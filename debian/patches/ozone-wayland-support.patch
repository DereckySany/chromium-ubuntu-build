Index: dev/README.md
===================================================================
--- dev.orig/README.md
+++ dev/README.md
@@ -1,11 +1,114 @@
-# ![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
+# Chromium for Wayland
 
-Chromium is an open-source browser project that aims to build a safer, faster,
-and more stable way for all users to experience the web.
+NOTE: All the work has moved to the Chromium mainline repository. This repo is being
+updated on a weekly basis and some patches may land here first. This is not a fork, but
+rather a downstream branch for first round reviews.
 
-The project's web site is https://www.chromium.org.
+The goal of this project is to enable
+[Chromium browser](https://www.chromium.org/) to run on
+[Wayland](https://wayland.freedesktop.org/). Note that contrary to
+[01.org/ozone-wayland](https://github.com/01org/ozone-wayland), the idea is
+to keep it very close to upstream developments as well as aligned on Google's own
+plans. In particular, this fork is rebased against
+[Chromium ToT](https://chromium.googlesource.com/chromium/src.git) each week
+and patches are upstreamed as soon as possible.
+
+The implementation also relies on actively developed Chromium technologies:
+
+* [Aura](https://www.chromium.org/developers/design-documents/aura/aura-overview) for the user interface and windowing.
+* [Ozone](https://chromium.googlesource.com/chromium/src/+/master/docs/ozone_overview.md) as a platform abstraction layer together with the [upstream Wayland backend](https://chromium.googlesource.com/chromium/src.git/+/master/ui/ozone/platform/wayland/).
+* [Mojo](https://chromium.googlesource.com/chromium/src/+/master/mojo) to perform IPC communication.
+
+Notice that the effort done here is also useful to run Chromium with Ozone on
+Linux Desktop for X11/Wayland.
+
+# What is Chromium browser?
+
+![Logo](chrome/app/theme/chromium/product_logo_64.png) Chromium
+
+[Chromium](https://www.chromium.org) is an open-source browser project that aims to build a safer, faster,
+and more stable way for all users to experience the Web.
 
 Documentation in the source is rooted in [docs/README.md](docs/README.md).
 
 Learn how to [Get Around the Chromium Source Code Directory Structure
 ](https://www.chromium.org/developers/how-tos/getting-around-the-chrome-source-code).
+
+# Building Chromium
+
+General information is provided by the upstream documentation for
+[Chromium on Linux](https://chromium.googlesource.com/chromium/src/+/master/docs/linux_build_instructions.md)
+and
+[Ozone](https://chromium.googlesource.com/chromium/src/+/master/docs/ozone_overview.md).
+Here is the summary of commands to build and run Chrome for Wayland:
+
+```
+gn args out/Ozone --args="use_ozone=true use_xkbcommon=true use_system_minigbm=true"
+ninja -C out/Ozone chrome
+./out/Ozone/chrome --ozone-platform=wayland
+
+Please note that Ozone/Wayland also supports GpuMemoryBuffers and in order to enable them, the --enable-native-gpu-buffers must be passed.
+
+Note that GN defaults to debug builds, which naturally take longer to finish and produce slower binaries at runtime. The 'is_debug=false' GN arguments disables it.
+
+Also note that some touch oriented Web pages like Google Maps, work better when the Touch Event API is explicitly enabled
+in chrome://flags or a command line argument --touch-events=enabled is passed.
+
+It is also possible to enable proprietary codecs (so that mp4, h264 medias play) with the following GN args: 'proprietary_codecs=true ffmpeg_branding=\"Chrome\"'.
+```
+
+By default, the `headless`, `x11` and `wayland` Ozone backends are
+compiled and X11 is selected when `--ozone-platform` is not specified.
+Please refer to the
+[GN Configuration notes](https://chromium.googlesource.com/chromium/src/+/master/docs/ozone_overview.md#GN-Configuration-notes) for details on how to change
+that behavior.
+
+# Running Tests
+
+To be added.
+
+# Rebase Strategy
+
+The fork is rebased every week against Chromium ToT.
+The goal is to be as close as possible to the latest code, which is
+constantly receiving performance and stability fixes.
+
+Here is the current process:
+
+* Every week, a member of the Igalia Chromium team takes the rebase shift.
+
+* Commits that are complementary of each other, receive a "fixup!" prefix on
+the commit title, and keep the rest of original commit title unchanged.
+
+For example:
+
+```
+$ git log --oneline
+commit 1
+commit 2
+commit 3
+fixup! commit 1
+fixup! commit 2
+commit 4
+fixup! commit 2
+(..)
+```
+
+This allows an easy identification of "fixup" commits, which should be squashed into
+their original counterpart commit as part of the next rebase cycle. That way we keep
+our Git history clean, and commits as atomic as possible, for when upstreaming.
+
+Git has [an optimized flow for this](http://fle.github.io/git-tip-keep-your-branch-clean-with-fixup-and-autosquash.html) as well.
+
+* We always keep the 'ozone-wayland-dev' branch as our primarily development branch.
+
+This means that force pushes will happen. So every time one of the team members
+rebases our branch, the developer should first back up the existing ozone-wayland-dev
+browser, with the following naming: ozone-wayland-dev-rXXXX, where XXXX is the respective
+Chromium baseline of the branch.
+
+* Branch acceptance criteria
+
+Make sure that the patches meet the [coding style](https://www.chromium.org/developers/coding-style) criteria.
+
+* Keep [our internal buildbot](https://build-chromium.igalia.com/) green.
Index: dev/chrome/browser/ui/views/tabs/window_finder_ozone.cc
===================================================================
--- dev.orig/chrome/browser/ui/views/tabs/window_finder_ozone.cc
+++ dev/chrome/browser/ui/views/tabs/window_finder_ozone.cc
@@ -2,7 +2,10 @@
 // Use of this source code is governed by a BSD-style license that can be
 // found in the LICENSE file.
 
+#include "chrome/browser/ui/browser_list.h"
+#include "chrome/browser/ui/browser_window.h"
 #include "chrome/browser/ui/views/tabs/window_finder.h"
+#include "ui/views/widget/widget.h"
 
 #include "base/stl_util.h"
 #include "ui/aura/window.h"
Index: dev/media/gpu/BUILD.gn
===================================================================
--- dev.orig/media/gpu/BUILD.gn
+++ dev/media/gpu/BUILD.gn
@@ -17,6 +17,7 @@ buildflag_header("buildflags") {
     "USE_VAAPI=$use_vaapi",
     "USE_V4L2_CODEC=$use_v4l2_codec",
     "USE_LIBV4L2=$use_v4lplugin",
+    "USE_LINUX_V4L2=$use_linux_v4l2_only",
   ]
 }
 
@@ -24,7 +25,7 @@ if (is_mac) {
   import("//build/config/mac/mac_sdk.gni")
 }
 
-if (is_chromeos && use_v4lplugin) {
+if (use_v4lplugin) {
   generate_stubs("libv4l2_stubs") {
     extra_header = "v4l2/v4l2_stub_header.fragment"
     sigs = [ "v4l2/v4l2.sig" ]
@@ -217,12 +218,8 @@ component("gpu") {
       "v4l2/v4l2_h264_accelerator.h",
       "v4l2/v4l2_image_processor.cc",
       "v4l2/v4l2_image_processor.h",
-      "v4l2/v4l2_jpeg_decode_accelerator.cc",
-      "v4l2/v4l2_jpeg_decode_accelerator.h",
       "v4l2/v4l2_jpeg_encode_accelerator.cc",
       "v4l2/v4l2_jpeg_encode_accelerator.h",
-      "v4l2/v4l2_slice_video_decode_accelerator.cc",
-      "v4l2/v4l2_slice_video_decode_accelerator.h",
       "v4l2/v4l2_video_decode_accelerator.cc",
       "v4l2/v4l2_video_decode_accelerator.h",
       "v4l2/v4l2_video_encode_accelerator.cc",
@@ -233,6 +230,15 @@ component("gpu") {
       "v4l2/v4l2_vp9_accelerator.h",
     ]
 
+    if (!use_linux_v4l2_only) {
+      sources += [
+        "v4l2_jpeg_decode_accelerator.cc",
+        "v4l2_jpeg_decode_accelerator.h",
+        "v4l2_slice_video_decode_accelerator.cc",
+        "v4l2_slice_video_decode_accelerator.h",
+      ]
+    }
+
     libs = [
       "EGL",
       "GLESv2",
Index: dev/media/gpu/args.gni
===================================================================
--- dev.orig/media/gpu/args.gni
+++ dev/media/gpu/args.gni
@@ -10,6 +10,10 @@ declare_args() {
   # platforms which have v4l2 hardware encoder / decoder.
   use_v4l2_codec = false
 
+  # Indicates that only definitions available in the mainline linux kernel
+  # will be used.
+  use_linux_v4l2_only = false
+
   # Indicates if VA-API-based hardware acceleration is to be used. This
   # is typically the case on x86-based ChromeOS devices.
   use_vaapi = false
Index: dev/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
===================================================================
--- dev.orig/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
+++ dev/media/gpu/gpu_jpeg_decode_accelerator_factory.cc
@@ -13,7 +13,8 @@
 #include "media/gpu/buildflags.h"
 #include "media/gpu/fake_jpeg_decode_accelerator.h"
 
-#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY)
+#if BUILDFLAG(USE_V4L2_CODEC) && defined(ARCH_CPU_ARM_FAMILY) && \
+    !BUILDFLAG(USE_LINUX_V4L2)
 #define USE_V4L2_JDA
 #endif
 
Index: dev/media/gpu/gpu_video_decode_accelerator_factory.cc
===================================================================
--- dev.orig/media/gpu/gpu_video_decode_accelerator_factory.cc
+++ dev/media/gpu/gpu_video_decode_accelerator_factory.cc
@@ -24,7 +24,9 @@
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
 #include "media/gpu/v4l2/v4l2_device.h"
+#if !BUILDFLAG(USE_LINUX_V4L2)
 #include "media/gpu/v4l2/v4l2_slice_video_decode_accelerator.h"
+#endif
 #include "media/gpu/v4l2/v4l2_video_decode_accelerator.h"
 #include "ui/gl/gl_surface_egl.h"
 #endif
@@ -67,10 +69,12 @@ gpu::VideoDecodeAcceleratorCapabilities
   vda_profiles = V4L2VideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
+#if !BUILDFLAG(USE_LINUX_V4L2)
   vda_profiles = V4L2SliceVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
       vda_profiles, &capabilities.supported_profiles);
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   vda_profiles = VaapiVideoDecodeAccelerator::GetSupportedProfiles();
   GpuVideoAcceleratorUtil::InsertUniqueDecodeProfiles(
@@ -164,8 +168,10 @@ GpuVideoDecodeAcceleratorFactory::Create
 #endif
 #if BUILDFLAG(USE_V4L2_CODEC)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2VDA,
+#if !BUILDFLAG(USE_LINUX_V4L2)
     &GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA,
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
     &GpuVideoDecodeAcceleratorFactory::CreateVaapiVDA,
 #endif
@@ -221,6 +227,7 @@ GpuVideoDecodeAcceleratorFactory::Create
   return decoder;
 }
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
 std::unique_ptr<VideoDecodeAccelerator>
 GpuVideoDecodeAcceleratorFactory::CreateV4L2SVDA(
     const gpu::GpuDriverBugWorkarounds& workarounds,
@@ -236,6 +243,7 @@ GpuVideoDecodeAcceleratorFactory::Create
   return decoder;
 }
 #endif
+#endif
 
 #if BUILDFLAG(USE_VAAPI)
 std::unique_ptr<VideoDecodeAccelerator>
Index: dev/media/gpu/gpu_video_decode_accelerator_factory.h
===================================================================
--- dev.orig/media/gpu/gpu_video_decode_accelerator_factory.h
+++ dev/media/gpu/gpu_video_decode_accelerator_factory.h
@@ -111,11 +111,13 @@ class MEDIA_GPU_EXPORT GpuVideoDecodeAcc
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
+#if !BUILDFLAG(USE_LINUX_V4L2)
   std::unique_ptr<VideoDecodeAccelerator> CreateV4L2SVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
       const gpu::GpuPreferences& gpu_preferences,
       MediaLog* media_log) const;
 #endif
+#endif
 #if BUILDFLAG(USE_VAAPI)
   std::unique_ptr<VideoDecodeAccelerator> CreateVaapiVDA(
       const gpu::GpuDriverBugWorkarounds& workarounds,
Index: dev/media/gpu/v4l2/generic_v4l2_device.cc
===================================================================
--- dev.orig/media/gpu/v4l2/generic_v4l2_device.cc
+++ dev/media/gpu/v4l2/generic_v4l2_device.cc
@@ -100,10 +100,20 @@ void* GenericV4L2Device::Mmap(void* addr
                               int flags,
                               unsigned int offset) {
   DCHECK(device_fd_.is_valid());
+#if BUILDFLAG(USE_LIBV4L2)
+  if (use_libv4l2_)
+    return v4l2_mmap(addr, len, prot, flags, device_fd_.get(), offset);
+#endif
   return mmap(addr, len, prot, flags, device_fd_.get(), offset);
 }
 
 void GenericV4L2Device::Munmap(void* addr, unsigned int len) {
+#if BUILDFLAG(USE_LIBV4L2)
+  if (use_libv4l2_) {
+    v4l2_munmap(addr, len);
+    return;
+  }
+#endif
   munmap(addr, len);
 }
 
@@ -479,9 +489,13 @@ bool GenericV4L2Device::OpenDevicePath(c
     return false;
 
 #if BUILDFLAG(USE_LIBV4L2)
+#if BUILDFLAG(USE_LINUX_V4L2)
+  if (
+#else
   if (type == Type::kEncoder &&
+#endif
       HANDLE_EINTR(v4l2_fd_open(device_fd_.get(), V4L2_DISABLE_CONVERSION)) !=
-          -1) {
+      -1) {
     VLOGF(2) << "Using libv4l2 for " << path;
     use_libv4l2_ = true;
   }
Index: dev/media/gpu/v4l2/v4l2.sig
===================================================================
--- dev.orig/media/gpu/v4l2/v4l2.sig
+++ dev/media/gpu/v4l2/v4l2.sig
@@ -8,3 +8,5 @@
 LIBV4L_PUBLIC int v4l2_close(int fd);
 LIBV4L_PUBLIC int v4l2_ioctl(int fd, unsigned long int request, ...);
 LIBV4L_PUBLIC int v4l2_fd_open(int fd, int v4l2_flags);
+LIBV4L_PUBLIC void *v4l2_mmap(void *start, size_t length, int prot, int flags, int fd, int64_t offset);
+LIBV4L_PUBLIC int v4l2_munmap(void *_start, size_t length);
Index: dev/media/gpu/v4l2/v4l2_device.cc
===================================================================
--- dev.orig/media/gpu/v4l2/v4l2_device.cc
+++ dev/media/gpu/v4l2/v4l2_device.cc
@@ -978,6 +978,21 @@ uint32_t V4L2Device::VideoFrameLayoutToV
                                       layout.num_buffers() == 1);
 }
 
+
+// static
+#if BUILDFLAG(USE_LINUX_V4L2)
+uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
+                                                   bool slice_based) {
+  if (profile >= H264PROFILE_MIN && profile <= H264PROFILE_MAX) {
+    return V4L2_PIX_FMT_H264;
+  } else if (profile >= VP8PROFILE_MIN && profile <= VP8PROFILE_MAX) {
+    return V4L2_PIX_FMT_VP8;
+  } else {
+    LOG(FATAL) << "Add more cases as needed";
+    return 0;
+  }
+}
+#else
 // static
 uint32_t V4L2Device::VideoCodecProfileToV4L2PixFmt(VideoCodecProfile profile,
                                                    bool slice_based) {
@@ -1019,6 +1034,7 @@ VideoCodecProfile V4L2Device::V4L2VP9Pro
       return VIDEO_CODEC_PROFILE_UNKNOWN;
   }
 }
+#endif
 
 // static
 std::vector<VideoCodecProfile> V4L2Device::V4L2PixFmtToVideoCodecProfiles(
@@ -1029,7 +1045,9 @@ std::vector<VideoCodecProfile> V4L2Devic
 
   switch (pix_fmt) {
     case V4L2_PIX_FMT_H264:
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_H264_SLICE:
+#endif
       if (is_encoder) {
         // TODO(posciak): need to query the device for supported H.264 profiles,
         // for now choose Main as a sensible default.
@@ -1042,11 +1060,14 @@ std::vector<VideoCodecProfile> V4L2Devic
       break;
 
     case V4L2_PIX_FMT_VP8:
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP8_FRAME:
+#endif
       min_profile = VP8PROFILE_MIN;
       max_profile = VP8PROFILE_MAX;
       break;
 
+#if !BUILDFLAG(USE_LINUX_V4L2)
     case V4L2_PIX_FMT_VP9:
     case V4L2_PIX_FMT_VP9_FRAME: {
       v4l2_queryctrl query_ctrl = {};
@@ -1073,6 +1094,7 @@ std::vector<VideoCodecProfile> V4L2Devic
       }
       break;
     }
+#endif
 
     default:
       VLOGF(1) << "Unhandled pixelformat " << FourccToString(pix_fmt);
@@ -1103,7 +1125,10 @@ uint32_t V4L2Device::V4L2PixFmtToDrmForm
       return DRM_FORMAT_ARGB8888;
 
     case V4L2_PIX_FMT_MT21C:
+#if !BUILDFLAG(USE_LINUX_V4L2)
+    case V4L2_PIX_FMT_MT21:
       return DRM_FORMAT_MT21;
+#endif
 
     default:
       DVLOGF(1) << "Unrecognized format " << FourccToString(format);
Index: dev/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
===================================================================
--- dev.orig/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
+++ dev/media/gpu/v4l2/v4l2_video_decode_accelerator.cc
@@ -33,6 +33,7 @@
 #include "media/base/video_types.h"
 #include "media/gpu/image_processor_factory.h"
 #include "media/gpu/macros.h"
+#include "media/gpu/buildflags.h"
 #include "media/gpu/v4l2/v4l2_image_processor.h"
 #include "media/video/h264_parser.h"
 #include "ui/gfx/geometry/rect.h"
@@ -82,7 +83,10 @@ size_t GetNumPlanesOfV4L2PixFmt(uint32_t
 
 // static
 const uint32_t V4L2VideoDecodeAccelerator::supported_input_fourccs_[] = {
-    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8, V4L2_PIX_FMT_VP9,
+    V4L2_PIX_FMT_H264, V4L2_PIX_FMT_VP8,
+#if !BUILDFLAG(USE_LINUX_V4L2)
+    V4L2_PIX_FMT_VP9,
+#endif
 };
 
 struct V4L2VideoDecodeAccelerator::BitstreamBufferRef {
Index: dev/media/gpu/vaapi/BUILD.gn
===================================================================
--- dev.orig/media/gpu/vaapi/BUILD.gn
+++ dev/media/gpu/vaapi/BUILD.gn
@@ -94,12 +94,12 @@ source_set("vaapi") {
     ]
   }
 
-  if (ozone_platform_gbm || use_egl) {
+  if (ozone_platform_wayland || ozone_platform_gbm || use_egl) {
     sources += [
       "vaapi_picture_native_pixmap.cc",
       "vaapi_picture_native_pixmap.h",
     ]
-    if (ozone_platform_gbm) {
+    if (ozone_platform_gbm || ozone_platform_wayland) {
       sources += [
         "vaapi_picture_native_pixmap_ozone.cc",
         "vaapi_picture_native_pixmap_ozone.h",
Index: dev/testing/buildbot/filters/ozone.browser_tests.filter
===================================================================
--- /dev/null
+++ dev/testing/buildbot/filters/ozone.browser_tests.filter
@@ -0,0 +1,307 @@
+#194 tests failed: It happens with upstream "ozone". (21/Nov/2018)
+-AppInfoDialogBrowserTest.InvokeUi_default
+-AskGoogleForSuggestionsDialogTest.InvokeUi_default
+-AuthenticatorDialogTest.InvokeUi_activate_usb
+-AuthenticatorDialogTest.InvokeUi_ble_activate
+-AuthenticatorDialogTest.InvokeUi_ble_device_selection
+-AuthenticatorDialogTest.InvokeUi_ble_enter_pairing_mode
+-AuthenticatorDialogTest.InvokeUi_ble_pairing_begin
+-AuthenticatorDialogTest.InvokeUi_ble_pin_entry
+-AuthenticatorDialogTest.InvokeUi_ble_power_on_manual
+-AuthenticatorDialogTest.InvokeUi_ble_verifying
+-AuthenticatorDialogTest.InvokeUi_cable_activate
+-AuthenticatorDialogTest.InvokeUi_closed
+-AuthenticatorDialogTest.InvokeUi_default
+-AuthenticatorDialogTest.InvokeUi_key_already_registered
+-AuthenticatorDialogTest.InvokeUi_key_not_registered
+-AuthenticatorDialogTest.InvokeUi_no_available_transports
+-AuthenticatorDialogTest.InvokeUi_timeout
+-AuthenticatorDialogTest.InvokeUi_touchid
+-AuthenticatorDialogTest.InvokeUi_transports
+-AuthenticatorDialogViewTest.InvokeUi_default
+-BluetoothChooserBrowserTest.InvokeUi_ConnectedBubble
+-BluetoothChooserBrowserTest.InvokeUi_ConnectedModal
+-BluetoothChooserBrowserTest.InvokeUi_NoDevicesBubble
+-BluetoothChooserBrowserTest.InvokeUi_NoDevicesModal
+-BluetoothChooserBrowserTest.InvokeUi_PairedBubble
+-BluetoothChooserBrowserTest.InvokeUi_PairedModal
+-BluetoothChooserBrowserTest.InvokeUi_ScanningBubble
+-BluetoothChooserBrowserTest.InvokeUi_ScanningModal
+-BluetoothChooserBrowserTest.InvokeUi_ScanningWithDevicesBubble
+-BluetoothChooserBrowserTest.InvokeUi_ScanningWithDevicesModal
+-BluetoothChooserBrowserTest.InvokeUi_UnavailableBubble
+-BluetoothChooserBrowserTest.InvokeUi_UnavailableModal
+-BookmarkAppHelperTest.InvokeUi_CreateBookmarkApp
+-BookmarkAppHelperTest.InvokeUi_CreateWindowedPWA
+-BookmarkBubbleViewBrowserTest.InvokeUi_bookmark_details
+-BookmarkBubbleViewBrowserTest.InvokeUi_bookmark_details_signed_in
+-BookmarkEditorViewBrowserTest.InvokeUi_all_tabs
+-BrowserActionApiTest.BrowserActionOpenPopupOnPopup
+-BrowserTest.DialogsDropFullscreen
+-BrowserViewTest.GetAccessibleTabModalDialogTitle
+-CardUnmaskPromptViewBrowserTest.InvokeUi_expired
+-CardUnmaskPromptViewBrowserTest.InvokeUi_valid
+-CertificateSelectorDialogTest.InvokeUi_default
+-CollectedCookiesTest.InvokeUi_default
+-ContentSettingBubbleDialogTest.InvokeUi_ads
+-ContentSettingBubbleDialogTest.InvokeUi_automatic_downloads
+-ContentSettingBubbleDialogTest.InvokeUi_cookies
+-ContentSettingBubbleDialogTest.InvokeUi_geolocation
+-ContentSettingBubbleDialogTest.InvokeUi_images
+-ContentSettingBubbleDialogTest.InvokeUi_javascript
+-ContentSettingBubbleDialogTest.InvokeUi_mediastream_camera
+-ContentSettingBubbleDialogTest.InvokeUi_mediastream_mic
+-ContentSettingBubbleDialogTest.InvokeUi_mediastream_mic_and_camera
+-ContentSettingBubbleDialogTest.InvokeUi_midi_sysex
+-ContentSettingBubbleDialogTest.InvokeUi_mixed_script
+-ContentSettingBubbleDialogTest.InvokeUi_plugins
+-ContentSettingBubbleDialogTest.InvokeUi_popups
+-ContentSettingBubbleDialogTest.InvokeUi_ppapi_broker
+-ContentSettingBubbleDialogTest.InvokeUi_protocol_handlers
+-DesktopCaptureApiTest.ChooseDesktopMedia
+-DesktopMediaPickerViewsBrowserTest.InvokeUi_default
+-DownloadDangerPromptBrowserTest.InvokeUi_DangerousFile
+-DownloadDangerPromptBrowserTest.InvokeUi_DangerousFileFromApi
+-DownloadDangerPromptBrowserTest.InvokeUi_DangerousUrl
+-DownloadDangerPromptBrowserTest.InvokeUi_DangerousUrlFromApi
+-DownloadDangerPromptBrowserTest.InvokeUi_PotentiallyUnwanted
+-DownloadDangerPromptBrowserTest.InvokeUi_PotentiallyUnwantedFromApi
+-DownloadDangerPromptBrowserTest.InvokeUi_UncommonContent
+-DownloadDangerPromptBrowserTest.InvokeUi_UncommonContentFromApi
+-ExtensionBlockedActionsBubbleTest.InvokeUi_ExtensionBlockedActionsBubble
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_AllInfoTypes
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_DetailedPermission
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_External
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_ExternalWithPermission
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_FromWebstore
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_FromWebstoreWithPermission
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_ManyPermissions
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_MultilinePermission
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_ReEnable
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_Simple
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_WithRetainedDevices
+-ExtensionInstallDialogViewInteractiveBrowserTest.InvokeUi_WithRetainedFiles
+-ExtensionMessageBubbleViewBrowserTest.InvokeUi_devmode_warning
+-ExtensionUninstallDialogViewInteractiveBrowserTest.InvokeUi_ManualUninstall
+-ExtensionUninstallDialogViewInteractiveBrowserTest.InvokeUi_ManualUninstallShowReportAbuse
+-ExtensionUninstallDialogViewInteractiveBrowserTest.InvokeUi_UninstallByExtension
+-ExtensionUninstallDialogViewInteractiveBrowserTest.InvokeUi_UninstallByExtensionShowReportAbuse
+-ExtensionWindowCreateTest.AcceptState
+-ExternalProtocolDialogBrowserTest.InvokeUi_default
+-FeaturePromoDialogTest.InvokeUi_FeaturePromo
+-FolderUploadConfirmationViewTest.InitiallyFocusesCancel
+-FolderUploadConfirmationViewTest.InvokeUi_default
+-FullscreenControllerTest.FastKeyboardLockUnlockRelock
+-FullscreenControllerTest.FullscreenOnFileURL
+-FullscreenControllerTest.KeyboardLockAfterMouseLock
+-FullscreenControllerTest.KeyboardLockAfterMouseLockWithEscLocked
+-FullscreenControllerTest.KeyboardLockBubbleHideCallbackUnlock
+-FullscreenControllerTest.KeyboardLockCycleWithMixedEscLockStates
+-FullscreenControllerTest.KeyboardLockDoesNotExitOnEscPressWhenEscIsLocked
+-FullscreenControllerTest.KeyboardLockExitsOnEscPressWhenEscNotLocked
+-FullscreenControllerTest.KeyboardLockNotLockedAfterFullscreenTransition
+-FullscreenControllerTest.KeyboardLockNotLockedInExtensionFullscreenMode
+-FullscreenControllerTest.KeyboardLockOnFileURLWithEscLocked
+-FullscreenControllerTest.KeyboardLockOnFileURLWithEscUnlocked
+-FullscreenControllerTest.KeyboardLockWithEscLocked
+-FullscreenControllerTest.KeyboardLockWithEscUnlocked
+-FullscreenControllerTest.MouseLockAfterKeyboardLock
+-FullscreenControllerTest.MouseLockAfterKeyboardLockWithEscLocked
+-FullscreenControllerTest.RepeatedEscEventsOutsideWindowDoesNotShowExitBubble
+-FullscreenControllerTest.RepeatedEscEventsWithinWindowReshowsExitBubble
+-FullscreenControllerTest.SlowKeyboardLockUnlockRelock
+-FullscreenControllerTest.TopViewStatusChange
+-GlobalErrorBubbleTest.InvokeUi_ExtensionDisabledGlobalError
+-GlobalErrorBubbleTest.InvokeUi_ExtensionDisabledGlobalErrorRemote
+-GlobalErrorBubbleTest.InvokeUi_ExternalInstallBubbleAlert
+-GlobalErrorBubbleTest.InvokeUi_SigninGlobalError
+-HatsBubbleTest.InvokeUi_default
+-HostedAppOpaqueBrowserFrameViewTest.DarkThemeColor
+-HostedAppOpaqueBrowserFrameViewTest.LightThemeColor
+-HostedAppOpaqueBrowserFrameViewTest.MediumThemeColor
+-HostedAppOpaqueBrowserFrameViewTest.SystemThemeColor
+-InputImeApiTest.SendKeyEventsOnNormalPage
+-LocalNTPVoiceJavascriptTest.TextTests
+-MediaGalleriesInteractiveDialogTest.InvokeUi_DisplayDialog
+-OmniboxPopupContentsViewTest.PopupMatchesLocationBarBackground
+-OmniboxPopupContentsViewTest.ThemeIntegration
+-OutOfProcessPPAPITest.Printing
+-OutdatedUpgradeBubbleTest.InvokeUi_NoAutoUpdate
+-OutdatedUpgradeBubbleTest.InvokeUi_Outdated
+-PWAConfirmationViewTest.InvokeUi_long_text
+-PWAConfirmationViewTest.InvokeUi_rtl
+-PWAConfirmationViewTest.InvokeUi_short_text
+-PageInfoBubbleViewBrowserTest.InvokeUi_AllowAllPermissions
+-PageInfoBubbleViewBrowserTest.InvokeUi_BlockAllPermissions
+-PageInfoBubbleViewBrowserTest.InvokeUi_Deceptive
+-PageInfoBubbleViewBrowserTest.InvokeUi_File
+-PageInfoBubbleViewBrowserTest.InvokeUi_Insecure
+-PageInfoBubbleViewBrowserTest.InvokeUi_Internal
+-PageInfoBubbleViewBrowserTest.InvokeUi_InternalExtension
+-PageInfoBubbleViewBrowserTest.InvokeUi_InternalViewSource
+-PageInfoBubbleViewBrowserTest.InvokeUi_Malware
+-PageInfoBubbleViewBrowserTest.InvokeUi_MixedContent
+-PageInfoBubbleViewBrowserTest.InvokeUi_MixedContentForm
+-PageInfoBubbleViewBrowserTest.InvokeUi_PasswordReuse
+-PageInfoBubbleViewBrowserTest.InvokeUi_Secure
+-PageInfoBubbleViewBrowserTest.InvokeUi_UnwantedSoftware
+-PasswordBubbleBrowserTest.InvokeUi_AutoSignin
+-PasswordBubbleBrowserTest.InvokeUi_AutomaticPasswordBubble
+-PasswordBubbleBrowserTest.InvokeUi_PendingPasswordBubble
+-PasswordDialogViewTest.InvokeUi_AutoSigninFirstRun
+-PasswordDialogViewTest.InvokeUi_PopupAccountChooserWithMultipleCredentialClickSignIn
+-PasswordDialogViewTest.InvokeUi_PopupAccountChooserWithSingleCredentialClickSignIn
+-PasswordDialogViewTest.InvokeUi_PopupAutoSigninPrompt
+-PasswordManagerDialogBrowserTest.InvokeUi_normal
+-PasswordReuseModalWarningTest.InvokeUi_default
+-PaymentRequestCreditCardEditorTest.EditingExpiredCard
+-PaymentRequestShippingAddressEditorTest.FocusFirstField_Name
+-PaymentRequestShippingAddressEditorTest.FocusFirstInvalidField_NotName
+-PaymentsRequestVisualTest.InvokeUi_NoShipping
+-PermissionDialogTest.InvokeUi_camera
+-PermissionDialogTest.InvokeUi_flash
+-PermissionDialogTest.InvokeUi_geolocation
+-PermissionDialogTest.InvokeUi_mic
+-PermissionDialogTest.InvokeUi_midi
+-PermissionDialogTest.InvokeUi_multiple
+-PermissionDialogTest.InvokeUi_notifications
+-PermissionDialogTest.InvokeUi_protocol_handlers
+-PresentationReceiverWindowControllerBrowserTest.CreatesWindow
+-ProfileChooserViewExtensionsTest.InvokeUi_Guest
+-ProfileChooserViewExtensionsTest.InvokeUi_ManageAccountLink
+-ProfileChooserViewExtensionsTest.InvokeUi_MultiProfile
+-ProfileChooserViewExtensionsTest.InvokeUi_SignedIn
+-ProfileChooserViewExtensionsTest.InvokeUi_SupervisedOwner
+-ProfileChooserViewExtensionsTest.InvokeUi_default
+-ProfileSigninConfirmationDialogTest.InvokeUi_default
+-RelaunchRecommendedBubbleViewDialogTest.InvokeUi_default
+-RelaunchRequiredDialogViewDialogTest.InvokeUi_default
+-RepostFormWarningTest.InvokeUi_TestRepostWarning
+-SaveCardBubbleControllerImplTest.InvokeUi_Local
+-SaveCardBubbleControllerImplTest.InvokeUi_Manage
+-SaveCardBubbleControllerImplTest.InvokeUi_Server
+-SaveCardBubbleControllerImplTest.InvokeUi_Server_WithCardExpirationDateDropDownBox
+-SaveCardBubbleControllerImplTest.InvokeUi_Server_WithCardholderNameTextfield
+-SessionCrashedBubbleViewTest.InvokeUi_SessionCrashedBubble
+-SessionCrashedBubbleViewTest.InvokeUi_SessionCrashedBubbleOfferUma
+-UpdateRecommendedDialogTest.InvokeUi_default
+-UsbChooserBrowserTest.InvokeUi_NoDevicesBubble
+-UsbChooserBrowserTest.InvokeUi_NoDevicesModal
+-UsbChooserBrowserTest.InvokeUi_WithDevicesBubble
+-UsbChooserBrowserTest.InvokeUi_WithDevicesModal
+-ZoomBubbleBrowserTest.NonImmersiveFullscreen
+-ZoomBubbleDialogTest.InvokeUi_default
+# Failed on the stock Chromium as well.
+-PaymentRequestShippingAddressEditorTest.AddImpossiblePhoneNumber
+-PaymentRequestShippingAddressEditorTest.AsyncData
+#26 tests timed out: It happens with upstream "ozone". (21/Nov/2018)
+-AutomationManagerAuraBrowserTest.TransientFocusChangesAreSuppressed
+-ChromeSitePerProcessTest.PopupWindowFocus
+-ExtensionWindowLastFocusedTest.NoDevtoolsAndAppWindows
+-ExtensionWindowLastFocusedTest.NoTabIdForDevToolsAndAppWindows
+-MachineLevelUserCloudPolicyEnrollmentTest.Test/0
+-MachineLevelUserCloudPolicyEnrollmentTest.Test/1
+-NavigationConsumingTest.NavigationConsumesUserGesture_Fullscreen
+-PDFExtensionClipboardTest.CombinedShiftArrowPresses
+-PDFExtensionClipboardTest.CombinedShiftRightArrowPresses
+-PDFExtensionClipboardTest.IndividualShiftRightArrowPresses
+-PDFExtensionTest.PdfZoomWithoutBubble
+-PictureInPictureWindowControllerBrowserTest.EnterFullscreenThenPictureInPicture
+-PictureInPictureWindowControllerBrowserTest.EnterPictureInPictureThenFullscreen
+-PluginPowerSaverBrowserTest.BlockTinyPlugins
+-PluginPowerSaverBrowserTest.EssentialPlugins
+-PluginPowerSaverBrowserTest.ExpandingSmallPlugin
+-PluginPowerSaverBrowserTest.ExpandingTinyPlugins
+-PluginPowerSaverBrowserTest.LargePostersNotThrottled
+-PluginPowerSaverBrowserTest.OriginWhitelisting
+-PluginPowerSaverBrowserTest.PosterTests
+-PluginPowerSaverBrowserTest.RunAllFlashInAllowMode
+-PluginPowerSaverBrowserTest.SmallCrossOrigin
+-PluginPowerSaverBrowserTest.SmallerThanPlayIcon
+-PluginPowerSaverBrowserTest.ZoomIndependent
+-ProfileHelperTest.OpenNewWindowForProfile
+-ProfileWindowBrowserTest.OpenBrowserWindowForProfileWithSigninRequired
+-MachineLevelUserCloudPolicyEnrollmentTest.Test/3
+#57 tests crashed: It happens with upstream "ozone". (21/Nov/2018)
+-AppBackgroundPageApiTest.NoJsBackgroundPage
+-BrowserViewTest.CloseWithTabs
+-BrowserViewTest.CloseWithTabsStartWithActive
+-CardUnmaskPromptViewBrowserTest.InvokeUi_valid_PermanentError
+-CardUnmaskPromptViewBrowserTest.InvokeUi_valid_TemporaryError
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.CrossSiteIframeBecomesSameSite/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.KillSubframe/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.LeavePageWithCrossSiteIframes/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.NavigateToSiteWithSubframeToOriginalSite/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.NavigateToSubframeProcess/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.OrderingOfDependentRows/0
+-DefaultIsolation/TaskManagerOOPIFBrowserTest.SubframeHistoryNavigation/0
+-EnterpriseStartupDialogViewBrowserTest.InvokeUi_Error
+-EnterpriseStartupDialogViewBrowserTest.InvokeUi_Information
+-EnterpriseStartupDialogViewBrowserTest.InvokeUi_Switch
+-FirstRunInternalPosixTest.HandleSigterm
+-ImportLockDialogViewBrowserTest.InvokeUi_default
+-IncognitoWindowTrackerBrowserTest.ShowPromo
+-NewTabTrackerBrowserTest.TestShowPromo
+-OutOfProcessPPAPITest.FlashFullscreen
+-PrerenderBrowserTest.OpenTaskManagerAfterPrerender
+-PrerenderBrowserTest.OpenTaskManagerAfterSwapIn
+-PrerenderBrowserTest.OpenTaskManagerBeforePrerender
+-ScreenCaptureNotificationUiBrowserTest.InvokeUi
+-SitePerProcess/TaskManagerOOPIFBrowserTest.CrossSiteIframeBecomesSameSite/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.KillSubframe/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.LeavePageWithCrossSiteIframes/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.NavigateToSiteWithSubframeToOriginalSite/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.NavigateToSubframeProcess/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.OrderingOfDependentRows/0
+-SitePerProcess/TaskManagerOOPIFBrowserTest.SubframeHistoryNavigation/0
+-StartupHelperBrowserTest.ValidateCrx
+-TaskManagerBrowserTest.DevToolsNewDockedWindow
+-TaskManagerBrowserTest.DevToolsNewUndockedWindow
+-TaskManagerBrowserTest.DevToolsOldDockedWindow
+-TaskManagerBrowserTest.DevToolsOldUndockedWindow
+-TaskManagerBrowserTest.HistoryNavigationInNewTab
+-TaskManagerBrowserTest.IdleWakeups
+-TaskManagerBrowserTest.JSHeapMemory
+-TaskManagerBrowserTest.KillTab
+-TaskManagerBrowserTest.NavigateAwayFromHungRenderer
+-TaskManagerBrowserTest.NoticeAppTab
+-TaskManagerBrowserTest.NoticeAppTabChanges
+-TaskManagerBrowserTest.NoticeExtensionTab
+-TaskManagerBrowserTest.NoticeExtensionTabChanges
+-TaskManagerBrowserTest.NoticeHostedAppTabAfterReload
+-TaskManagerBrowserTest.NoticeHostedAppTabBeforeReload
+-TaskManagerBrowserTest.NoticeHostedAppTabChanges
+-TaskManagerBrowserTest.NoticeTabContentsChanges
+-TaskManagerBrowserTest.ReloadExtension
+-TaskManagerBrowserTest.SentDataObserved
+-TaskManagerBrowserTest.TotalSentDataObserved
+-TaskManagerBrowserTest.WebWorkerJSHeapMemory
+-TaskManagerUtilityProcessBrowserTest.UtilityJSHeapMemory
+-WebRtcDesktopCaptureBrowserTest.RunsScreenshareFromOneTabToAnother
+-WebRtcGetDisplayMediaBrowserTestWithPicker.GetDisplayMediaVideo
+-WebViewTest.TaskManagerExistingWebView
+-WebViewTest.TaskManagerNewWebView
+#The following cases happen on Igalia Buildbot.
+#7 tests failed:
+-PaymentRequestShippingAddressEditorTest.AddPossiblePhoneNumber
+-ProcessMemoryMetricsEmitterTest.FetchAndEmitMetrics
+-ProcessMemoryMetricsEmitterTest.FetchAndEmitMetricsWithExtensions
+-ProcessMemoryMetricsEmitterTest.FetchAndEmitMetricsWithHostedApps
+-ProcessMemoryMetricsEmitterTest.FetchDuringTrace
+-ProcessMemoryMetricsEmitterTest.FetchThreeTimes
+-ProcessMemoryMetricsEmitterTest.ForegroundAndBackgroundPages
+#2 tests failed: due to using no-sandbox switch
+-SandboxStatusUITest.testBPFSandboxEnabled
+-SandboxStatusUITest.testSUIDorNamespaceSandboxEnabled
+#2 tests timed out:
+-MediaGalleriesGalleryWatchApiTest.CorrectResponseOnModifyingWatchedGallery
+-MediaGalleriesGalleryWatchApiTest.RemoveListenerAndModifyGallery
+
+#Failed:
+-OmniboxPopupContentsViewTest.ClickOmnibox
+-ProfileChooserViewExtensionsTest.InvokeUi_DiceGuest
+-TabHoverCardBubbleViewBrowserTest.InvokeUi_tab_hover_card
+
+#Timed out
+-MediaGalleriesGalleryWatchApiTest.BasicGalleryWatch
+-StartupBrowserCreatorTest.UpdateWithTwoProfiles
Index: dev/ui/base/BUILD.gn
===================================================================
--- dev.orig/ui/base/BUILD.gn
+++ dev/ui/base/BUILD.gn
@@ -436,9 +436,12 @@ jumbo_component("base") {
     deps += [ "//ui/events" ]
   }
 
+  if (use_x11 || ozone_platform_x11) {
+    configs += [ "//build/config/linux:x11" ]
+  }
+
   if (use_x11) {
     public_deps += [ "//ui/base/x" ]
-    configs += [ "//build/config/linux:x11" ]
 
     if (!is_chromeos) {
       sources += [
@@ -452,30 +455,44 @@ jumbo_component("base") {
     }
   }
 
-  if (use_x11 && use_aura) {
+  if ((use_x11 || ozone_platform_x11) && use_aura) {
     sources += [
-      "cursor/cursor_loader_x11.cc",
-      "cursor/cursor_loader_x11.h",
-      "cursor/cursor_x11.cc",
       "x/selection_owner.cc",
       "x/selection_owner.h",
-      "x/selection_requestor.cc",
-      "x/selection_requestor.h",
       "x/selection_utils.cc",
       "x/selection_utils.h",
     ]
-    deps += [
-      "//ui/events/platform/x11",
-      "//ui/gfx/x",
-    ]
 
     if (!is_chromeos) {
       # These Aura X11 files aren't used on ChromeOS.
       sources += [
-        "dragdrop/os_exchange_data_provider_aurax11.cc",
-        "dragdrop/os_exchange_data_provider_aurax11.h",
+        "dragdrop/os_exchange_data_provider_aurax11_base.cc",
+        "dragdrop/os_exchange_data_provider_aurax11_base.h",
+      ]
+    }
+
+    if (use_x11 && use_aura) {
+      sources += [
+        "cursor/cursor_loader_x11.cc",
+        "cursor/cursor_loader_x11.h",
+        "cursor/cursor_x11.cc",
+        "x/selection_requestor.cc",
+        "x/selection_requestor.h",
       ]
+
+      if (!is_chromeos) {
+        # These Aura X11 files aren't used on ChromeOS.
+        sources += [
+          "dragdrop/os_exchange_data_provider_aurax11.cc",
+          "dragdrop/os_exchange_data_provider_aurax11.h",
+        ]
+      }
     }
+
+    deps += [
+      "//ui/events/platform/x11",
+      "//ui/gfx/x",
+    ]
   }
 
   if (use_aura) {
Index: dev/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
===================================================================
--- dev.orig/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
+++ dev/ui/base/dragdrop/os_exchange_data_provider_aurax11.cc
@@ -7,14 +7,7 @@
 #include <utility>
 
 #include "base/logging.h"
-#include "base/memory/ref_counted_memory.h"
-#include "base/strings/string_split.h"
-#include "base/strings/string_util.h"
-#include "base/strings/utf_string_conversions.h"
-#include "net/base/filename_util.h"
 #include "ui/base/clipboard/clipboard_constants.h"
-#include "ui/base/clipboard/clipboard_format_type.h"
-#include "ui/base/dragdrop/file_info.h"
 #include "ui/base/x/selection_utils.h"
 #include "ui/events/platform/platform_event_source.h"
 #include "ui/gfx/x/x11_atom_cache.h"
@@ -26,68 +19,19 @@
 
 namespace ui {
 
-namespace {
-
-const char kDndSelection[] = "XdndSelection";
-const char kRendererTaint[] = "chromium/x-renderer-taint";
-
-const char kNetscapeURL[] = "_NETSCAPE_URL";
-
-}  // namespace
-
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11(
     ::Window x_window,
     const SelectionFormatMap& selection)
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(false),
-      x_window_(x_window),
-      format_map_(selection),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+    : OSExchangeDataProviderAuraX11Base(x_window, selection) {}
 
 OSExchangeDataProviderAuraX11::OSExchangeDataProviderAuraX11()
-    : x_display_(gfx::GetXDisplay()),
-      x_root_window_(DefaultRootWindow(x_display_)),
-      own_window_(true),
-      x_window_(XCreateWindow(x_display_,
-                              x_root_window_,
-                              -100,
-                              -100,
-                              10,
-                              10,              // x, y, width, height
-                              0,               // border width
-                              CopyFromParent,  // depth
-                              InputOnly,
-                              CopyFromParent,  // visual
-                              0,
-                              NULL)),
-      format_map_(),
-      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
-  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
-
+    : OSExchangeDataProviderAuraX11Base() {
   PlatformEventSource::GetInstance()->AddPlatformEventDispatcher(this);
 }
 
 OSExchangeDataProviderAuraX11::~OSExchangeDataProviderAuraX11() {
-  if (own_window_) {
+  if (own_window_)
     PlatformEventSource::GetInstance()->RemovePlatformEventDispatcher(this);
-    XDestroyWindow(x_display_, x_window_);
-  }
-}
-
-void OSExchangeDataProviderAuraX11::TakeOwnershipOfSelection() const {
-  selection_owner_.TakeOwnershipOfSelection(format_map_);
-}
-
-void OSExchangeDataProviderAuraX11::RetrieveTargets(
-    std::vector<Atom>* targets) const {
-  selection_owner_.RetrieveTargets(targets);
-}
-
-SelectionFormatMap OSExchangeDataProviderAuraX11::GetFormatMap() const {
-  // We return the |selection_owner_|'s format map instead of our own in case
-  // ours has been modified since TakeOwnershipOfSelection() was called.
-  return selection_owner_.selection_format_map();
 }
 
 std::unique_ptr<OSExchangeData::Provider>
@@ -98,300 +42,6 @@ OSExchangeDataProviderAuraX11::Clone() c
   return std::move(ret);
 }
 
-void OSExchangeDataProviderAuraX11::MarkOriginatedFromRenderer() {
-  std::string empty;
-  format_map_.Insert(gfx::GetAtom(kRendererTaint),
-                     scoped_refptr<base::RefCountedMemory>(
-                         base::RefCountedString::TakeString(&empty)));
-}
-
-bool OSExchangeDataProviderAuraX11::DidOriginateFromRenderer() const {
-  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
-}
-
-void OSExchangeDataProviderAuraX11::SetString(const base::string16& text_data) {
-  if (HasString())
-    return;
-
-  std::string utf8 = base::UTF16ToUTF8(text_data);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&utf8));
-
-  format_map_.Insert(gfx::GetAtom(kMimeTypeText), mem);
-  format_map_.Insert(gfx::GetAtom(kText), mem);
-  format_map_.Insert(gfx::GetAtom(kString), mem);
-  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetURL(const GURL& url,
-                                           const base::string16& title) {
-  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
-  // empty title. Is this necessary?
-  if (url.is_valid()) {
-    // Mozilla's URL format: (UTF16: URL, newline, title)
-    base::string16 spec = base::UTF8ToUTF16(url.spec());
-
-    std::vector<unsigned char> data;
-    ui::AddString16ToVector(spec, &data);
-    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
-    ui::AddString16ToVector(title, &data);
-    scoped_refptr<base::RefCountedMemory> mem(
-        base::RefCountedBytes::TakeVector(&data));
-
-    format_map_.Insert(gfx::GetAtom(kMimeTypeMozillaURL), mem);
-
-    // Set a string fallback as well.
-    SetString(spec);
-
-    // Return early if this drag already contains file contents (this implies
-    // that file contents must be populated before URLs). Nautilus (and possibly
-    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
-    // protocol, but we want to prioritize XDS in this case.
-    if (!file_contents_name_.empty())
-      return;
-
-    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
-    // to create a link to the URL. Setting text/uri-list doesn't work because
-    // Nautilus will fetch and copy the contents of the URL to the drop target
-    // instead of linking...
-    // Format is UTF8: URL + "\n" + title.
-    std::string netscape_url = url.spec();
-    netscape_url += "\n";
-    netscape_url += base::UTF16ToUTF8(title);
-    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
-                       scoped_refptr<base::RefCountedMemory>(
-                           base::RefCountedString::TakeString(&netscape_url)));
-  }
-}
-
-void OSExchangeDataProviderAuraX11::SetFilename(const base::FilePath& path) {
-  std::vector<FileInfo> data;
-  data.push_back(FileInfo(path, base::FilePath()));
-  SetFilenames(data);
-}
-
-void OSExchangeDataProviderAuraX11::SetFilenames(
-    const std::vector<FileInfo>& filenames) {
-  std::vector<std::string> paths;
-  for (const auto& filename : filenames) {
-    std::string url_spec = net::FilePathToFileURL(filename.path).spec();
-    if (!url_spec.empty())
-      paths.push_back(url_spec);
-  }
-
-  std::string joined_data = base::JoinString(paths, "\n");
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedString::TakeString(&joined_data));
-  format_map_.Insert(gfx::GetAtom(kMimeTypeURIList), mem);
-}
-
-void OSExchangeDataProviderAuraX11::SetPickledData(
-    const ClipboardFormatType& format,
-    const base::Pickle& pickle) {
-  const unsigned char* data =
-      reinterpret_cast<const unsigned char*>(pickle.data());
-
-  std::vector<unsigned char> bytes;
-  bytes.insert(bytes.end(), data, data + pickle.size());
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetString(base::string16* result) const {
-  if (HasFile()) {
-    // Various Linux file managers both pass a list of file:// URIs and set the
-    // string representation to the URI. We explicitly don't want to return use
-    // this representation.
-    return false;
-  }
-
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::string text = data.GetText();
-    *result = base::UTF8ToUTF16(text);
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetURLAndTitle(
-    OSExchangeData::FilenameToURLPolicy policy,
-    GURL* url,
-    base::string16* title) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // TODO(erg): Technically, both of these forms can accept multiple URLs,
-    // but that doesn't match the assumptions of the rest of the system which
-    // expect single types.
-
-    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
-      // Mozilla URLs are (UTF16: URL, newline, title).
-      base::string16 unparsed;
-      data.AssignTo(&unparsed);
-
-      std::vector<base::string16> tokens = base::SplitString(
-          unparsed, base::ASCIIToUTF16("\n"),
-          base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
-      if (tokens.size() > 0) {
-        if (tokens.size() > 1)
-          *title = tokens[1];
-        else
-          *title = base::string16();
-
-        *url = GURL(tokens[0]);
-        return true;
-      }
-    } else if (data.GetType() == gfx::GetAtom(kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (const std::string& token : tokens) {
-        GURL test_url(token);
-        if (!test_url.SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES) {
-          *url = test_url;
-          *title = base::string16();
-          return true;
-        }
-      }
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilename(base::FilePath* path) const {
-  std::vector<FileInfo> filenames;
-  if (GetFilenames(&filenames)) {
-    *path = filenames.front().path;
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::GetFilenames(
-    std::vector<FileInfo>* filenames) const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  filenames->clear();
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (const std::string& token : tokens) {
-      GURL url(token);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
-        filenames->push_back(FileInfo(file_path, base::FilePath()));
-      }
-    }
-  }
-
-  return !filenames->empty();
-}
-
-bool OSExchangeDataProviderAuraX11::GetPickledData(
-    const ClipboardFormatType& format,
-    base::Pickle* pickle) const {
-  std::vector< ::Atom> requested_types;
-  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    // Note that the pickle object on the right hand side of the assignment
-    // only refers to the bytes in |data|. The assignment copies the data.
-    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
-                           static_cast<int>(data.GetSize()));
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasString() const {
-  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
-  return !requested_types.empty() && !HasFile();
-}
-
-bool OSExchangeDataProviderAuraX11::HasURL(
-    OSExchangeData::FilenameToURLPolicy policy) const {
-  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // The Linux desktop doesn't differentiate between files and URLs like
-  // Windows does and stuffs all the data into one mime type.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
-      // File managers shouldn't be using this type, so this is a URL.
-      return true;
-    } else if (data.GetType() == gfx::GetAtom(ui::kMimeTypeURIList)) {
-      std::vector<std::string> tokens = ui::ParseURIList(data);
-      for (const std::string& token : tokens) {
-        if (!GURL(token).SchemeIsFile() ||
-            policy == OSExchangeData::CONVERT_FILENAMES)
-          return true;
-      }
-
-      return false;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasFile() const {
-  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  if (requested_types.empty())
-    return false;
-
-  // To actually answer whether we have a file, we need to look through the
-  // contents of the kMimeTypeURIList type, and see if any of them are file://
-  // URIs.
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    std::vector<std::string> tokens = ui::ParseURIList(data);
-    for (const std::string& token : tokens) {
-      GURL url(token);
-      base::FilePath file_path;
-      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
-        return true;
-    }
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasCustomFormat(
-    const ClipboardFormatType& format) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
-}
-
 void OSExchangeDataProviderAuraX11::SetFileContents(
     const base::FilePath& filename,
     const std::string& file_contents) {
@@ -427,60 +77,6 @@ void OSExchangeDataProviderAuraX11::SetF
           base::RefCountedString::TakeString(&file_contents_copy)));
 }
 
-void OSExchangeDataProviderAuraX11::SetHtml(const base::string16& html,
-                                            const GURL& base_url) {
-  std::vector<unsigned char> bytes;
-  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
-  // assume UTF-8.
-  bytes.push_back(0xFF);
-  bytes.push_back(0xFE);
-  ui::AddString16ToVector(html, &bytes);
-  scoped_refptr<base::RefCountedMemory> mem(
-      base::RefCountedBytes::TakeVector(&bytes));
-
-  format_map_.Insert(gfx::GetAtom(kMimeTypeHTML), mem);
-}
-
-bool OSExchangeDataProviderAuraX11::GetHtml(base::string16* html,
-                                            GURL* base_url) const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
-  if (data.IsValid()) {
-    *html = data.GetHtml();
-    *base_url = GURL();
-    return true;
-  }
-
-  return false;
-}
-
-bool OSExchangeDataProviderAuraX11::HasHtml() const {
-  std::vector< ::Atom> url_atoms;
-  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
-  std::vector< ::Atom> requested_types;
-  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
-
-  return !requested_types.empty();
-}
-
-void OSExchangeDataProviderAuraX11::SetDragImage(
-    const gfx::ImageSkia& image,
-    const gfx::Vector2d& cursor_offset) {
-  drag_image_ = image;
-  drag_image_offset_ = cursor_offset;
-}
-
-gfx::ImageSkia OSExchangeDataProviderAuraX11::GetDragImage() const {
-  return drag_image_;
-}
-
-gfx::Vector2d OSExchangeDataProviderAuraX11::GetDragImageOffset() const {
-  return drag_image_offset_;
-}
 
 bool OSExchangeDataProviderAuraX11::CanDispatchEvent(
     const PlatformEvent& event) {
@@ -500,21 +96,4 @@ uint32_t OSExchangeDataProviderAuraX11::
   return ui::POST_DISPATCH_NONE;
 }
 
-bool OSExchangeDataProviderAuraX11::GetPlainTextURL(GURL* url) const {
-  base::string16 text;
-  if (GetString(&text)) {
-    GURL test_url(text);
-    if (test_url.is_valid()) {
-      *url = test_url;
-      return true;
-    }
-  }
-
-  return false;
-}
-
-std::vector< ::Atom> OSExchangeDataProviderAuraX11::GetTargets() const {
-  return format_map_.GetTypes();
-}
-
 }  // namespace ui
Index: dev/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
===================================================================
--- dev.orig/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
+++ dev/ui/base/dragdrop/os_exchange_data_provider_aurax11.h
@@ -5,29 +5,14 @@
 #ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 #define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_H_
 
-#include <stdint.h>
-#include <map>
-
-#include "base/files/file_path.h"
-#include "base/macros.h"
-#include "base/pickle.h"
-#include "ui/base/dragdrop/os_exchange_data.h"
-#include "ui/base/x/selection_owner.h"
-#include "ui/base/x/selection_requestor.h"
-#include "ui/base/x/selection_utils.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
-#include "ui/gfx/geometry/vector2d.h"
-#include "ui/gfx/image/image_skia.h"
-#include "ui/gfx/x/x11.h"
-#include "url/gurl.h"
 
 namespace ui {
 
-class OSExchangeDataProviderAuraX11Test;
-
 // OSExchangeData::Provider implementation for aura on linux.
 class UI_BASE_EXPORT OSExchangeDataProviderAuraX11
-    : public OSExchangeData::Provider,
+    : public OSExchangeDataProviderAuraX11Base,
       public PlatformEventDispatcher {
  public:
   // |x_window| is the window the cursor is over, and |selection| is the set of
@@ -41,99 +26,15 @@ class UI_BASE_EXPORT OSExchangeDataProvi
 
   ~OSExchangeDataProviderAuraX11() override;
 
-  // After all the Set* methods have built up the data we're offering, call
-  // this to take ownership of the XdndSelection clipboard.
-  void TakeOwnershipOfSelection() const;
-
-  // Retrieves a list of types we're offering. Noop if we haven't taken the
-  // selection.
-  void RetrieveTargets(std::vector<Atom>* targets) const;
-
-  // Makes a copy of the format map currently being offered.
-  SelectionFormatMap GetFormatMap() const;
-
-  const base::FilePath& file_contents_name() const {
-    return file_contents_name_;
-  }
-
-  // Overridden from OSExchangeData::Provider:
   std::unique_ptr<Provider> Clone() const override;
-  void MarkOriginatedFromRenderer() override;
-  bool DidOriginateFromRenderer() const override;
-  void SetString(const base::string16& data) override;
-  void SetURL(const GURL& url, const base::string16& title) override;
-  void SetFilename(const base::FilePath& path) override;
-  void SetFilenames(const std::vector<FileInfo>& filenames) override;
-  void SetPickledData(const ClipboardFormatType& format,
-                      const base::Pickle& pickle) override;
-  bool GetString(base::string16* data) const override;
-  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
-                      GURL* url,
-                      base::string16* title) const override;
-  bool GetFilename(base::FilePath* path) const override;
-  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
-  bool GetPickledData(const ClipboardFormatType& format,
-                      base::Pickle* pickle) const override;
-  bool HasString() const override;
-  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
-  bool HasFile() const override;
-  bool HasCustomFormat(const ClipboardFormatType& format) const override;
-
   void SetFileContents(const base::FilePath& filename,
                        const std::string& file_contents) override;
 
-  void SetHtml(const base::string16& html, const GURL& base_url) override;
-  bool GetHtml(base::string16* html, GURL* base_url) const override;
-  bool HasHtml() const override;
-  void SetDragImage(const gfx::ImageSkia& image,
-                    const gfx::Vector2d& cursor_offset) override;
-  gfx::ImageSkia GetDragImage() const override;
-  gfx::Vector2d GetDragImageOffset() const override;
-
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
 
  private:
-  friend class OSExchangeDataProviderAuraX11Test;
-  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
-
-  // Returns true if |formats_| contains a string format and the string can be
-  // parsed as a URL.
-  bool GetPlainTextURL(GURL* url) const;
-
-  // Returns the targets in |format_map_|.
-  std::vector< ::Atom> GetTargets() const;
-
-  // Drag image and offset data.
-  gfx::ImageSkia drag_image_;
-  gfx::Vector2d drag_image_offset_;
-
-  // Our X11 state.
-  Display* x_display_;
-  ::Window x_root_window_;
-
-  // In X11, because the IPC parts of drag operations are implemented by
-  // XSelection, we require an x11 window to receive drag messages on. The
-  // OSExchangeDataProvider system is modeled on the Windows implementation,
-  // which does not require a window. We only sometimes have a valid window
-  // available (in the case of drag receiving). Other times, we need to create
-  // our own xwindow just to receive events on it.
-  const bool own_window_;
-
-  ::Window x_window_;
-
-  // A representation of data. This is either passed to us from the other
-  // process, or built up through a sequence of Set*() calls. It can be passed
-  // to |selection_owner_| when we take the selection.
-  SelectionFormatMap format_map_;
-
-  // Auxilary data for the X Direct Save protocol.
-  base::FilePath file_contents_name_;
-
-  // Takes a snapshot of |format_map_| and offers it to other windows.
-  mutable SelectionOwner selection_owner_;
-
   DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11);
 };
 
Index: dev/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
===================================================================
--- /dev/null
+++ dev/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.cc
@@ -0,0 +1,461 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+
+#include <utility>
+
+#include "base/logging.h"
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/string_util.h"
+#include "base/strings/utf_string_conversions.h"
+#include "net/base/filename_util.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/clipboard/clipboard_format_type.h"
+#include "ui/base/clipboard/scoped_clipboard_writer.h"
+#include "ui/base/dragdrop/file_info.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+
+// Note: the GetBlah() methods are used immediately by the
+// web_contents_view_aura.cc:PrepareDropData(), while the omnibox is a
+// little more discriminating and calls HasBlah() before trying to get the
+// information.
+
+namespace ui {
+
+namespace {
+
+const char kDndSelection[] = "XdndSelection";
+const char kRendererTaint[] = "chromium/x-renderer-taint";
+
+const char kNetscapeURL[] = "_NETSCAPE_URL";
+
+}  // namespace
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base(
+    ::Window x_window,
+    const SelectionFormatMap& selection)
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(false),
+      x_window_(x_window),
+      format_map_(selection),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {}
+
+OSExchangeDataProviderAuraX11Base::OSExchangeDataProviderAuraX11Base()
+    : x_display_(gfx::GetXDisplay()),
+      x_root_window_(DefaultRootWindow(x_display_)),
+      own_window_(true),
+      x_window_(XCreateWindow(x_display_,
+                              x_root_window_,
+                              -100,
+                              -100,
+                              10,
+                              10,              // x, y, width, height
+                              0,               // border width
+                              CopyFromParent,  // depth
+                              InputOnly,
+                              CopyFromParent,  // visual
+                              0,
+                              NULL)),
+      format_map_(),
+      selection_owner_(x_display_, x_window_, gfx::GetAtom(kDndSelection)) {
+  XStoreName(x_display_, x_window_, "Chromium Drag & Drop Window");
+}
+
+OSExchangeDataProviderAuraX11Base::~OSExchangeDataProviderAuraX11Base() {
+  if (own_window_)
+    XDestroyWindow(x_display_, x_window_);
+}
+
+void OSExchangeDataProviderAuraX11Base::TakeOwnershipOfSelection() const {
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+}
+
+void OSExchangeDataProviderAuraX11Base::RetrieveTargets(
+    std::vector<Atom>* targets) const {
+  selection_owner_.RetrieveTargets(targets);
+}
+
+SelectionFormatMap OSExchangeDataProviderAuraX11Base::GetFormatMap() const {
+  // We return the |selection_owner_|'s format map instead of our own in case
+  // ours has been modified since TakeOwnershipOfSelection() was called.
+  return selection_owner_.selection_format_map();
+}
+
+void OSExchangeDataProviderAuraX11Base::MarkOriginatedFromRenderer() {
+  std::string empty;
+  format_map_.Insert(gfx::GetAtom(kRendererTaint),
+                     scoped_refptr<base::RefCountedMemory>(
+                         base::RefCountedString::TakeString(&empty)));
+}
+
+bool OSExchangeDataProviderAuraX11Base::DidOriginateFromRenderer() const {
+  return format_map_.find(gfx::GetAtom(kRendererTaint)) != format_map_.end();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetString(
+    const base::string16& text_data) {
+  if (HasString())
+    return;
+
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  format_map_.Insert(gfx::GetAtom(kMimeTypeText), mem);
+  format_map_.Insert(gfx::GetAtom(kText), mem);
+  format_map_.Insert(gfx::GetAtom(kString), mem);
+  format_map_.Insert(gfx::GetAtom(kUtf8String), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetURL(const GURL& url,
+                                               const base::string16& title) {
+  // TODO(dcheng): The original GTK code tries very hard to avoid writing out an
+  // empty title. Is this necessary?
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    format_map_.Insert(gfx::GetAtom(kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    SetString(spec);
+
+    // Return early if this drag already contains file contents (this implies
+    // that file contents must be populated before URLs). Nautilus (and possibly
+    // other file managers) prefer _NETSCAPE_URL over the X Direct Save
+    // protocol, but we want to prioritize XDS in this case.
+    if (!file_contents_name_.empty())
+      return;
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    format_map_.Insert(gfx::GetAtom(kNetscapeURL),
+                       scoped_refptr<base::RefCountedMemory>(
+                           base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilename(
+    const base::FilePath& path) {
+  std::vector<FileInfo> data;
+  data.push_back(FileInfo(path, base::FilePath()));
+  SetFilenames(data);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetFilenames(
+    const std::vector<FileInfo>& filenames) {
+  std::vector<std::string> paths;
+  for (const auto& filename : filenames) {
+    std::string url_spec = net::FilePathToFileURL(filename.path).spec();
+    if (!url_spec.empty())
+      paths.push_back(url_spec);
+  }
+
+  std::string joined_data = base::JoinString(paths, "\n");
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&joined_data));
+  format_map_.Insert(gfx::GetAtom(kMimeTypeURIList), mem);
+}
+
+void OSExchangeDataProviderAuraX11Base::SetPickledData(
+    const ClipboardFormatType& format,
+    const base::Pickle& pickle) {
+  const unsigned char* data =
+      reinterpret_cast<const unsigned char*>(pickle.data());
+
+  std::vector<unsigned char> bytes;
+  bytes.insert(bytes.end(), data, data + pickle.size());
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(format.ToString().c_str()), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetString(
+    base::string16* result) const {
+  if (HasFile()) {
+    // Various Linux file managers both pass a list of file:// URIs and set the
+    // string representation to the URI. We explicitly don't want to return use
+    // this representation.
+    return false;
+  }
+
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::string text = data.GetText();
+    *result = base::UTF8ToUTF16(text);
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetURLAndTitle(
+    OSExchangeData::FilenameToURLPolicy policy,
+    GURL* url,
+    base::string16* title) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // TODO(erg): Technically, both of these forms can accept multiple URLs,
+    // but that doesn't match the assumptions of the rest of the system which
+    // expect single types.
+
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
+      // Mozilla URLs are (UTF16: URL, newline, title).
+      base::string16 unparsed;
+      data.AssignTo(&unparsed);
+
+      std::vector<base::string16> tokens =
+          base::SplitString(unparsed, base::ASCIIToUTF16("\n"),
+                            base::KEEP_WHITESPACE, base::SPLIT_WANT_NONEMPTY);
+      if (tokens.size() > 0) {
+        if (tokens.size() > 1)
+          *title = tokens[1];
+        else
+          *title = base::string16();
+
+        *url = GURL(tokens[0]);
+        return true;
+      }
+    } else if (data.GetType() == gfx::GetAtom(kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (const std::string& token : tokens) {
+        GURL test_url(token);
+        if (!test_url.SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES) {
+          *url = test_url;
+          *title = base::string16();
+          return true;
+        }
+      }
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilename(
+    base::FilePath* path) const {
+  std::vector<FileInfo> filenames;
+  if (GetFilenames(&filenames)) {
+    *path = filenames.front().path;
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetFilenames(
+    std::vector<FileInfo>* filenames) const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  filenames->clear();
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (const std::string& token : tokens) {
+      GURL url(token);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path)) {
+        filenames->push_back(FileInfo(file_path, base::FilePath()));
+      }
+    }
+  }
+
+  return !filenames->empty();
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPickledData(
+    const ClipboardFormatType& format,
+    base::Pickle* pickle) const {
+  std::vector<::Atom> requested_types;
+  requested_types.push_back(gfx::GetAtom(format.ToString().c_str()));
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    // Note that the pickle object on the right hand side of the assignment
+    // only refers to the bytes in |data|. The assignment copies the data.
+    *pickle = base::Pickle(reinterpret_cast<const char*>(data.GetData()),
+                           static_cast<int>(data.GetSize()));
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasString() const {
+  std::vector<::Atom> text_atoms = ui::GetTextAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(text_atoms, GetTargets(), &requested_types);
+  return !requested_types.empty() && !HasFile();
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasURL(
+    OSExchangeData::FilenameToURLPolicy policy) const {
+  std::vector<::Atom> url_atoms = ui::GetURLAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // The Linux desktop doesn't differentiate between files and URLs like
+  // Windows does and stuffs all the data into one mime type.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    if (data.GetType() == gfx::GetAtom(kMimeTypeMozillaURL)) {
+      // File managers shouldn't be using this type, so this is a URL.
+      return true;
+    } else if (data.GetType() ==
+               gfx::GetAtom(kMimeTypeURIList)) {
+      std::vector<std::string> tokens = ui::ParseURIList(data);
+      for (const std::string& token : tokens) {
+        if (!GURL(token).SchemeIsFile() ||
+            policy == OSExchangeData::CONVERT_FILENAMES)
+          return true;
+      }
+
+      return false;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasFile() const {
+  std::vector<::Atom> url_atoms = ui::GetURIListAtomsFrom();
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  if (requested_types.empty())
+    return false;
+
+  // To actually answer whether we have a file, we need to look through the
+  // contents of the kMimeTypeURIList type, and see if any of them are file://
+  // URIs.
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    std::vector<std::string> tokens = ui::ParseURIList(data);
+    for (const std::string& token : tokens) {
+      GURL url(token);
+      base::FilePath file_path;
+      if (url.SchemeIsFile() && net::FileURLToFilePath(url, &file_path))
+        return true;
+    }
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasCustomFormat(
+    const ClipboardFormatType& format) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(format.ToString().c_str()));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetHtml(const base::string16& html,
+                                                const GURL& base_url) {
+  std::vector<unsigned char> bytes;
+  // Manually jam a UTF16 BOM into bytes because otherwise, other programs will
+  // assume UTF-8.
+  bytes.push_back(0xFF);
+  bytes.push_back(0xFE);
+  ui::AddString16ToVector(html, &bytes);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedBytes::TakeVector(&bytes));
+
+  format_map_.Insert(gfx::GetAtom(kMimeTypeHTML), mem);
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetHtml(base::string16* html,
+                                                GURL* base_url) const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  ui::SelectionData data(format_map_.GetFirstOf(requested_types));
+  if (data.IsValid()) {
+    *html = data.GetHtml();
+    *base_url = GURL();
+    return true;
+  }
+
+  return false;
+}
+
+bool OSExchangeDataProviderAuraX11Base::HasHtml() const {
+  std::vector<::Atom> url_atoms;
+  url_atoms.push_back(gfx::GetAtom(kMimeTypeHTML));
+  std::vector<::Atom> requested_types;
+  GetAtomIntersection(url_atoms, GetTargets(), &requested_types);
+
+  return !requested_types.empty();
+}
+
+void OSExchangeDataProviderAuraX11Base::SetDragImage(
+    const gfx::ImageSkia& image,
+    const gfx::Vector2d& cursor_offset) {
+  drag_image_ = image;
+  drag_image_offset_ = cursor_offset;
+}
+
+gfx::ImageSkia OSExchangeDataProviderAuraX11Base::GetDragImage() const {
+  return drag_image_;
+}
+
+gfx::Vector2d OSExchangeDataProviderAuraX11Base::GetDragImageOffset() const {
+  return drag_image_offset_;
+}
+
+bool OSExchangeDataProviderAuraX11Base::GetPlainTextURL(GURL* url) const {
+  base::string16 text;
+  if (GetString(&text)) {
+    GURL test_url(text);
+    if (test_url.is_valid()) {
+      *url = test_url;
+      return true;
+    }
+  }
+
+  return false;
+}
+
+std::vector<::Atom> OSExchangeDataProviderAuraX11Base::GetTargets() const {
+  return format_map_.GetTypes();
+}
+
+}  // namespace ui
Index: dev/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
===================================================================
--- /dev/null
+++ dev/ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h
@@ -0,0 +1,135 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+#define UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
+
+#include <stdint.h>
+#include <map>
+
+#include "base/files/file_path.h"
+#include "base/macros.h"
+#include "base/pickle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/selection_requestor.h"
+#include "ui/base/x/selection_utils.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/vector2d.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/x/x11.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+struct ClipboardFormatType;
+
+class OSExchangeDataProviderAuraX11Test;
+
+// OSExchangeData::Provider implementation for aura on linux.
+class UI_BASE_EXPORT OSExchangeDataProviderAuraX11Base
+    : public OSExchangeData::Provider {
+ public:
+  // |x_window| is the window the cursor is over, and |selection| is the set of
+  // data being offered.
+  OSExchangeDataProviderAuraX11Base(::Window x_window,
+                                    const SelectionFormatMap& selection);
+
+  // Creates a Provider for sending drag information. This creates its own,
+  // hidden X11 window to own send data.
+  OSExchangeDataProviderAuraX11Base();
+
+  ~OSExchangeDataProviderAuraX11Base() override;
+
+  // After all the Set* methods have built up the data we're offering, call
+  // this to take ownership of the XdndSelection clipboard.
+  void TakeOwnershipOfSelection() const;
+
+  // Retrieves a list of types we're offering. Noop if we haven't taken the
+  // selection.
+  void RetrieveTargets(std::vector<Atom>* targets) const;
+
+  // Makes a copy of the format map currently being offered.
+  SelectionFormatMap GetFormatMap() const;
+
+  const base::FilePath& file_contents_name() const {
+    return file_contents_name_;
+  }
+
+  // Overridden from OSExchangeData::Provider:
+  void MarkOriginatedFromRenderer() override;
+  bool DidOriginateFromRenderer() const override;
+  void SetString(const base::string16& data) override;
+  void SetURL(const GURL& url, const base::string16& title) override;
+  void SetFilename(const base::FilePath& path) override;
+  void SetFilenames(const std::vector<FileInfo>& filenames) override;
+  void SetPickledData(const ClipboardFormatType& format,
+                      const base::Pickle& pickle) override;
+  bool GetString(base::string16* data) const override;
+  bool GetURLAndTitle(OSExchangeData::FilenameToURLPolicy policy,
+                      GURL* url,
+                      base::string16* title) const override;
+  bool GetFilename(base::FilePath* path) const override;
+  bool GetFilenames(std::vector<FileInfo>* filenames) const override;
+  bool GetPickledData(const ClipboardFormatType& format,
+                      base::Pickle* pickle) const override;
+  bool HasString() const override;
+  bool HasURL(OSExchangeData::FilenameToURLPolicy policy) const override;
+  bool HasFile() const override;
+  bool HasCustomFormat(const ClipboardFormatType& format) const override;
+
+  void SetHtml(const base::string16& html, const GURL& base_url) override;
+  bool GetHtml(base::string16* html, GURL* base_url) const override;
+  bool HasHtml() const override;
+  void SetDragImage(const gfx::ImageSkia& image,
+                    const gfx::Vector2d& cursor_offset) override;
+  gfx::ImageSkia GetDragImage() const override;
+  gfx::Vector2d GetDragImageOffset() const override;
+
+ protected:
+  friend class OSExchangeDataProviderAuraX11Test;
+  typedef std::map<ClipboardFormatType, base::Pickle> PickleData;
+
+  // Returns true if |formats_| contains a string format and the string can be
+  // parsed as a URL.
+  bool GetPlainTextURL(GURL* url) const;
+
+  // Returns the targets in |format_map_|.
+  std::vector<::Atom> GetTargets() const;
+
+  // Drag image and offset data.
+  gfx::ImageSkia drag_image_;
+  gfx::Vector2d drag_image_offset_;
+
+  // Our X11 state.
+  Display* x_display_;
+  ::Window x_root_window_;
+
+  // In X11, because the IPC parts of drag operations are implemented by
+  // XSelection, we require an x11 window to receive drag messages on. The
+  // OSExchangeDataProvider system is modeled on the Windows implementation,
+  // which does not require a window. We only sometimes have a valid window
+  // available (in the case of drag receiving). Other times, we need to create
+  // our own xwindow just to receive events on it.
+  const bool own_window_;
+
+  ::Window x_window_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Auxilary data for the X Direct Save protocol.
+  base::FilePath file_contents_name_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  DISALLOW_COPY_AND_ASSIGN(OSExchangeDataProviderAuraX11Base);
+};
+
+}  // namespace ui
+
+#endif  // UI_BASE_DRAGDROP_OS_EXCHANGE_DATA_PROVIDER_AURAX11_BASE_H_
Index: dev/ui/base/ime/input_method_initializer.cc
===================================================================
--- dev.orig/ui/base/ime/input_method_initializer.cc
+++ dev/ui/base/ime/input_method_initializer.cc
@@ -50,11 +50,13 @@ void InitializeInputMethodForTesting() {
   if (!g_linux_input_method_context_factory_for_testing)
     g_linux_input_method_context_factory_for_testing =
         new FakeInputMethodContextFactory();
+#if !defined(USE_OZONE)
   const LinuxInputMethodContextFactory* factory =
       LinuxInputMethodContextFactory::instance();
   CHECK(!factory || factory == g_linux_input_method_context_factory_for_testing)
       << "LinuxInputMethodContextFactory was already initialized somewhere "
       << "else.";
+#endif
   LinuxInputMethodContextFactory::SetInstance(
       g_linux_input_method_context_factory_for_testing);
 #elif defined(OS_WIN)
Index: dev/ui/ozone/platform/drm/host/drm_window_host.cc
===================================================================
--- dev.orig/ui/ozone/platform/drm/host/drm_window_host.cc
+++ dev/ui/ozone/platform/drm/host/drm_window_host.cc
@@ -147,6 +147,12 @@ gfx::Rect DrmWindowHost::GetRestoredBoun
   return gfx::Rect();
 }
 
+bool DrmWindowHost::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void DrmWindowHost::StopMoveLoop() {}
+
 bool DrmWindowHost::CanDispatchEvent(const PlatformEvent& event) {
   DCHECK(event);
 
Index: dev/ui/ozone/platform/drm/host/drm_window_host.h
===================================================================
--- dev.orig/ui/ozone/platform/drm/host/drm_window_host.h
+++ dev/ui/ozone/platform/drm/host/drm_window_host.h
@@ -79,6 +79,8 @@ class DrmWindowHost : public PlatformWin
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
Index: dev/ui/ozone/platform/headless/BUILD.gn
===================================================================
--- dev.orig/ui/ozone/platform/headless/BUILD.gn
+++ dev/ui/ozone/platform/headless/BUILD.gn
@@ -26,6 +26,7 @@ source_set("headless") {
     "//base",
     "//skia",
     "//ui/base",
+    "//ui/base/ime",
     "//ui/display/manager",
     "//ui/events",
     "//ui/events/ozone:events_ozone_layout",
Index: dev/ui/ozone/platform/headless/ozone_platform_headless.cc
===================================================================
--- dev.orig/ui/ozone/platform/headless/ozone_platform_headless.cc
+++ dev/ui/ozone/platform/headless/ozone_platform_headless.cc
@@ -8,6 +8,7 @@
 #include "base/files/file_path.h"
 #include "base/macros.h"
 #include "ui/base/cursor/ozone/bitmap_cursor_factory_ozone.h"
+#include "ui/base/ime/linux/fake_input_method_context_factory.h"
 #include "ui/events/ozone/layout/keyboard_layout_engine_manager.h"
 #include "ui/events/ozone/layout/stub/stub_keyboard_layout_engine.h"
 #include "ui/events/platform/platform_event_source.h"
@@ -90,6 +91,13 @@ class OzonePlatformHeadless : public Ozo
     input_controller_ = CreateStubInputController();
     cursor_factory_ozone_ = std::make_unique<BitmapCursorFactoryOzone>();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
+
+    if (LinuxInputMethodContextFactory::instance())
+      return;
+    fake_input_method_factory_ =
+        std::make_unique<FakeInputMethodContextFactory>();
+    LinuxInputMethodContextFactory::SetInstance(
+        fake_input_method_factory_.get());
   }
 
   void InitializeGPU(const InitParams& params) override {
@@ -105,6 +113,7 @@ class OzonePlatformHeadless : public Ozo
   std::unique_ptr<InputController> input_controller_;
   std::unique_ptr<GpuPlatformSupportHost> gpu_platform_support_host_;
   std::unique_ptr<OverlayManagerOzone> overlay_manager_;
+  std::unique_ptr<FakeInputMethodContextFactory> fake_input_method_factory_;
   base::FilePath file_path_;
 
   DISALLOW_COPY_AND_ASSIGN(OzonePlatformHeadless);
Index: dev/ui/ozone/platform/wayland/wayland_window.cc
===================================================================
--- dev.orig/ui/ozone/platform/wayland/wayland_window.cc
+++ dev/ui/ozone/platform/wayland/wayland_window.cc
@@ -455,6 +455,12 @@ gfx::Rect WaylandWindow::GetRestoredBoun
   return restored_bounds_;
 }
 
+bool WaylandWindow::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return true;
+}
+
+void WaylandWindow::StopMoveLoop() {}
+
 bool WaylandWindow::CanDispatchEvent(const PlatformEvent& event) {
   // This window is a nested popup window, all the events must be forwarded
   // to the main popup window.
Index: dev/ui/ozone/platform/wayland/wayland_window.h
===================================================================
--- dev.orig/ui/ozone/platform/wayland/wayland_window.h
+++ dev/ui/ozone/platform/wayland/wayland_window.h
@@ -124,6 +124,8 @@ class WaylandWindow : public PlatformWin
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // PlatformEventDispatcher
   bool CanDispatchEvent(const PlatformEvent& event) override;
Index: dev/ui/ozone/platform/x11/BUILD.gn
===================================================================
--- dev.orig/ui/ozone/platform/x11/BUILD.gn
+++ dev/ui/ozone/platform/x11/BUILD.gn
@@ -28,6 +28,12 @@ source_set("x11") {
     "x11_display_fetcher_ozone.h",
     "x11_screen_ozone.cc",
     "x11_screen_ozone.h",
+    "x11_drag_context.cc",
+    "x11_drag_context.h",
+    "x11_drag_source.cc",
+    "x11_drag_source.h",
+    "x11_drag_util.cc",
+    "x11_drag_util.h",
     "x11_surface_factory.cc",
     "x11_surface_factory.h",
     "x11_window_manager_ozone.cc",
@@ -41,6 +47,8 @@ source_set("x11") {
     "//gpu/vulkan:buildflags",
     "//skia",
     "//ui/base",
+    "//ui/base/clipboard:clipboard_types",
+    "//ui/base/ime",
     "//ui/base/x",
     "//ui/display/manager",
     "//ui/events",
@@ -57,6 +65,7 @@ source_set("x11") {
     "//ui/ozone/common",
     "//ui/platform_window",
     "//ui/platform_window/x11",
+    "//ui/platform_window/platform_window_handler",
   ]
 
   if (enable_vulkan) {
Index: dev/ui/ozone/platform/x11/DEPS
===================================================================
--- dev.orig/ui/ozone/platform/x11/DEPS
+++ dev/ui/ozone/platform/x11/DEPS
@@ -1,3 +1,4 @@
 include_rules = [
   "+ui/base/x",
+  "+ui/base/ime",
 ]
Index: dev/ui/ozone/platform/x11/ozone_platform_x11.cc
===================================================================
--- dev.orig/ui/ozone/platform/x11/ozone_platform_x11.cc
+++ dev/ui/ozone/platform/x11/ozone_platform_x11.cc
@@ -9,6 +9,7 @@
 
 #include "base/message_loop/message_loop.h"
 #include "base/strings/utf_string_conversions.h"
+#include "ui/base/ime/linux/fake_input_method_context_factory.h"
 #include "ui/base/x/x11_util.h"
 #include "ui/display/manager/fake_display_delegate.h"
 #include "ui/events/devices/x11/touch_factory_x11.h"
@@ -89,8 +90,13 @@ class OzonePlatformX11 : public OzonePla
     input_controller_ = CreateStubInputController();
     cursor_factory_ozone_ = std::make_unique<X11CursorFactoryOzone>();
     gpu_platform_support_host_.reset(CreateStubGpuPlatformSupportHost());
-
     TouchFactory::SetTouchDeviceListFromCommandLine();
+
+    if (LinuxInputMethodContextFactory::instance())
+      return;
+    fake_input_method_factory_ =
+        std::make_unique<FakeInputMethodContextFactory>();
+    LinuxInputMethodContextFactory::SetInstance(fake_input_method_factory_.get());
   }
 
   void InitializeGPU(const InitParams& params) override {
@@ -147,6 +153,7 @@ class OzonePlatformX11 : public OzonePla
   std::unique_ptr<InputController> input_controller_;
   std::unique_ptr<X11CursorFactoryOzone> cursor_factory_ozone_;
   std::unique_ptr<GpuPlatformSupportHost> gpu_platform_support_host_;
+  std::unique_ptr<FakeInputMethodContextFactory> fake_input_method_factory_;
 
   // Objects in the GPU process.
   std::unique_ptr<X11SurfaceFactory> surface_factory_ozone_;
Index: dev/ui/ozone/platform/x11/x11_drag_context.cc
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_context.cc
@@ -0,0 +1,266 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/dragdrop/os_exchange_data_provider_aurax11_base.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/platform/x11/x11_event_source.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+constexpr int kWillAcceptDrop = 1;
+constexpr int kWantFurtherPosEvents = 2;
+
+// Window property that will receive the drag and drop selection data.
+const char kChromiumDragReciever[] = "_CHROMIUM_DRAG_RECEIVER";
+
+}  // namespace
+
+class X11OSExchangeDataProvider : public OSExchangeDataProviderAuraX11Base {
+ public:
+  X11OSExchangeDataProvider(::Window x_window,
+                            const SelectionFormatMap& selection)
+      : OSExchangeDataProviderAuraX11Base(x_window, selection) {}
+
+  X11OSExchangeDataProvider() {}
+
+  std::unique_ptr<Provider> Clone() const override {
+    std::unique_ptr<X11OSExchangeDataProvider> ret(
+        new X11OSExchangeDataProvider());
+    ret->format_map_ = format_map_;
+    return std::move(ret);
+  }
+};
+
+X11DragContext::X11DragContext(X11WindowOzone* window,
+                               XID local_window,
+                               const XClientMessageEvent& event,
+                               const SelectionFormatMap* map)
+    : window_(window),
+      local_window_(local_window),
+      source_window_(event.data.l[0]),
+      waiting_to_handle_position_(false),
+      suggested_action_(x11::None) {
+  if (!map) {
+    bool get_types_from_property = ((event.data.l[1] & 1) != 0);
+
+    if (get_types_from_property) {
+      if (!ui::GetAtomArrayProperty(source_window_, kXdndTypeList,
+                                    &unfetched_targets_)) {
+        return;
+      }
+    } else {
+      // data.l[2,3,4] contain the first three types. Unused slots can be None.
+      for (int i = 0; i < 3; ++i) {
+        if (event.data.l[2 + i] != x11::None) {
+          unfetched_targets_.push_back(event.data.l[2 + i]);
+        }
+      }
+    }
+
+#if DCHECK_IS_ON()
+    DVLOG(1) << "XdndEnter has " << unfetched_targets_.size() << " data types";
+    for (::Atom target : unfetched_targets_) {
+      DVLOG(1) << "XdndEnter data type: " << target;
+    }
+#endif  // DCHECK_IS_ON()
+
+    // The window doesn't have a DesktopDragDropClientAura, that means it's
+    // created by some other process. Listen for messages on it.
+    source_window_events_.reset(
+        new ui::XScopedEventSelector(source_window_, PropertyChangeMask));
+
+    // We must perform a full sync here because we could be racing
+    // |source_window_|.
+    XSync(gfx::GetXDisplay(), x11::False);
+  } else {
+    // This drag originates from an aura window within our process. This means
+    // that we can shortcut the X11 server and ask the owning SelectionOwner
+    // for the data it's offering.
+    fetched_targets_ = *map;
+  }
+
+  ReadActions();
+}
+
+X11DragContext::~X11DragContext() = default;
+
+void X11DragContext::OnXdndPosition(const XClientMessageEvent& event) {
+  unsigned long source_window = event.data.l[0];
+  int x_root_window = event.data.l[2] >> 16;
+  int y_root_window = event.data.l[2] & 0xffff;
+  ::Time time_stamp = event.data.l[3];
+  ::Atom suggested_action = event.data.l[4];
+
+  OnXdndPositionMessage(suggested_action, source_window, time_stamp,
+                        gfx::PointF(x_root_window, y_root_window));
+}
+
+void X11DragContext::OnXdndPositionMessage(::Atom suggested_action,
+                                           XID source_window,
+                                           ::Time time_stamp,
+                                           const gfx::PointF& screen_point) {
+  DCHECK_EQ(source_window_, source_window);
+  suggested_action_ = suggested_action;
+
+  if (!unfetched_targets_.empty()) {
+    // We have unfetched targets. That means we need to pause the handling of
+    // the position message and ask the other window for its data.
+    screen_point_ = screen_point;
+    position_time_stamp_ = time_stamp;
+    waiting_to_handle_position_ = true;
+
+    fetched_targets_ = ui::SelectionFormatMap();
+    RequestNextTarget();
+  } else {
+    CompleteXdndPosition(source_window, screen_point);
+  }
+}
+
+void X11DragContext::RequestNextTarget() {
+  DCHECK(!unfetched_targets_.empty());
+  DCHECK(waiting_to_handle_position_);
+
+  ::Atom target = unfetched_targets_.back();
+  unfetched_targets_.pop_back();
+
+  XConvertSelection(gfx::GetXDisplay(), gfx::GetAtom(kXdndSelection), target,
+                    gfx::GetAtom(kChromiumDragReciever), local_window_,
+                    position_time_stamp_);
+}
+
+void X11DragContext::OnSelectionNotify(const XSelectionEvent& event) {
+  if (!waiting_to_handle_position_) {
+    // A misbehaved window may send SelectionNotify without us requesting data
+    // via XConvertSelection().
+    return;
+  }
+
+  DVLOG(1) << "SelectionNotify, format " << event.target;
+
+  if (event.property != x11::None) {
+    DCHECK_EQ(event.property, gfx::GetAtom(kChromiumDragReciever));
+
+    scoped_refptr<base::RefCountedMemory> data;
+    ::Atom type = x11::None;
+    if (ui::GetRawBytesOfProperty(local_window_, event.property, &data, NULL,
+                                  &type)) {
+      fetched_targets_.Insert(event.target, data);
+    }
+  } else {
+    // The source failed to convert the drop data to the format (target in X11
+    // parlance) that we asked for. This happens, even though we only ask for
+    // the formats advertised by the source. http://crbug.com/628099
+    DVLOG(1) << "XConvertSelection failed for source-advertised target "
+             << event.target;
+  }
+
+  if (!unfetched_targets_.empty()) {
+    RequestNextTarget();
+  } else {
+    waiting_to_handle_position_ = false;
+    CompleteXdndPosition(source_window_, screen_point_);
+  }
+}
+
+void X11DragContext::ReadActions() {
+  std::vector<::Atom> atom_array;
+  if (!ui::GetAtomArrayProperty(source_window_, kXdndActionList, &atom_array)) {
+    actions_.clear();
+  } else {
+    actions_.swap(atom_array);
+  }
+}
+
+int X11DragContext::GetDragOperation() const {
+  int drag_operation = ui::DragDropTypes::DRAG_NONE;
+  for (std::vector<::Atom>::const_iterator it = actions_.begin();
+       it != actions_.end(); ++it) {
+    MaskOperation(*it, &drag_operation);
+  }
+
+  MaskOperation(suggested_action_, &drag_operation);
+
+  return drag_operation;
+}
+
+void X11DragContext::MaskOperation(::Atom xdnd_operation,
+                                   int* drag_operation) const {
+  if (xdnd_operation == gfx::GetAtom(kXdndActionCopy))
+    *drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionMove))
+    *drag_operation |= ui::DragDropTypes::DRAG_MOVE;
+  else if (xdnd_operation == gfx::GetAtom(kXdndActionLink))
+    *drag_operation |= ui::DragDropTypes::DRAG_LINK;
+}
+
+void X11DragContext::CompleteXdndPosition(XID source_window,
+                                          const gfx::PointF& screen_point) {
+  // int drag_operation = ui::DragDropTypes::DRAG_COPY;
+  std::unique_ptr<OSExchangeData> data = std::make_unique<OSExchangeData>(
+      std::make_unique<X11OSExchangeDataProvider>(local_window_,
+                                                  fetched_targets()));
+  int drag_operation = GetDragOperation();
+  // KDE-based file browsers such as Dolphin change the drag operation depending
+  // on whether alt/ctrl/shift was pressed. However once Chromium gets control
+  // over the X11 events, the source application does no longer receive X11
+  // events for key modifier changes, so the dnd operation gets stuck in an
+  // incorrect state. Blink can only dnd-open files of type DRAG_COPY, so the
+  // DRAG_COPY mask is added if the dnd object is a file.
+  if (drag_operation &
+          (ui::DragDropTypes::DRAG_MOVE | ui::DragDropTypes::DRAG_LINK) &&
+      data->HasFile()) {
+    drag_operation |= ui::DragDropTypes::DRAG_COPY;
+  }
+
+  if (!sent_entered_) {
+    window_->OnDragDataCollected(screen_point, std::move(data), drag_operation);
+    sent_entered_ = true;
+  }
+  window_->OnDragMotion(screen_point, 0, position_time_stamp_, drag_operation);
+
+  // Sends an XdndStatus message back to the source_window. l[2,3]
+  // theoretically represent an area in the window where the current action is
+  // the same as what we're returning, but I can't find any implementation that
+  // actually making use of this. A client can return (0, 0) and/or set the
+  // first bit of l[1] to disable the feature, and it appears that gtk neither
+  // sets this nor respects it if set.
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndStatus);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window;
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] =
+      (drag_operation != 0) ? (kWantFurtherPosEvents | kWillAcceptDrop) : 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window, &xev);
+}
+
+void X11DragContext::OnXdndDrop(int drag_operation) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndFinished);
+  xev.xclient.format = 32;
+  xev.xclient.window = source_window();
+  xev.xclient.data.l[0] = local_window_;
+  xev.xclient.data.l[1] = (drag_operation != 0) ? 1 : 0;
+  xev.xclient.data.l[2] = DragOperationToAtom(drag_operation);
+
+  ui::SendXClientEvent(source_window(), &xev);
+}
+
+}  // namespace ui
Index: dev/ui/ozone/platform/x11/x11_drag_context.h
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_context.h
@@ -0,0 +1,115 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
+
+#include "ui/base/x/selection_utils.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "ui/gfx/geometry/point_f.h"
+
+namespace ui {
+
+class XScopedEventSelector;
+class X11WindowOzone;
+
+class X11DragContext {
+ public:
+  X11DragContext(X11WindowOzone* window,
+                 XID local_window,
+                 const XClientMessageEvent& event,
+                 const SelectionFormatMap* map);
+  ~X11DragContext();
+
+  void OnXdndPosition(const XClientMessageEvent& event);
+  // When we receive an XdndPosition message, we need to have all the data
+  // copied from the other window before we process the XdndPosition
+  // message. If we have that data already, dispatch immediately. Otherwise,
+  // delay dispatching until we do.
+  void OnXdndPositionMessage(::Atom suggested_action,
+                             XID source_window,
+                             ::Time time_stamp,
+                             const gfx::PointF& screen_point);
+
+  // Called when XSelection data has been copied to our process.
+  void OnSelectionNotify(const XSelectionEvent& xselection);
+
+  void OnXdndDrop(int drag_operation);
+
+  // Clones the fetched targets.
+  const ui::SelectionFormatMap& fetched_targets() { return fetched_targets_; }
+
+  // Reads the kXdndActionList property from |source_window| and copies it
+  // into |actions|.
+  void ReadActions();
+
+  // Creates a ui::DragDropTypes::DragOperation representation of the current
+  // action list.
+  int GetDragOperation() const;
+
+  // views::DesktopDragDropClientOzone* source_client() { return source_client_; }
+
+  XID source_window() { return source_window_; }
+
+ private:
+  // Called to request the next target from the source window. This is only
+  // done on the first XdndPosition; after that, we cache the data offered by
+  // the source window.
+  void RequestNextTarget();
+
+  // Masks the X11 atom |xdnd_operation|'s views representation onto
+  // |drag_operation|.
+  void MaskOperation(::Atom xdnd_operation, int* drag_operation) const;
+
+  void CompleteXdndPosition(::Window source_window,
+                            const gfx::PointF& screen_point);
+
+  void SendXClientEvent(XID xid, XEvent* xev);
+
+  X11WindowOzone* window_;
+
+  // The XID of our chrome local aura window handling our events.
+  XID local_window_;
+
+  // The XID of the window that's initiated the drag.
+  XID source_window_;
+
+  // Events that we have selected on |source_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> source_window_events_;
+
+  // Whether we're blocking the handling of an XdndPosition message by waiting
+  // for |unfetched_targets_| to be fetched.
+  bool waiting_to_handle_position_;
+
+  // Where the cursor is on screen.
+  gfx::PointF screen_point_;
+
+  // The time stamp of the last XdndPosition event we received. The XDND
+  // specification mandates that we use this time stamp when querying the source
+  // about the drag and drop data.
+  ::Time position_time_stamp_;
+
+  // A SelectionFormatMap of data that we have in our process.
+  ui::SelectionFormatMap fetched_targets_;
+
+  // The names of various data types offered by the other window that we
+  // haven't fetched and put in |fetched_targets_| yet.
+  std::vector<::Atom> unfetched_targets_;
+
+  // XdndPosition messages have a suggested action. Qt applications exclusively
+  // use this, instead of the XdndActionList which is backed by |actions_|.
+  ::Atom suggested_action_;
+
+  // Possible actions.
+  std::vector<::Atom> actions_;
+
+  bool sent_entered_ = false;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragContext);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_CONTEXT_H_
Index: dev/ui/ozone/platform/x11/x11_drag_source.cc
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_source.cc
@@ -0,0 +1,458 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/event.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/platform/scoped_event_dispatcher.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+#include "ui/ozone/platform/x11/x11_window_ozone.h"
+
+namespace ui {
+
+namespace {
+
+// The time to wait since sending the last XdndPosition message before
+// reprocessing the most recent mouse move event in case that the window
+// stacking order has changed and |source_current_window_| needs to be updated.
+const int kRepeatMouseMoveTimeoutMs = 350;
+
+// The time to wait for the target to respond after the user has released the
+// mouse button before ending the move loop.
+const int kEndMoveLoopTimeoutMs = 1000;
+
+XID ValidateXdndWindow(XID window) {
+  if (window == x11::None)
+    return x11::None;
+
+  // TODO(crbug/651775): The proxy window should be reported separately from the
+  //     target window. XDND messages should be sent to the proxy, and their
+  //     window field should point to the target.
+
+  // Figure out which window we should test as XdndAware. If |target| has
+  // XdndProxy, it will set that proxy on target, and if not, |target|'s
+  // original value will remain.
+  ui::GetXIDProperty(window, kXdndProxy, &window);
+
+  int version;
+  if (ui::GetIntProperty(window, kXdndAware, &version) &&
+      version >= kMaxXdndVersion) {
+    return window;
+  }
+  return x11::None;
+}
+
+}  // namespace
+
+X11DragSource::X11DragSource(X11WindowOzone* window,
+                             XID xwindow,
+                             int operation,
+                             const ui::OSExchangeData& data)
+    : window_(window),
+      xwindow_(xwindow),
+      drag_operation_(operation),
+      negotiated_operation_(ui::DragDropTypes::DRAG_NONE),
+      source_state_(SOURCE_STATE_OTHER),
+      format_map_(),
+      selection_owner_(gfx::GetXDisplay(),
+                       xwindow,
+                       gfx::GetAtom(kXdndSelection)),
+      screen_point_(gfx::Point()),
+      weak_factory_(this) {
+  XStoreName(gfx::GetXDisplay(), xwindow, "Chromium Drag & Drop Window");
+  CreateDragInputWindow(gfx::GetXDisplay());
+
+  base::string16 str;
+  const OSExchangeData::FilenameToURLPolicy policy =
+      OSExchangeData::FilenameToURLPolicy::DO_NOT_CONVERT_FILENAMES;
+  if (data.HasURL(policy)) {
+    GURL url;
+    base::string16 title;
+    data.GetURLAndTitle(policy, &url, &title);
+    InsertURLToSelectionFormatMap(url, title, &format_map_);
+  }
+  if (data.GetString(&str)) {
+    InsertStringToSelectionFormatMap(str, &format_map_);
+  }
+  selection_owner_.TakeOwnershipOfSelection(format_map_);
+
+  old_dispatcher_ = std::move(nested_dispatcher_);
+  nested_dispatcher_ =
+      ui::PlatformEventSource::GetInstance()->OverrideDispatcher(this);
+}
+
+X11DragSource::~X11DragSource() {
+  window_ = nullptr;
+  last_motion_in_screen_.reset();
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    SendXdndLeave(source_current_window_);
+    source_current_window_ = gfx::kNullAcceleratedWidget;
+  }
+  repeat_mouse_move_timer_.Stop();
+  end_move_loop_timer_.Stop();
+
+  grab_input_window_events_.reset();
+  XDestroyWindow(gfx::GetXDisplay(), grab_input_window_);
+  grab_input_window_ = gfx::kNullAcceleratedWidget;
+
+  nested_dispatcher_ = std::move(old_dispatcher_);
+}
+
+void X11DragSource::OnXdndStatus(const XClientMessageEvent& event) {
+  DVLOG(1) << "OnXdndStatus";
+
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+
+  if (source_window != source_current_window_)
+    return;
+
+  if (source_state_ != SOURCE_STATE_PENDING_DROP &&
+      source_state_ != SOURCE_STATE_OTHER) {
+    return;
+  }
+
+  waiting_on_status_ = false;
+  status_received_since_enter_ = true;
+
+  if (event.data.l[1] & 1) {
+    ::Atom atom_operation = event.data.l[4];
+    negotiated_operation_ = AtomToDragOperation(atom_operation);
+  } else {
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+  }
+
+  if (source_state_ == SOURCE_STATE_PENDING_DROP) {
+    // We were waiting on the status message so we could send the XdndDrop.
+    if (negotiated_operation_ == ui::DragDropTypes::DRAG_NONE) {
+      FinishDragDrop();
+      return;
+    }
+    source_state_ = SOURCE_STATE_DROPPED;
+    SendXdndDrop(source_window);
+    return;
+  }
+
+  ui::CursorType cursor_type = ui::CursorType::kNull;
+  switch (negotiated_operation_) {
+    case ui::DragDropTypes::DRAG_NONE:
+      cursor_type = ui::CursorType::kDndNone;
+      break;
+    case ui::DragDropTypes::DRAG_MOVE:
+      cursor_type = ui::CursorType::kDndMove;
+      break;
+    case ui::DragDropTypes::DRAG_COPY:
+      cursor_type = ui::CursorType::kDndCopy;
+      break;
+    case ui::DragDropTypes::DRAG_LINK:
+      cursor_type = ui::CursorType::kDndLink;
+      break;
+  }
+  // Note: event.data.[2,3] specify a rectangle. It is a request by the other
+  // window to not send further XdndPosition messages while the cursor is
+  // within it. However, it is considered advisory and (at least according to
+  // the spec) the other side must handle further position messages within
+  // it. GTK+ doesn't bother with this, so neither should we.
+
+  if (next_position_message_.get()) {
+    // We were waiting on the status message so we could send off the next
+    // position message we queued up.
+    gfx::Point p = next_position_message_->first;
+    unsigned long event_time = next_position_message_->second;
+    next_position_message_.reset();
+
+    SendXdndPosition(source_window, p, event_time);
+  }
+}
+
+void X11DragSource::OnXdndFinished(const XClientMessageEvent& event) {
+  gfx::AcceleratedWidget source_window = event.data.l[0];
+  if (source_current_window_ != source_window)
+    return;
+
+  // Clear |negotiated_operation_| if the drag was rejected.
+  if ((event.data.l[1] & 1) == 0)
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+  // Clear |source_current_window_| to avoid sending XdndLeave upon ending the
+  // move loop.
+  source_current_window_ = gfx::kNullAcceleratedWidget;
+  FinishDragDrop();
+}
+
+void X11DragSource::OnSelectionRequest(const XEvent& event) {
+  selection_owner_.OnSelectionRequest(event);
+}
+
+DragDropTypes::DragOperation X11DragSource::negotiated_operation() {
+  return negotiated_operation_;
+}
+
+bool X11DragSource::CanDispatchEvent(const ui::PlatformEvent& event) {
+  return true;
+}
+
+uint32_t X11DragSource::DispatchEvent(const ui::PlatformEvent& event) {
+  DCHECK(base::MessageLoopCurrentForUI::IsSet());
+
+  // This method processes all events while the move loop is active.
+  ui::EventType type = event->type();
+  switch (type) {
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED: {
+      bool dispatch_mouse_event = !last_motion_in_screen_.get();
+      last_motion_in_screen_.reset(
+          ui::EventFromNative(event).release()->AsMouseEvent());
+
+      last_motion_in_screen_->set_location(
+          ui::EventSystemLocationFromNative(event));
+      if (dispatch_mouse_event) {
+        // Post a task to dispatch mouse movement event when control returns to
+        // the message loop. This allows smoother dragging since the events are
+        // dispatched without waiting for the drag widget updates.
+        base::ThreadTaskRunnerHandle::Get()->PostTask(
+            FROM_HERE, base::Bind(&X11DragSource::DispatchMouseMovement,
+                                  weak_factory_.GetWeakPtr()));
+      }
+      return ui::POST_DISPATCH_NONE;
+    } break;
+    case ui::ET_MOUSE_RELEASED: {
+      // TODO: left button checking.
+      // Assume that drags are being done with the left mouse button. Only
+      // break the drag if the left mouse button was released.
+      DispatchMouseMovement();
+      HandleMouseRelease();
+
+      if (!grabbed_pointer_) {
+        // If the source widget had capture prior to the move loop starting,
+        // it may be relying on views::Widget getting the mouse release and
+        // releasing capture in Widget::OnMouseEvent().
+        return ui::POST_DISPATCH_PERFORM_DEFAULT;
+      }
+    } break;
+    default:
+      break;
+  }
+  return ui::POST_DISPATCH_PERFORM_DEFAULT;
+}
+
+void X11DragSource::CreateDragInputWindow(XDisplay* display) {
+  unsigned long attribute_mask = CWEventMask | CWOverrideRedirect;
+  XSetWindowAttributes swa;
+  memset(&swa, 0, sizeof(swa));
+  swa.override_redirect = x11::True;
+  grab_input_window_ = XCreateWindow(display, DefaultRootWindow(display), -100,
+                                     -100, 10, 10, 0, CopyFromParent, InputOnly,
+                                     CopyFromParent, attribute_mask, &swa);
+  uint32_t event_mask = ButtonPressMask | ButtonReleaseMask |
+                        PointerMotionMask | KeyPressMask | KeyReleaseMask |
+                        StructureNotifyMask;
+  grab_input_window_events_.reset(
+      new ui::XScopedEventSelector(grab_input_window_, event_mask));
+
+  XMapRaised(display, grab_input_window_);
+}
+
+void X11DragSource::SendXdndEnter(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndEnter);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = (kMaxXdndVersion << 24);  // The version number.
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+
+  std::vector<Atom> targets;
+  selection_owner_.RetrieveTargets(&targets);
+
+  if (targets.size() > 3) {
+    xev.xclient.data.l[1] |= 1;
+    ui::SetAtomArrayProperty(xwindow_, kXdndTypeList, "ATOM", targets);
+  } else {
+    // Pack the targets into the enter message.
+    for (size_t i = 0; i < targets.size(); ++i)
+      xev.xclient.data.l[2 + i] = targets[i];
+  }
+
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndLeave(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndLeave);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = 0;
+  xev.xclient.data.l[3] = 0;
+  xev.xclient.data.l[4] = 0;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::SendXdndPosition(XID dest_window,
+                                     const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  waiting_on_status_ = true;
+
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndPosition);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = (screen_point.x() << 16) | screen_point.y();
+  xev.xclient.data.l[3] = event_time;
+  xev.xclient.data.l[4] = DragOperationToAtom(drag_operation_);
+  ui::SendXClientEvent(dest_window, &xev);
+
+  // http://www.whatwg.org/specs/web-apps/current-work/multipage/dnd.html and
+  // the Xdnd protocol both recommend that drag events should be sent
+  // periodically.
+  repeat_mouse_move_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kRepeatMouseMoveTimeoutMs),
+      base::Bind(&X11DragSource::ProcessMouseMove, base::Unretained(this),
+                 screen_point, event_time));
+}
+
+void X11DragSource::SendXdndDrop(XID dest_window) {
+  XEvent xev;
+  xev.xclient.type = ClientMessage;
+  xev.xclient.message_type = gfx::GetAtom(kXdndDrop);
+  xev.xclient.format = 32;
+  xev.xclient.window = dest_window;
+  xev.xclient.data.l[0] = xwindow_;
+  xev.xclient.data.l[1] = 0;
+  xev.xclient.data.l[2] = x11::CurrentTime;
+  xev.xclient.data.l[3] = x11::None;
+  xev.xclient.data.l[4] = x11::None;
+  ui::SendXClientEvent(dest_window, &xev);
+}
+
+void X11DragSource::DispatchMouseMovement() {
+  if (!last_motion_in_screen_)
+    return;
+
+  repeat_mouse_move_timer_.Stop();
+  base::TimeTicks time_stamp = last_motion_in_screen_->time_stamp();
+  ProcessMouseMove(last_motion_in_screen_->location(),
+                   (time_stamp - base::TimeTicks()).InMilliseconds());
+
+  last_motion_in_screen_.reset();
+}
+
+void X11DragSource::ProcessMouseMove(const gfx::Point& screen_point,
+                                     unsigned long event_time) {
+  if (source_state_ != SOURCE_STATE_OTHER)
+    return;
+
+  // Find the current window the cursor is over.
+  gfx::AcceleratedWidget dest_window = gfx::kNullAcceleratedWidget;
+  window_->OnMouseMoved(screen_point, &dest_window);
+  if (dest_window == gfx::kNullAcceleratedWidget) {
+    screen_point_ = screen_point;
+    ui::EnumerateTopLevelWindows(this);
+    dest_window = ValidateXdndWindow(toplevel_);
+  }
+
+  if (source_current_window_ != dest_window) {
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndLeave(source_current_window_);
+
+    source_current_window_ = dest_window;
+    waiting_on_status_ = false;
+    next_position_message_.reset();
+    status_received_since_enter_ = false;
+    negotiated_operation_ = ui::DragDropTypes::DRAG_NONE;
+
+    if (source_current_window_ != gfx::kNullAcceleratedWidget)
+      SendXdndEnter(source_current_window_);
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      next_position_message_.reset(
+          new std::pair<gfx::Point, unsigned long>(screen_point, event_time));
+    } else {
+      SendXdndPosition(dest_window, screen_point, event_time);
+    }
+  }
+}
+
+void X11DragSource::StartEndMoveLoopTimer() {
+  end_move_loop_timer_.Start(
+      FROM_HERE, base::TimeDelta::FromMilliseconds(kEndMoveLoopTimeoutMs), this,
+      &X11DragSource::FinishDragDrop);
+}
+
+void X11DragSource::FinishDragDrop() {
+  window_->OnDragSessionClose(negotiated_operation_);
+}
+
+void X11DragSource::HandleMouseRelease() {
+  repeat_mouse_move_timer_.Stop();
+
+  if (source_state_ != SOURCE_STATE_OTHER) {
+    // The user has previously released the mouse and is clicking in
+    // frustration.
+    FinishDragDrop();
+    return;
+  }
+
+  if (source_current_window_ != gfx::kNullAcceleratedWidget) {
+    if (waiting_on_status_) {
+      if (status_received_since_enter_) {
+        // If we are waiting for an XdndStatus message, we need to wait for it
+        // to complete.
+        source_state_ = SOURCE_STATE_PENDING_DROP;
+
+        // Start timer to end the move loop if the target takes too long to send
+        // the XdndStatus and XdndFinished messages.
+        StartEndMoveLoopTimer();
+        return;
+      }
+
+      FinishDragDrop();
+      return;
+    }
+
+    if (negotiated_operation_ != ui::DragDropTypes::DRAG_NONE) {
+      // Start timer to end the move loop if the target takes too long to send
+      // an XdndFinished message. It is important that StartEndMoveLoopTimer()
+      // is called before SendXdndDrop() because SendXdndDrop()
+      // sends XdndFinished synchronously if the drop target is a Chrome
+      // window.
+      StartEndMoveLoopTimer();
+
+      // We have negotiated an action with the other end.
+      source_state_ = SOURCE_STATE_DROPPED;
+      SendXdndDrop(source_current_window_);
+      return;
+    }
+  }
+
+  FinishDragDrop();
+}
+
+bool X11DragSource::ShouldStopIterating(XID xid) {
+  if (!ui::IsWindowVisible(xid))
+    return false;
+
+  if (ui::WindowContainsPoint(xid, screen_point_)) {
+    toplevel_ = xid;
+    return true;
+  }
+  return false;
+}
+
+}  // namespace ui
Index: dev/ui/ozone/platform/x11/x11_drag_source.h
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_source.h
@@ -0,0 +1,157 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
+
+#include "base/timer/timer.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/base/x/selection_owner.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/gfx/native_widget_types.h"
+
+namespace ui {
+class MouseEvent;
+class ScopedEventDispatcher;
+class XScopedEventSelector;
+class X11WindowOzone;
+class OSExchangeData;
+
+class X11DragSource : public ui::PlatformEventDispatcher,
+                      public ui::EnumerateWindowsDelegate {
+ public:
+  explicit X11DragSource(X11WindowOzone* window,
+                         XID xwindow,
+                         int operation,
+                         const OSExchangeData& data);
+  ~X11DragSource() override;
+
+  void OnXdndStatus(const XClientMessageEvent& event);
+  void OnXdndFinished(const XClientMessageEvent& event);
+  void OnSelectionRequest(const XEvent& event);
+
+  DragDropTypes::DragOperation negotiated_operation();
+  SelectionFormatMap* format_map() { return &format_map_; }
+
+  // ui:::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& event) override;
+
+ private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
+
+  // Creates an input-only window to be used during the drag.
+  void CreateDragInputWindow(XDisplay* display);
+
+  void HandleMouseRelease();
+
+  void FinishDragDrop();
+
+  void SendXdndEnter(XID dest_window);
+  void SendXdndLeave(XID dest_window);
+  void SendXdndPosition(XID dest_window,
+                        const gfx::Point& screen_point,
+                        unsigned long event_time);
+  void SendXdndDrop(XID dest_window);
+
+  void ProcessMouseMove(const gfx::Point& screen_point,
+                        unsigned long event_time);
+
+  // Dispatch mouse movement event to |delegate_| in a posted task.
+  void DispatchMouseMovement();
+
+  void StartEndMoveLoopTimer();
+
+  // ui::EnumerateWindowsDelegate:
+  bool ShouldStopIterating(XID xid) override;
+
+  // An invisible InputOnly window. Keyboard grab and sometimes mouse grab
+  // are set on this window.
+  XID grab_input_window_;
+
+  // Events selected on |grab_input_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> grab_input_window_events_;
+
+  // Whether the pointer was grabbed on |grab_input_window_|.
+  bool grabbed_pointer_;
+
+  X11WindowOzone* window_;
+
+  XID xwindow_;
+
+  std::unique_ptr<MouseEvent> last_motion_in_screen_;
+  gfx::AcceleratedWidget source_current_window_;
+
+  // When the mouse is released, we need to wait for the last XdndStatus message
+  // only if we have previously received a status message from
+  // |source_current_window_|.
+  bool status_received_since_enter_;
+
+  // In the Xdnd protocol, we aren't supposed to send another XdndPosition
+  // message until we have received a confirming XdndStatus message.
+  bool waiting_on_status_;
+
+  // If we would send an XdndPosition message while we're waiting for an
+  // XdndStatus response, we need to cache the latest details we'd send.
+  std::unique_ptr<std::pair<gfx::Point, unsigned long>> next_position_message_;
+
+  // The operation bitfield as requested by StartDragAndDrop.
+  int drag_operation_;
+
+  // We offer the other window a list of possible operations,
+  // XdndActionsList. This is the requested action from the other window. This
+  // is DRAG_NONE if we haven't sent out an XdndPosition message yet, haven't
+  // yet received an XdndStatus or if the other window has told us that there's
+  // no action that we can agree on.
+  DragDropTypes::DragOperation negotiated_operation_;
+
+  // Reprocesses the most recent mouse move event if the mouse has not moved
+  // in a while in case the window stacking order has changed and
+  // |source_current_window_| needs to be updated.
+  base::OneShotTimer repeat_mouse_move_timer_;
+
+  SourceState source_state_;
+
+  // Ends the move loop if the target is too slow to respond after the mouse is
+  // released.
+  base::OneShotTimer end_move_loop_timer_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> nested_dispatcher_;
+
+  std::unique_ptr<ui::ScopedEventDispatcher> old_dispatcher_;
+
+  // A representation of data. This is either passed to us from the other
+  // process, or built up through a sequence of Set*() calls. It can be passed
+  // to |selection_owner_| when we take the selection.
+  SelectionFormatMap format_map_;
+
+  // Takes a snapshot of |format_map_| and offers it to other windows.
+  mutable SelectionOwner selection_owner_;
+
+  gfx::Point screen_point_;
+  XID toplevel_;
+
+  base::WeakPtrFactory<X11DragSource> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(X11DragSource);
+};
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_SOURCE_H_
Index: dev/ui/ozone/platform/x11/x11_drag_util.cc
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_util.cc
@@ -0,0 +1,109 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/ozone/platform/x11/x11_drag_util.h"
+
+#include "base/memory/ref_counted_memory.h"
+#include "base/strings/string_split.h"
+#include "base/strings/utf_string_conversions.h"
+#include "ui/base/clipboard/clipboard_constants.h"
+#include "ui/base/x/selection_utils.h"
+
+namespace ui {
+
+namespace {
+const char kDragNetscapeURL[] = "_NETSCAPE_URL";
+const char kDragString[] = "STRING";
+const char kDragText[] = "TEXT";
+const char kDragTextPlain[] = "text/plain";
+const char kDragTextPlainUtf8[] = "text/plain;charset=utf-8";
+const char kDragUtf8String[] = "UTF8_STRING";
+}  // namespace
+
+::Atom DragOperationToAtom(int drag_operation) {
+  if (drag_operation & DragDropTypes::DRAG_COPY)
+    return gfx::GetAtom(kXdndActionCopy);
+  if (drag_operation & DragDropTypes::DRAG_MOVE)
+    return gfx::GetAtom(kXdndActionMove);
+  if (drag_operation & DragDropTypes::DRAG_LINK)
+    return gfx::GetAtom(kXdndActionLink);
+
+  return x11::None;
+}
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom) {
+  if (atom == gfx::GetAtom(kXdndActionCopy))
+    return DragDropTypes::DRAG_COPY;
+  if (atom == gfx::GetAtom(kXdndActionMove))
+    return DragDropTypes::DRAG_MOVE;
+  if (atom == gfx::GetAtom(kXdndActionLink))
+    return DragDropTypes::DRAG_LINK;
+
+  return DragDropTypes::DRAG_NONE;
+}
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations) {
+  std::vector<::Atom> operations;
+  if (drag_operations & DragDropTypes::DRAG_COPY)
+    operations.push_back(gfx::GetAtom(kXdndActionCopy));
+  if (drag_operations & DragDropTypes::DRAG_MOVE)
+    operations.push_back(gfx::GetAtom(kXdndActionMove));
+  if (drag_operations & DragDropTypes::DRAG_LINK)
+    operations.push_back(gfx::GetAtom(kXdndActionLink));
+  return operations;
+}
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map) {
+  std::string utf8 = base::UTF16ToUTF8(text_data);
+  scoped_refptr<base::RefCountedMemory> mem(
+      base::RefCountedString::TakeString(&utf8));
+
+  map->Insert(gfx::GetAtom(kMimeTypeText), mem);
+  map->Insert(gfx::GetAtom(kDragText), mem);
+  map->Insert(gfx::GetAtom(kDragString), mem);
+  map->Insert(gfx::GetAtom(kDragUtf8String), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlain), mem);
+  map->Insert(gfx::GetAtom(kDragTextPlainUtf8), mem);
+}
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map) {
+  if (url.is_valid()) {
+    // Mozilla's URL format: (UTF16: URL, newline, title)
+    base::string16 spec = base::UTF8ToUTF16(url.spec());
+
+    std::vector<unsigned char> data;
+    ui::AddString16ToVector(spec, &data);
+    ui::AddString16ToVector(base::ASCIIToUTF16("\n"), &data);
+    ui::AddString16ToVector(title, &data);
+    scoped_refptr<base::RefCountedMemory> mem(
+        base::RefCountedBytes::TakeVector(&data));
+
+    map->Insert(gfx::GetAtom(kMimeTypeMozillaURL), mem);
+
+    // Set a string fallback as well.
+    InsertStringToSelectionFormatMap(spec, map);
+
+    // Set _NETSCAPE_URL for file managers like Nautilus that use it as a hint
+    // to create a link to the URL. Setting text/uri-list doesn't work because
+    // Nautilus will fetch and copy the contents of the URL to the drop target
+    // instead of linking...
+    // Format is UTF8: URL + "\n" + title.
+    std::string netscape_url = url.spec();
+    netscape_url += "\n";
+    netscape_url += base::UTF16ToUTF8(title);
+    map->Insert(gfx::GetAtom(kDragNetscapeURL),
+                scoped_refptr<base::RefCountedMemory>(
+                    base::RefCountedString::TakeString(&netscape_url)));
+  }
+}
+
+void SendXClientEvent(XID window, XEvent* xev) {
+  DCHECK_EQ(ClientMessage, xev->type);
+  XSendEvent(gfx::GetXDisplay(), window, x11::False, 0, xev);
+}
+
+}  // namespace ui
Index: dev/ui/ozone/platform/x11/x11_drag_util.h
===================================================================
--- /dev/null
+++ dev/ui/ozone/platform/x11/x11_drag_util.h
@@ -0,0 +1,107 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+#define UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
+
+#include <vector>
+
+#include "base/strings/string_util.h"
+#include "ui/base/dragdrop/drag_drop_types.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/gfx/x/x11_atom_cache.h"
+#include "url/gurl.h"
+
+namespace ui {
+
+class SelectionFormatMap;
+
+// The lowest XDND protocol version that we understand.
+//
+// The XDND protocol specification says that we must support all versions
+// between 3 and the version we advertise in the XDndAware property.
+constexpr int kMinXdndVersion = 3;
+
+// The value used in the XdndAware property.
+//
+// The XDND protocol version used between two windows will be the minimum
+// between the two versions advertised in the XDndAware property.
+constexpr int kMaxXdndVersion = 5;
+
+// Window property that contains the possible actions that will be presented to
+// the user when the drag and drop action is kXdndActionAsk.
+const char kXdndActionList[] = "XdndActionList";
+
+// Window property that tells other applications the window understands XDND.
+const char kXdndAware[] = "XdndAware";
+
+// Window property pointing to a proxy window to receive XDND target messages.
+// The XDND source must check the proxy window must for the XdndAware property,
+// and must send all XDND messages to the proxy instead of the target. However,
+// the target field in the messages must still represent the original target
+// window (the window pointed to by the cursor).
+const char kXdndProxy[] = "XdndProxy";
+
+// These actions have the same meaning as in the W3C Drag and Drop spec.
+const char kXdndActionCopy[] = "XdndActionCopy";
+const char kXdndActionMove[] = "XdndActionMove";
+const char kXdndActionLink[] = "XdndActionLink";
+
+// Message sent from an XDND source to the target to start the XDND protocol.
+// The target must wait for an XDndPosition event before querying the data.
+const char kXdndEnter[] = "XdndEnter";
+
+// Window property that holds the supported drag and drop data types.
+// This property is set on the XDND source window when the drag and drop data
+// can be converted to more than 3 types.
+const char kXdndTypeList[] = "XdndTypeList";
+
+// Message sent from an XDND source to the target when the user cancels the drag
+// and drop operation.
+const char kXdndLeave[] = "XdndLeave";
+
+// Message sent by the XDND source when the cursor position changes.
+// The source will also send an XdndPosition event right after the XdndEnter
+// event, to tell the target about the initial cursor position and the desired
+// drop action.
+// The time stamp in the XdndPosition must be used when requesting selection
+// information.
+// After the target optionally acquires selection information, it must tell the
+// source if it can accept the drop via an XdndStatus message.
+const char kXdndPosition[] = "XdndPosition";
+
+// Message sent from an XDND source to the target when the user confirms the
+// drag and drop operation.
+const char kXdndDrop[] = "XdndDrop";
+
+// Selection used by the XDND protocol to transfer data between applications.
+const char kXdndSelection[] = "XdndSelection";
+
+// Message sent by the XDND target in response to an XdndPosition message.
+// The message informs the source if the target will accept the drop, and what
+// action will be taken if the drop is accepted.
+const char kXdndStatus[] = "XdndStatus";
+
+// Message sent from an XDND target to the source in respose to an XdndDrop.
+// The message must be sent whether the target acceepts the drop or not.
+const char kXdndFinished[] = "XdndFinished";
+
+::Atom DragOperationToAtom(int drag_operation);
+
+DragDropTypes::DragOperation AtomToDragOperation(::Atom atom);
+
+std::vector<::Atom> GetOfferedDragOperations(int drag_operations);
+
+void InsertStringToSelectionFormatMap(const base::string16& text_data,
+                                      SelectionFormatMap* map);
+
+void InsertURLToSelectionFormatMap(const GURL& url,
+                                   const base::string16& title,
+                                   SelectionFormatMap* map);
+
+void SendXClientEvent(XID xwindow, XEvent* xev);
+
+}  // namespace ui
+
+#endif  // UI_OZONE_PLATFORM_X11_X11_DRAG_UTIL_H_
Index: dev/ui/ozone/platform/x11/x11_window_ozone.cc
===================================================================
--- dev.orig/ui/ozone/platform/x11/x11_window_ozone.cc
+++ dev/ui/ozone/platform/x11/x11_window_ozone.cc
@@ -5,6 +5,9 @@
 #include "ui/ozone/platform/x11/x11_window_ozone.h"
 
 #include "base/bind.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
+#include "ui/base/hit_test.h"
+#include "ui/base/x/x11_util.h"
 #include "ui/events/event.h"
 #include "ui/events/event_utils.h"
 #include "ui/events/ozone/events_ozone.h"
@@ -12,18 +15,91 @@
 #include "ui/gfx/geometry/point.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/ozone/platform/x11/x11_cursor_ozone.h"
+#include "ui/ozone/platform/x11/x11_drag_context.h"
+#include "ui/ozone/platform/x11/x11_drag_source.h"
+#include "ui/ozone/platform/x11/x11_drag_util.h"
 #include "ui/ozone/platform/x11/x11_window_manager_ozone.h"
 
 namespace ui {
 
+namespace {
+
+// These constants are defined in the Extended Window Manager Hints
+// standard...and aren't in any header that I can find.
+const int k_NET_WM_MOVERESIZE_SIZE_TOPLEFT = 0;
+const int k_NET_WM_MOVERESIZE_SIZE_TOP = 1;
+const int k_NET_WM_MOVERESIZE_SIZE_TOPRIGHT = 2;
+const int k_NET_WM_MOVERESIZE_SIZE_RIGHT = 3;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT = 4;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOM = 5;
+const int k_NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT = 6;
+const int k_NET_WM_MOVERESIZE_SIZE_LEFT = 7;
+const int k_NET_WM_MOVERESIZE_MOVE = 8;
+
+// Identifies the direction of the "hittest" for X11.
+bool IdentifyDirection(int hittest, int* direction) {
+  DCHECK(direction);
+  *direction = -1;
+  switch (hittest) {
+    case HTBOTTOM:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOM;
+      break;
+    case HTBOTTOMLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOMLEFT;
+      break;
+    case HTBOTTOMRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_BOTTOMRIGHT;
+      break;
+    case HTCAPTION:
+      *direction = k_NET_WM_MOVERESIZE_MOVE;
+      break;
+    case HTLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_LEFT;
+      break;
+    case HTRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_RIGHT;
+      break;
+    case HTTOP:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOP;
+      break;
+    case HTTOPLEFT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOPLEFT;
+      break;
+    case HTTOPRIGHT:
+      *direction = k_NET_WM_MOVERESIZE_SIZE_TOPRIGHT;
+      break;
+    default:
+      return false;
+  }
+  return true;
+}
+
+}  // namespace
+
 X11WindowOzone::X11WindowOzone(X11WindowManagerOzone* window_manager,
                                PlatformWindowDelegate* delegate,
                                const gfx::Rect& bounds)
-    : X11WindowBase(delegate, bounds), window_manager_(window_manager) {
+    : X11WindowBase(delegate, bounds),
+      window_manager_(window_manager),
+      target_current_context_(nullptr) {
   DCHECK(window_manager);
   auto* event_source = X11EventSourceLibevent::GetInstance();
   if (event_source)
     event_source->AddXEventDispatcher(this);
+
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  move_loop_client_.reset(new WindowMoveLoopClient());
+#endif
+
+  unsigned long xdnd_version = kMaxXdndVersion;
+  XChangeProperty(xdisplay(), xwindow(), gfx::GetAtom(kXdndAware), XA_ATOM, 32,
+                  PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&xdnd_version), 1);
+
+  // Set a class property key, which allows |this| to be used for interactive
+  // events, e.g. move or resize.
+  SetWmMoveResizeHandler(this, AsWmMoveResizeHandler());
 }
 
 X11WindowOzone::~X11WindowOzone() {
@@ -49,6 +125,35 @@ void X11WindowOzone::SetCursor(PlatformC
   XDefineCursor(xdisplay(), xwindow(), cursor_ozone->xcursor());
 }
 
+void X11WindowOzone::StartDrag(const ui::OSExchangeData& data,
+                               int operation,
+                               gfx::NativeCursor cursor,
+                               base::OnceCallback<void(int)> callback) {
+  std::vector<::Atom> actions = GetOfferedDragOperations(operation);
+  ui::SetAtomArrayProperty(xwindow(), kXdndActionList, "ATOM", actions);
+
+  drag_source_ =
+      std::make_unique<X11DragSource>(this, xwindow(), operation, data);
+}
+
+bool X11WindowOzone::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  DCHECK(move_loop_client_);
+  ReleaseCapture();
+  return move_loop_client_->RunMoveLoop(this, drag_offset);
+#endif
+  return true;
+}
+
+void X11WindowOzone::StopMoveLoop() {
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  ReleaseCapture();
+  move_loop_client_->EndMoveLoop();
+#endif
+}
+
 void X11WindowOzone::CheckCanDispatchNextPlatformEvent(XEvent* xev) {
   handle_next_event_ = xwindow() == x11::None ? false : IsEventForXWindow(*xev);
 }
@@ -65,12 +170,21 @@ bool X11WindowOzone::DispatchXEvent(XEve
   if (!IsEventForXWindow(*xev))
     return false;
 
+  if (ProcessDragDropEvent(xev))
+    return true;
+
   ProcessXWindowEvent(xev);
   return true;
 }
 
-bool X11WindowOzone::CanDispatchEvent(const PlatformEvent& event) {
-  return handle_next_event_;
+bool X11WindowOzone::CanDispatchEvent(const PlatformEvent& platform_event) {
+  bool in_move_loop =
+#if !defined(OS_CHROMEOS)
+      move_loop_client_->IsInMoveLoop();
+#else
+      false;
+#endif
+  return handle_next_event_ || in_move_loop;
 }
 
 uint32_t X11WindowOzone::DispatchEvent(const PlatformEvent& event) {
@@ -98,4 +212,181 @@ void X11WindowOzone::OnLostCapture() {
   delegate()->OnLostCapture();
 }
 
+void X11WindowOzone::OnDragDataCollected(const gfx::PointF& screen_point,
+                                         std::unique_ptr<OSExchangeData> data,
+                                         int operation) {
+  // TODO(jkim).
+  // delegate()->OnDragEnter(this, screen_point, std::move(data), operation);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::OnMouseMoved(const gfx::Point& point,
+                                  gfx::AcceleratedWidget* widget) {
+  // TODO(jkim).
+  // delegate()->OnMouseMoved(point, widget);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::OnDragSessionClose(int dnd_action) {
+  // TODO(jkim).
+  // drag_source_.reset();
+  // delegate()->OnDragSessionClosed(dnd_action);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+void X11WindowOzone::DispatchHostWindowDragMovement(
+    int hittest,
+    const gfx::Point& pointer_location) {
+  int direction;
+  if (!IdentifyDirection(hittest, &direction))
+    return;
+
+  // We most likely have an implicit grab right here. We need to dump it
+  // because what we're about to do is tell the window manager
+  // that it's now responsible for moving the window around; it immediately
+  // grabs when it receives the event below.
+  XUngrabPointer(xdisplay(), x11::CurrentTime);
+
+  XEvent event;
+  memset(&event, 0, sizeof(event));
+  event.xclient.type = ClientMessage;
+  event.xclient.display = xdisplay();
+  event.xclient.window = xwindow();
+  event.xclient.message_type = gfx::GetAtom("_NET_WM_MOVERESIZE");
+  event.xclient.format = 32;
+  event.xclient.data.l[0] = pointer_location.x();
+  event.xclient.data.l[1] = pointer_location.y();
+  event.xclient.data.l[2] = direction;
+  event.xclient.data.l[3] = 0;
+  event.xclient.data.l[4] = 0;
+
+  XSendEvent(xdisplay(), xroot_window(), x11::False,
+             SubstructureRedirectMask | SubstructureNotifyMask, &event);
+}
+
+void X11WindowOzone::OnDragMotion(const gfx::PointF& screen_point,
+                                  int flags,
+                                  ::Time event_time,
+                                  int operation) {
+  // TODO(jkim).
+  // gfx::AcceleratedWidget widget = gfx::kNullAcceleratedWidget;
+  // drag_operation_ =
+  //    delegate()->OnDragMotion(screen_point, event_time, operation, &widget);
+  NOTIMPLEMENTED_LOG_ONCE();
+}
+
+bool X11WindowOzone::ProcessDragDropEvent(XEvent* xev) {
+  switch (xev->type) {
+    case SelectionNotify: {
+      if (!target_current_context_.get()) {
+        NOTREACHED();
+        return false;
+      }
+      target_current_context_->OnSelectionNotify(xev->xselection);
+      return true;
+    }
+    case PropertyNotify: {
+      if (xev->xproperty.atom != gfx::GetAtom(kXdndActionList))
+        return false;
+      if (!target_current_context_.get() ||
+          target_current_context_->source_window() != xev->xany.window) {
+        return false;
+      }
+      target_current_context_->ReadActions();
+      return true;
+    }
+    case SelectionRequest: {
+      if (!drag_source_)
+        return false;
+      drag_source_->OnSelectionRequest(*xev);
+      return true;
+    }
+    case ClientMessage: {
+      XClientMessageEvent& event = xev->xclient;
+      Atom message_type = event.message_type;
+      if (message_type == gfx::GetAtom("WM_PROTOCOLS"))
+        return false;
+
+      if (message_type == gfx::GetAtom(kXdndEnter)) {
+        int version = (event.data.l[1] & 0xff000000) >> 24;
+        if (version < kMinXdndVersion) {
+          // This protocol version is not documented in the XDND standard (last
+          // revised in 1999), so we don't support it. Since don't understand
+          // the protocol spoken by the source, we can't tell it that we can't
+          // talk to it.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too old.";
+          return false;
+        }
+        if (version > kMaxXdndVersion) {
+          // The XDND version used should be the minimum between the versions
+          // advertised by the source and the target. We advertise
+          // kMaxXdndVersion, so this should never happen when talking to an
+          // XDND-compliant application.
+          LOG(ERROR)
+              << "XdndEnter message discarded because its version is too new.";
+          return false;
+        }
+        // Make sure that we've run ~X11DragContext() before creating another
+        // one.
+        target_current_context_.reset();
+        SelectionFormatMap* map = nullptr;
+        if (drag_source_)
+          map = drag_source_->format_map();
+        target_current_context_.reset(
+            new X11DragContext(this, xwindow(), event, map));
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndLeave)) {
+        // TODO(jkim).
+        // delegate()->OnDragLeave();
+        NOTIMPLEMENTED_LOG_ONCE();
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndPosition)) {
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+
+        target_current_context_->OnXdndPosition(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndStatus)) {
+        drag_source_->OnXdndStatus(event);
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndFinished)) {
+        // TODO(jkim).
+        // int negotiated_operation = drag_source_->negotiated_operation();
+        // drag_source_->OnXdndFinished(event);
+        // delegate()->OnDragSessionClosed(negotiated_operation);
+        NOTIMPLEMENTED_LOG_ONCE();
+        return true;
+      }
+      if (message_type == gfx::GetAtom(kXdndDrop)) {
+        // TODO(jkim).
+        // delegate()->OnDragDrop(nullptr);
+        return false;
+
+        if (!target_current_context_.get()) {
+          NOTREACHED();
+          return false;
+        }
+        target_current_context_->OnXdndDrop(drag_operation_);
+        target_current_context_.reset();
+        return true;
+      }
+      break;
+    }
+    default:
+      break;
+  }
+  return false;
+}
+
+WmMoveResizeHandler* X11WindowOzone::AsWmMoveResizeHandler() {
+  return static_cast<WmMoveResizeHandler*>(this);
+}
+
 }  // namespace ui
Index: dev/ui/ozone/platform/x11/x11_window_ozone.h
===================================================================
--- dev.orig/ui/ozone/platform/x11/x11_window_ozone.h
+++ dev/ui/ozone/platform/x11/x11_window_ozone.h
@@ -8,16 +8,22 @@
 #include "base/macros.h"
 #include "ui/events/platform/platform_event_dispatcher.h"
 #include "ui/events/platform/x11/x11_event_source_libevent.h"
+#include "ui/platform_window/platform_window_handler/wm_move_resize_handler.h"
+#include "ui/platform_window/x11/window_move_loop_client.h"
 #include "ui/platform_window/x11/x11_window_base.h"
 
 namespace ui {
 
+class OSExchangeData;
+class X11DragContext;
+class X11DragSource;
 class X11WindowManagerOzone;
 
 // PlatformWindow implementation for X11 Ozone. PlatformEvents are ui::Events.
 class X11WindowOzone : public X11WindowBase,
                        public PlatformEventDispatcher,
-                       public XEventDispatcher {
+                       public XEventDispatcher,
+                       public WmMoveResizeHandler {
  public:
   X11WindowOzone(X11WindowManagerOzone* window_manager,
                  PlatformWindowDelegate* delegate,
@@ -30,8 +36,16 @@ class X11WindowOzone : public X11WindowB
   // PlatformWindow:
   void PrepareForShutdown() override;
   void SetCapture() override;
+
   void ReleaseCapture() override;
   void SetCursor(PlatformCursor cursor) override;
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   // XEventDispatcher:
   void CheckCanDispatchNextPlatformEvent(XEvent* xev) override;
@@ -39,17 +53,59 @@ class X11WindowOzone : public X11WindowB
   PlatformEventDispatcher* GetPlatformEventDispatcher() override;
   bool DispatchXEvent(XEvent* event) override;
 
+  void OnDragDataCollected(const gfx::PointF& screen_point,
+                           std::unique_ptr<OSExchangeData> data,
+                           int operation);
+  void OnDragMotion(const gfx::PointF& screen_point,
+                    int flags,
+                    ::Time event_time,
+                    int operation);
+  void OnMouseMoved(const gfx::Point& point, gfx::AcceleratedWidget* widget);
+  void OnDragSessionClose(int dnd_action);
+
+  // WmMoveResizeHandler
+  void DispatchHostWindowDragMovement(
+      int hittest,
+      const gfx::Point& pointer_location) override;
+
  private:
+  enum SourceState {
+    // |source_current_window_| will receive a drop once we receive an
+    // XdndStatus from it.
+    SOURCE_STATE_PENDING_DROP,
+
+    // The move looped will be ended once we receive XdndFinished from
+    // |source_current_window_|. We should not send XdndPosition to
+    // |source_current_window_| while in this state.
+    SOURCE_STATE_DROPPED,
+
+    // There is no drag in progress or there is a drag in progress and the
+    // user has not yet released the mouse.
+    SOURCE_STATE_OTHER,
+  };
   // PlatformEventDispatcher:
   bool CanDispatchEvent(const PlatformEvent& event) override;
   uint32_t DispatchEvent(const PlatformEvent& event) override;
+  bool ProcessDragDropEvent(XEvent* xev);
+
+  WmMoveResizeHandler* AsWmMoveResizeHandler();
 
   X11WindowManagerOzone* window_manager_;
 
+// TODO(msisov, tonikitoo): Add a dummy implementation for chromeos.
+#if !defined(OS_CHROMEOS)
+  std::unique_ptr<WindowMoveLoopClient> move_loop_client_;
+#endif
+
   // Tells if this dispatcher can process next translated event based on a
   // previous check in ::CheckCanDispatchNextPlatformEvent based on a XID
   // target.
   bool handle_next_event_ = false;
+  std::unique_ptr<X11DragContext> target_current_context_;
+  // DesktopDragDropClientOzone* drag_drop_client_;
+  int drag_operation_;
+  // unsigned long source_window_;
+  std::unique_ptr<X11DragSource> drag_source_;
 
   DISALLOW_COPY_AND_ASSIGN(X11WindowOzone);
 };
Index: dev/ui/platform_window/platform_window.h
===================================================================
--- dev.orig/ui/platform_window/platform_window.h
+++ dev/ui/platform_window/platform_window.h
@@ -71,6 +71,11 @@ class PlatformWindow : public PropertyHa
   // Sets and gets the restored bounds of the platform-window.
   virtual void SetRestoredBoundsInPixels(const gfx::Rect& bounds) = 0;
   virtual gfx::Rect GetRestoredBoundsInPixels() const = 0;
+
+  // Asks to window move client to start move loop.
+  virtual bool RunMoveLoop(const gfx::Vector2d& drag_offset) = 0;
+
+  virtual void StopMoveLoop() = 0;
 };
 
 }  // namespace ui
Index: dev/ui/platform_window/stub/stub_window.cc
===================================================================
--- dev.orig/ui/platform_window/stub/stub_window.cc
+++ dev/ui/platform_window/stub/stub_window.cc
@@ -80,4 +80,10 @@ gfx::Rect StubWindow::GetRestoredBoundsI
   return gfx::Rect();
 }
 
+bool StubWindow::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void StubWindow::StopMoveLoop() {}
+
 }  // namespace ui
Index: dev/ui/platform_window/stub/stub_window.h
===================================================================
--- dev.orig/ui/platform_window/stub/stub_window.h
+++ dev/ui/platform_window/stub/stub_window.h
@@ -50,6 +50,8 @@ class STUB_WINDOW_EXPORT StubWindow : pu
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
   PlatformWindowDelegate* delegate_;
   gfx::Rect bounds_;
Index: dev/ui/platform_window/x11/BUILD.gn
===================================================================
--- dev.orig/ui/platform_window/x11/BUILD.gn
+++ dev/ui/platform_window/x11/BUILD.gn
@@ -22,6 +22,7 @@ jumbo_component("x11") {
     "//ui/events/platform/x11",
     "//ui/gfx/x",
     "//ui/platform_window",
+    "//ui/platform_window/platform_window_handler",
   ]
 
   configs += [ "//build/config/linux:x11" ]
@@ -34,7 +35,18 @@ jumbo_component("x11") {
     "x11_window_export.h",
   ]
 
-  if (use_x11) {
+  if (ozone_platform_x11) {
+    sources += [
+      "whole_screen_move_loop.cc",
+      "whole_screen_move_loop.h",
+      "window_move_loop_client.cc",
+      "window_move_loop_client.h",
+    ]
+    deps += [
+      "//ui/base",
+      "//ui/base/x",
+    ]
+  } else if (use_x11) {
     sources += [
       "x11_window.cc",
       "x11_window.h",
Index: dev/ui/platform_window/x11/whole_screen_move_loop.cc
===================================================================
--- /dev/null
+++ dev/ui/platform_window/x11/whole_screen_move_loop.cc
@@ -0,0 +1,228 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/platform_window/x11/whole_screen_move_loop.h"
+
+#include <stddef.h>
+#include <utility>
+
+#include "base/bind.h"
+#include "base/logging.h"
+#include "base/macros.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "base/single_thread_task_runner.h"
+#include "base/threading/thread_task_runner_handle.h"
+#include "ui/aura/client/capture_client.h"
+#include "ui/aura/env.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_event_dispatcher.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/x/x11_pointer_grab.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/base/x/x11_window_event_manager.h"
+#include "ui/events/event.h"
+#include "ui/events/event_utils.h"
+#include "ui/events/keycodes/keyboard_code_conversion_x.h"
+#include "ui/events/ozone/events_ozone.h"
+#include "ui/events/platform/platform_event_source.h"
+#include "ui/events/platform/scoped_event_dispatcher.h"
+#include "ui/events/platform/x11/x11_event_source.h"
+#include "ui/events/platform/x11/x11_event_source_libevent.h"
+#include "ui/gfx/x/x11.h"
+#include "ui/platform_window/platform_window_delegate.h"
+
+namespace ui {
+
+// XGrabKey requires the modifier mask to explicitly be specified.
+const unsigned int kModifiersMasks[] = {0,         // No additional modifier.
+                                        Mod2Mask,  // Num lock
+                                        LockMask,  // Caps lock
+                                        Mod5Mask,  // Scroll lock
+                                        Mod2Mask | LockMask,
+                                        Mod2Mask | Mod5Mask,
+                                        LockMask | Mod5Mask,
+                                        Mod2Mask | LockMask | Mod5Mask};
+
+WholeScreenMoveLoop::WholeScreenMoveLoop(views::X11MoveLoopDelegate* delegate)
+    : delegate_(delegate),
+      in_move_loop_(false),
+      grab_input_window_(x11::None),
+      grabbed_pointer_(false),
+      canceled_(false),
+      weak_factory_(this) {}
+
+WholeScreenMoveLoop::~WholeScreenMoveLoop() {}
+
+void WholeScreenMoveLoop::DispatchMouseMovement() {
+  if (!last_motion_in_screen_ && !last_motion_in_screen_->IsLocatedEvent())
+    return;
+  delegate_->OnMouseMovement(
+      last_motion_in_screen_->AsLocatedEvent()->location(),
+      last_motion_in_screen_->flags(), last_motion_in_screen_->time_stamp());
+  last_motion_in_screen_.reset();
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostLinux, ui::PlatformEventDispatcher implementation:
+
+bool WholeScreenMoveLoop::CanDispatchEvent(const ui::PlatformEvent& event) {
+  return in_move_loop_;
+}
+
+uint32_t WholeScreenMoveLoop::DispatchEvent(
+    const ui::PlatformEvent& platform_event) {
+  DCHECK(base::MessageLoopCurrentForUI::IsSet());
+
+  // This method processes all events while the move loop is active.
+  if (!in_move_loop_)
+    return ui::POST_DISPATCH_PERFORM_DEFAULT;
+
+  auto* event = static_cast<ui::Event*>(platform_event);
+  switch (event->type()) {
+    case ui::ET_MOUSE_MOVED:
+    case ui::ET_MOUSE_DRAGGED: {
+      bool can_send = !last_motion_in_screen_.get();
+
+      ui::MouseEvent* mouse_event = event->AsMouseEvent();
+      gfx::Point root_location = mouse_event->root_location();
+      mouse_event->set_location(root_location);
+
+      last_motion_in_screen_ = ui::Event::Clone(*event);
+      DCHECK(last_motion_in_screen_->IsMouseEvent());
+
+      if (can_send)
+        DispatchMouseMovement();
+      return ui::POST_DISPATCH_PERFORM_DEFAULT;
+    }
+    case ui::ET_MOUSE_RELEASED: {
+      ui::MouseEvent* mouse_event = event->AsMouseEvent();
+      gfx::Point root_location = mouse_event->root_location();
+      mouse_event->set_location(root_location);
+
+      last_motion_in_screen_ = ui::Event::Clone(*event);
+      DCHECK(last_motion_in_screen_->IsMouseEvent());
+
+      EndMoveLoop();
+      return ui::POST_DISPATCH_PERFORM_DEFAULT;
+    }
+    case ui::ET_KEY_PRESSED:
+      canceled_ = true;
+      EndMoveLoop();
+      return ui::POST_DISPATCH_NONE;
+    default:
+      break;
+  }
+  return ui::POST_DISPATCH_PERFORM_DEFAULT;
+}
+
+bool WholeScreenMoveLoop::RunMoveLoop() {
+  DCHECK(!in_move_loop_);  // Can only handle one nested loop at a time.
+
+  CreateDragInputWindow(gfx::GetXDisplay());
+
+  if (!GrabPointer()) {
+    XDestroyWindow(gfx::GetXDisplay(), grab_input_window_);
+    CHECK(false) << "failed to grab pointer";
+    return false;
+  }
+
+  GrabEscKey();
+
+  std::unique_ptr<ui::ScopedEventDispatcher> old_dispatcher =
+      std::move(nested_dispatcher_);
+  nested_dispatcher_ =
+      ui::PlatformEventSource::GetInstance()->OverrideDispatcher(this);
+
+  base::WeakPtr<WholeScreenMoveLoop> alive(weak_factory_.GetWeakPtr());
+
+  in_move_loop_ = true;
+  canceled_ = false;
+  base::MessageLoopCurrent::ScopedNestableTaskAllower allow_nested;
+  base::RunLoop run_loop;
+  quit_closure_ = run_loop.QuitClosure();
+  run_loop.Run();
+
+  if (!alive)
+    return false;
+
+  nested_dispatcher_ = std::move(old_dispatcher);
+  return !canceled_;
+}
+
+void WholeScreenMoveLoop::UpdateCursor() {}
+
+void WholeScreenMoveLoop::EndMoveLoop() {
+  if (!in_move_loop_)
+    return;
+
+  // Prevent DispatchMouseMovement from dispatching any posted motion event.
+  last_motion_in_screen_.reset();
+
+  // TODO(erg): Is this ungrab the cause of having to click to give input focus
+  // on drawn out windows? Not ungrabbing here screws the X server until I kill
+  // the chrome process.
+
+  // Ungrab before we let go of the window.
+  if (grabbed_pointer_)
+    ui::UngrabPointer();
+  else
+    UpdateCursor();
+
+  XDisplay* display = gfx::GetXDisplay();
+  unsigned int esc_keycode = XKeysymToKeycode(display, XK_Escape);
+  for (size_t i = 0; i < base::size(kModifiersMasks); ++i) {
+    XUngrabKey(display, esc_keycode, kModifiersMasks[i], grab_input_window_);
+  }
+
+  // Restore the previous dispatcher.
+  nested_dispatcher_.reset();
+  grab_input_window_events_.reset();
+  XDestroyWindow(display, grab_input_window_);
+  grab_input_window_ = x11::None;
+  in_move_loop_ = false;
+  quit_closure_.Run();
+}
+
+bool WholeScreenMoveLoop::GrabPointer() {
+  XDisplay* display = gfx::GetXDisplay();
+
+  // Pass "owner_events" as false so that X sends all mouse events to
+  // |grab_input_window_|.
+  int ret = ui::GrabPointer(grab_input_window_, false, x11::None);
+  if (ret != GrabSuccess) {
+    DLOG(ERROR) << "Grabbing pointer for dragging failed: "
+                << ui::GetX11ErrorString(display, ret);
+  }
+  XFlush(display);
+  return ret == GrabSuccess;
+}
+
+void WholeScreenMoveLoop::GrabEscKey() {
+  XDisplay* display = gfx::GetXDisplay();
+  unsigned int esc_keycode = XKeysymToKeycode(display, XK_Escape);
+  for (size_t i = 0; i < base::size(kModifiersMasks); ++i) {
+    XGrabKey(display, esc_keycode, kModifiersMasks[i], grab_input_window_,
+             x11::False, GrabModeAsync, GrabModeAsync);
+  }
+}
+
+void WholeScreenMoveLoop::CreateDragInputWindow(XDisplay* display) {
+  unsigned long attribute_mask = CWEventMask | CWOverrideRedirect;
+  XSetWindowAttributes swa;
+  memset(&swa, 0, sizeof(swa));
+  swa.override_redirect = x11::True;
+  grab_input_window_ = XCreateWindow(display, DefaultRootWindow(display), -100,
+                                     -100, 10, 10, 0, CopyFromParent, InputOnly,
+                                     CopyFromParent, attribute_mask, &swa);
+  uint32_t event_mask = ButtonPressMask | ButtonReleaseMask |
+                        PointerMotionMask | KeyPressMask | KeyReleaseMask |
+                        StructureNotifyMask;
+  grab_input_window_events_.reset(
+      new ui::XScopedEventSelector(grab_input_window_, event_mask));
+
+  XMapRaised(display, grab_input_window_);
+}
+
+}  // namespace ui
Index: dev/ui/platform_window/x11/whole_screen_move_loop.h
===================================================================
--- /dev/null
+++ dev/ui/platform_window/x11/whole_screen_move_loop.h
@@ -0,0 +1,90 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
+#define UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
+
+#include <stdint.h>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/macros.h"
+#include "base/memory/weak_ptr.h"
+#include "ui/base/cursor/cursor.h"
+#include "ui/events/platform/platform_event_dispatcher.h"
+#include "ui/gfx/geometry/vector2d_f.h"
+#include "ui/gfx/image/image_skia.h"
+#include "ui/gfx/native_widget_types.h"
+#include "ui/gfx/x/x11_types.h"
+#include "ui/views/widget/desktop_aura/x11_move_loop.h"
+#include "ui/views/widget/desktop_aura/x11_move_loop_delegate.h"
+
+namespace ui {
+class MouseEvent;
+class ScopedEventDispatcher;
+class XScopedEventSelector;
+class PlatformWindowDelegate;
+
+// Runs a nested run loop and grabs the mouse. This is used to implement
+// dragging.
+class WholeScreenMoveLoop : public ui::PlatformEventDispatcher {
+ public:
+  explicit WholeScreenMoveLoop(views::X11MoveLoopDelegate* delegate);
+  ~WholeScreenMoveLoop() override;
+
+  // ui:::PlatformEventDispatcher:
+  bool CanDispatchEvent(const ui::PlatformEvent& event) override;
+  uint32_t DispatchEvent(const ui::PlatformEvent& platform_event) override;
+
+  // X11MoveLoop:
+  bool RunMoveLoop();
+  void UpdateCursor();
+  void EndMoveLoop();
+
+  bool in_move_loop() { return in_move_loop_; }
+
+ private:
+  // Grabs the pointer, setting the mouse cursor to |cursor|. Returns true if
+  // successful.
+  bool GrabPointer();
+
+  void GrabEscKey();
+
+  // Creates an input-only window to be used during the drag.
+  void CreateDragInputWindow(XDisplay* display);
+
+  // Dispatch mouse movement event to |delegate_| in a posted task.
+  void DispatchMouseMovement();
+
+  views::X11MoveLoopDelegate* delegate_;
+
+  // Are we running a nested run loop from RunMoveLoop()?
+  bool in_move_loop_;
+  std::unique_ptr<ui::ScopedEventDispatcher> nested_dispatcher_;
+
+  // An invisible InputOnly window. Keyboard grab and sometimes mouse grab
+  // are set on this window.
+  XID grab_input_window_;
+
+  // Events selected on |grab_input_window_|.
+  std::unique_ptr<ui::XScopedEventSelector> grab_input_window_events_;
+
+  // Whether the pointer was grabbed on |grab_input_window_|.
+  bool grabbed_pointer_;
+
+  base::Closure quit_closure_;
+
+  // Keeps track of whether the move-loop is cancled by the user (e.g. by
+  // pressing escape).
+  bool canceled_;
+
+  std::unique_ptr<ui::Event> last_motion_in_screen_;
+  base::WeakPtrFactory<WholeScreenMoveLoop> weak_factory_;
+
+  DISALLOW_COPY_AND_ASSIGN(WholeScreenMoveLoop);
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_X11_WHOLE_SCREEN_MOVE_LOOP_H_
Index: dev/ui/platform_window/x11/window_move_loop_client.cc
===================================================================
--- /dev/null
+++ dev/ui/platform_window/x11/window_move_loop_client.cc
@@ -0,0 +1,62 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#include "ui/platform_window/x11/window_move_loop_client.h"
+
+#include <X11/Xlib.h>
+
+#include "base/debug/stack_trace.h"
+#include "base/message_loop/message_loop.h"
+#include "base/run_loop.h"
+#include "ui/aura/env.h"
+#include "ui/aura/window.h"
+#include "ui/aura/window_tree_host.h"
+#include "ui/base/x/x11_util.h"
+#include "ui/events/event.h"
+
+#include "ui/platform_window/platform_window.h"
+
+namespace ui {
+
+WindowMoveLoopClient::WindowMoveLoopClient()
+    : move_loop_(this), window_(nullptr) {}
+
+WindowMoveLoopClient::~WindowMoveLoopClient() {}
+
+void WindowMoveLoopClient::OnMouseMovement(const gfx::Point& screen_point,
+                                           int flags,
+                                           base::TimeTicks event_time) {
+  gfx::Point system_loc = screen_point - window_offset_;
+  window_->SetBounds(gfx::Rect(system_loc, gfx::Size()));
+}
+
+void WindowMoveLoopClient::OnMouseReleased() {
+  EndMoveLoop();
+}
+
+void WindowMoveLoopClient::OnMoveLoopEnded() {
+  window_ = nullptr;
+}
+
+////////////////////////////////////////////////////////////////////////////////
+// DesktopWindowTreeHostLinux, wm::WindowMoveClient implementation:
+
+bool WindowMoveLoopClient::RunMoveLoop(PlatformWindow* window,
+                                       const gfx::Vector2d& drag_offset) {
+  window_offset_ = drag_offset;
+  window_ = window;
+  window_->SetCapture();
+  return move_loop_.RunMoveLoop();
+}
+
+void WindowMoveLoopClient::EndMoveLoop() {
+  window_->ReleaseCapture();
+  move_loop_.EndMoveLoop();
+}
+
+bool WindowMoveLoopClient::IsInMoveLoop() {
+  return move_loop_.in_move_loop();
+}
+
+}  // namespace ui
Index: dev/ui/platform_window/x11/window_move_loop_client.h
===================================================================
--- /dev/null
+++ dev/ui/platform_window/x11/window_move_loop_client.h
@@ -0,0 +1,54 @@
+// Copyright (c) 2018 The Chromium Authors. All rights reserved.
+// Use of this source code is governed by a BSD-style license that can be
+// found in the LICENSE file.
+
+#ifndef UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
+#define UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
+
+#include <X11/Xlib.h>
+
+#include "base/callback.h"
+#include "base/compiler_specific.h"
+#include "base/message_loop/message_loop.h"
+#include "ui/gfx/geometry/point.h"
+#include "ui/platform_window/x11/whole_screen_move_loop.h"
+#include "ui/platform_window/x11/x11_window_export.h"
+
+namespace ui {
+
+class PlatformWindow;
+
+// When we're dragging tabs, we need to manually position our window.
+class X11_WINDOW_EXPORT WindowMoveLoopClient : public views::X11MoveLoopDelegate {
+ public:
+  WindowMoveLoopClient();
+  ~WindowMoveLoopClient() override;
+
+  // Overridden from X11MoveLoopDelegate:
+  void OnMouseMovement(const gfx::Point& screen_point,
+                       int flags,
+                       base::TimeTicks event_time) override;
+  void OnMouseReleased() override;
+  void OnMoveLoopEnded() override;
+
+  bool RunMoveLoop(PlatformWindow* window, const gfx::Vector2d& drag_offset);
+  void EndMoveLoop();
+
+  bool IsInMoveLoop();
+
+ private:
+  WholeScreenMoveLoop move_loop_;
+
+  // We need to keep track of this so we can actually move it when reacting to
+  // mouse events.
+  PlatformWindow* window_;
+
+  // Our cursor offset from the top left window origin when the drag
+  // started. Used to calculate the window's new bounds relative to the current
+  // location of the cursor.
+  gfx::Vector2d window_offset_;
+};
+
+}  // namespace ui
+
+#endif  // UI_PLATFORM_WINDOW_X11_WINDOW_MOVE_LOOP_CLIENT_H_
Index: dev/ui/platform_window/x11/x11_window_base.cc
===================================================================
--- dev.orig/ui/platform_window/x11/x11_window_base.cc
+++ dev/ui/platform_window/x11/x11_window_base.cc
@@ -18,6 +18,7 @@
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/x/x11_atom_cache.h"
 #include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_init_properties.h"
 
 namespace ui {
 
@@ -71,6 +72,27 @@ void X11WindowBase::Create() {
   swa.background_pixmap = x11::None;
   swa.bit_gravity = NorthWestGravity;
   swa.override_redirect = UseTestConfigForPlatformWindows();
+
+  ::Atom window_type;
+  // There is now default initialization for this type. Initialize it
+  // to ::WINDOW here. It will be changed by delelgate if it know the
+  // type of the window.
+  ui::PlatformWindowType ui_window_type = ui::PlatformWindowType::kWindow;
+  // TODO(msisov, jkim): pass PlatformWindowInitProperties here.
+   switch (ui_window_type) {
+    case ui::PlatformWindowType::kMenu:
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_MENU");
+      swa.override_redirect = x11::True;
+      break;
+    case ui::PlatformWindowType::kPopup:
+      swa.override_redirect = x11::True;
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NOTIFICATION");
+      break;
+    default:
+      window_type = gfx::GetAtom("_NET_WM_WINDOW_TYPE_NORMAL");
+      break;
+  }
+
   xwindow_ =
       XCreateWindow(xdisplay_, xroot_window_, bounds_.x(), bounds_.y(),
                     bounds_.width(), bounds_.height(),
@@ -80,6 +102,10 @@ void X11WindowBase::Create() {
                     CopyFromParent,  // visual
                     CWBackPixmap | CWBitGravity | CWOverrideRedirect, &swa);
 
+  XChangeProperty(xdisplay_, xwindow_, gfx::GetAtom("_NET_WM_WINDOW_TYPE"),
+                  XA_ATOM, 32, PropModeReplace,
+                  reinterpret_cast<unsigned char*>(&window_type), 1);
+
   // Setup XInput event mask.
   long event_mask = ButtonPressMask | ButtonReleaseMask | FocusChangeMask |
                     KeyPressMask | KeyReleaseMask | EnterWindowMask |
@@ -138,6 +164,13 @@ void X11WindowBase::Create() {
   size_hints.win_gravity = StaticGravity;
   XSetWMNormalHints(xdisplay_, xwindow_, &size_hints);
 
+// Disable native frame by default in non-ChromeOS builds for now.
+// TODO(msisov, tonikitoo): check if native frame should be used by checking
+// Widget::InitParams::remove_standard_frame.
+#if !defined(OS_CHROMEOS)
+  ui::SetUseOSWindowFrame(xwindow_, false);
+#endif
+
   delegate_->OnAcceleratedWidgetAvailable(xwindow_);
 }
 
@@ -170,7 +203,7 @@ void X11WindowBase::SetBounds(const gfx:
     XWindowChanges changes = {0};
     unsigned value_mask = 0;
 
-    if (bounds_.size() != bounds.size()) {
+    if (!bounds.size().IsEmpty() && bounds_.size() != bounds.size()) {
       changes.width = bounds.width();
       changes.height = bounds.height();
       value_mask |= CWHeight | CWWidth;
@@ -190,8 +223,13 @@ void X11WindowBase::SetBounds(const gfx:
   // case if we're running without a window manager.  If there's a window
   // manager, it can modify or ignore the request, but (per ICCCM) we'll get a
   // (possibly synthetic) ConfigureNotify about the actual size and correct
-  // |bounds_| later.
+  // |bounds_| later. If |bounds| came with zero size, use the previous size
+  // of |bounds_|.
+  gfx::Size size = bounds_.size();
+  if (!bounds.size().IsEmpty())
+    size = bounds_.size();
   bounds_ = bounds;
+  bounds_.set_size(size);
 
   // Even if the pixel bounds didn't change this call to the delegate should
   // still happen. The device scale factor may have changed which effectively
@@ -310,6 +348,22 @@ gfx::Rect X11WindowBase::GetRestoredBoun
   return gfx::Rect();
 }
 
+bool X11WindowBase::RunMoveLoop(const gfx::Vector2d& drag_offset) {
+  return false;
+}
+
+void X11WindowBase::StopMoveLoop() {}
+
+void X11WindowBase::StartDrag(const ui::OSExchangeData& data,
+                              int operation,
+                              gfx::NativeCursor cursor,
+                              base::OnceCallback<void(int)> callback) {
+  // If this is for ozone/X11, the child class of this, X11WindowOzone, will
+  // handle it. Otherwise, DragDrop has been implemented directly, for instance
+  // DesktopDragDropClientAuraX11 or DragDropControllerMus.
+  NOTREACHED();
+}
+
 void X11WindowBase::UnConfineCursor() {
   if (!has_pointer_barriers_)
     return;
Index: dev/ui/platform_window/x11/x11_window_base.h
===================================================================
--- dev.orig/ui/platform_window/x11/x11_window_base.h
+++ dev/ui/platform_window/x11/x11_window_base.h
@@ -11,12 +11,14 @@
 
 #include "base/callback.h"
 #include "base/containers/flat_set.h"
+#include "ui/base/dragdrop/os_exchange_data.h"
 #include "base/macros.h"
 #include "ui/gfx/geometry/rect.h"
 #include "ui/gfx/x/x11.h"
 #include "ui/gfx/x/x11_types.h"
 #include "ui/platform_window/platform_window.h"
 #include "ui/platform_window/platform_window_delegate.h"
+#include "ui/platform_window/platform_window_handler/wm_drag_handler.h"
 #include "ui/platform_window/x11/x11_window_export.h"
 
 namespace ui {
@@ -25,11 +27,18 @@ class XScopedEventSelector;
 
 // Abstract base implementation for a X11 based PlatformWindow. Methods that
 // are platform specific are left unimplemented.
-class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow {
+class X11_WINDOW_EXPORT X11WindowBase : public PlatformWindow,
+                                        public WmDragHandler {
  public:
   X11WindowBase(PlatformWindowDelegate* delegate, const gfx::Rect& bounds);
   ~X11WindowBase() override;
 
+  // Initiates Drag Action.
+  void StartDrag(const ui::OSExchangeData& data,
+                 int operation,
+                 gfx::NativeCursor cursor,
+                 base::OnceCallback<void(int)> callback) override;
+
   // PlatformWindow:
   void Show() override;
   void Hide() override;
@@ -50,6 +59,8 @@ class X11_WINDOW_EXPORT X11WindowBase :
   PlatformImeController* GetPlatformImeController() override;
   void SetRestoredBoundsInPixels(const gfx::Rect& bounds) override;
   gfx::Rect GetRestoredBoundsInPixels() const override;
+  bool RunMoveLoop(const gfx::Vector2d& drag_offset) override;
+  void StopMoveLoop() override;
 
  protected:
   // Creates new underlying XWindow. Does not map XWindow.
@@ -58,8 +69,10 @@ class X11_WINDOW_EXPORT X11WindowBase :
   void Destroy();
 
   PlatformWindowDelegate* delegate() { return delegate_; }
+
   XDisplay* xdisplay() { return xdisplay_; }
   XID xwindow() const { return xwindow_; }
+  XID xroot_window() const { return xroot_window_; }
 
   void UnConfineCursor();
 
Index: dev/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
===================================================================
--- dev.orig/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
+++ dev/ui/views/widget/desktop_aura/desktop_window_tree_host_platform.cc
@@ -376,14 +376,13 @@ Widget::MoveLoopResult DesktopWindowTree
     const gfx::Vector2d& drag_offset,
     Widget::MoveLoopSource source,
     Widget::MoveLoopEscapeBehavior escape_behavior) {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
+  if (platform_window()->RunMoveLoop(drag_offset))
+    return Widget::MOVE_LOOP_SUCCESSFUL;
   return Widget::MOVE_LOOP_CANCELED;
 }
 
 void DesktopWindowTreeHostPlatform::EndMoveLoop() {
-  // TODO: needs PlatformWindow support.
-  NOTIMPLEMENTED_LOG_ONCE();
+  platform_window()->StopMoveLoop();
 }
 
 void DesktopWindowTreeHostPlatform::SetVisibilityChangedAnimationsEnabled(
Index: dev/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
===================================================================
--- dev.orig/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
+++ dev/ui/views/widget/desktop_aura/x11_move_loop_delegate.h
@@ -14,6 +14,8 @@ namespace views {
 // Receives mouse events while the X11MoveLoop is tracking a drag.
 class X11MoveLoopDelegate {
  public:
+  virtual ~X11MoveLoopDelegate() {}
+
   // Called when we receive a mouse move event.
   virtual void OnMouseMovement(const gfx::Point& screen_point,
                                int flags,
