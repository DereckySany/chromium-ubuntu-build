Revert 80f1e31950c38663e3678b9ba1fb38314e878f54, as it is causing
compile errors on everything besides Clang 7.0.

Index: dev/gpu/BUILD.gn
===================================================================
--- dev.orig/gpu/BUILD.gn
+++ dev/gpu/BUILD.gn
@@ -320,7 +320,6 @@ test("gpu_unittests") {
     "command_buffer/client/raster_implementation_unittest.cc",
     "command_buffer/client/raster_implementation_unittest_autogen.h",
     "command_buffer/client/ring_buffer_test.cc",
-    "command_buffer/client/transfer_buffer_cmd_copy_helpers_unittest.cc",
     "command_buffer/client/transfer_buffer_unittest.cc",
     "command_buffer/client/vertex_array_object_manager_unittest.cc",
     "command_buffer/client/webgpu_implementation_unittest.cc",
Index: dev/gpu/GLES2/gl2chromium_autogen.h
===================================================================
--- dev.orig/gpu/GLES2/gl2chromium_autogen.h
+++ dev/gpu/GLES2/gl2chromium_autogen.h
@@ -168,12 +168,6 @@
 #define glShallowFinishCHROMIUM GLES2_GET_FUN(ShallowFinishCHROMIUM)
 #define glShallowFlushCHROMIUM GLES2_GET_FUN(ShallowFlushCHROMIUM)
 #define glOrderingBarrierCHROMIUM GLES2_GET_FUN(OrderingBarrierCHROMIUM)
-#define glMultiDrawArraysWEBGL GLES2_GET_FUN(MultiDrawArraysWEBGL)
-#define glMultiDrawArraysInstancedWEBGL \
-  GLES2_GET_FUN(MultiDrawArraysInstancedWEBGL)
-#define glMultiDrawElementsWEBGL GLES2_GET_FUN(MultiDrawElementsWEBGL)
-#define glMultiDrawElementsInstancedWEBGL \
-  GLES2_GET_FUN(MultiDrawElementsInstancedWEBGL)
 #define glStencilFunc GLES2_GET_FUN(StencilFunc)
 #define glStencilFuncSeparate GLES2_GET_FUN(StencilFuncSeparate)
 #define glStencilMask GLES2_GET_FUN(StencilMask)
Index: dev/gpu/command_buffer/build_gles2_cmd_buffer.py
===================================================================
--- dev.orig/gpu/command_buffer/build_gles2_cmd_buffer.py
+++ dev/gpu/command_buffer/build_gles2_cmd_buffer.py
@@ -2857,80 +2857,6 @@ _FUNCTION_INFO = {
     'trace_level': 2,
     'es31': True
   },
-  'MultiDrawArraysWEBGL': {
-    'type': 'Custom',
-    'cmd_args': 'GLenumDrawMode mode, '
-                'uint32_t firsts_shm_id, uint32_t firsts_shm_offset, '
-                'uint32_t counts_shm_id, uint32_t counts_shm_offset, '
-                'GLsizei drawcount',
-    'extension': 'WEBGL_multi_draw',
-    'extension_flag': 'webgl_multi_draw',
-    'data_transfer_methods': ['shm'],
-    'size_args': {
-      'firsts': 'drawcount * sizeof(GLint)',
-      'counts': 'drawcount * sizeof(GLsizei)', },
-    'defer_draws': True,
-    'impl_func': False,
-    'client_test': False,
-    'trace_level': 2,
-  },
-  'MultiDrawArraysInstancedWEBGL': {
-    'type': 'Custom',
-    'cmd_args': 'GLenumDrawMode mode, '
-                'uint32_t firsts_shm_id, uint32_t firsts_shm_offset, '
-                'uint32_t counts_shm_id, uint32_t counts_shm_offset, '
-                'uint32_t instance_counts_shm_id, '
-                'uint32_t instance_counts_shm_offset, GLsizei drawcount',
-    'extension': 'WEBGL_multi_draw_instanced',
-    'extension_flag': 'webgl_multi_draw_instanced',
-    'data_transfer_methods': ['shm'],
-    'size_args': {
-      'firsts': 'drawcount * sizeof(GLint)',
-      'counts': 'drawcount * sizeof(GLsizei)',
-      'instance_counts': 'drawcount * sizeof(GLsizei)', },
-    'defer_draws': True,
-    'impl_func': False,
-    'client_test': False,
-    'trace_level': 2,
-  },
-  'MultiDrawElementsWEBGL': {
-    'type': 'Custom',
-    'cmd_args': 'GLenumDrawMode mode, '
-                'uint32_t counts_shm_id, uint32_t counts_shm_offset, '
-                'GLenumIndexType type, '
-                'uint32_t offsets_shm_id, uint32_t offsets_shm_offset, '
-                'GLsizei drawcount',
-    'extension': 'WEBGL_multi_draw',
-    'extension_flag': 'webgl_multi_draw',
-    'data_transfer_methods': ['shm'],
-    'size_args': {
-      'counts': 'drawcount * sizeof(GLsizei)',
-      'offsets': 'drawcount * sizeof(GLsizei)', },
-    'defer_draws': True,
-    'impl_func': False,
-    'client_test': False,
-    'trace_level': 2,
-  },
-  'MultiDrawElementsInstancedWEBGL': {
-    'type': 'Custom',
-    'cmd_args': 'GLenumDrawMode mode, '
-                'uint32_t counts_shm_id, uint32_t counts_shm_offset, '
-                'GLenumIndexType type, '
-                'uint32_t offsets_shm_id, uint32_t offsets_shm_offset, '
-                'uint32_t instance_counts_shm_id, '
-                'uint32_t instance_counts_shm_offset, GLsizei drawcount',
-    'extension': 'WEBGL_multi_draw_instanced',
-    'extension_flag': 'webgl_multi_draw_instanced',
-    'data_transfer_methods': ['shm'],
-    'size_args': {
-      'counts': 'drawcount * sizeof(GLsizei)',
-      'offsets': 'drawcount * sizeof(GLsizei)',
-      'instance_counts': 'drawcount * sizeof(GLsizei)', },
-    'defer_draws': True,
-    'impl_func': False,
-    'client_test': False,
-    'trace_level': 2,
-  },
   'OverlayPromotionHintCHROMIUM': {
     'decoder_func': 'DoOverlayPromotionHintCHROMIUM',
     'extension': "CHROMIUM_uniform_stream_texture_matrix",
Index: dev/gpu/command_buffer/client/BUILD.gn
===================================================================
--- dev.orig/gpu/command_buffer/client/BUILD.gn
+++ dev/gpu/command_buffer/client/BUILD.gn
@@ -85,7 +85,6 @@ jumbo_source_set("client_sources") {
     "shared_image_interface.h",
     "transfer_buffer.cc",
     "transfer_buffer.h",
-    "transfer_buffer_cmd_copy_helpers.h",
   ]
 
   configs += [ "//gpu:gpu_implementation" ]
Index: dev/gpu/command_buffer/client/gles2_c_lib_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_c_lib_autogen.h
+++ dev/gpu/command_buffer/client/gles2_c_lib_autogen.h
@@ -740,39 +740,6 @@ void GL_APIENTRY GLES2ShallowFlushCHROMI
 void GL_APIENTRY GLES2OrderingBarrierCHROMIUM() {
   gles2::GetGLContext()->OrderingBarrierCHROMIUM();
 }
-void GL_APIENTRY GLES2MultiDrawArraysWEBGL(GLenum mode,
-                                           const GLint* firsts,
-                                           const GLsizei* counts,
-                                           GLsizei drawcount) {
-  gles2::GetGLContext()->MultiDrawArraysWEBGL(mode, firsts, counts, drawcount);
-}
-void GL_APIENTRY
-GLES2MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                   const GLint* firsts,
-                                   const GLsizei* counts,
-                                   const GLsizei* instance_counts,
-                                   GLsizei drawcount) {
-  gles2::GetGLContext()->MultiDrawArraysInstancedWEBGL(
-      mode, firsts, counts, instance_counts, drawcount);
-}
-void GL_APIENTRY GLES2MultiDrawElementsWEBGL(GLenum mode,
-                                             const GLsizei* counts,
-                                             GLenum type,
-                                             const GLsizei* offsets,
-                                             GLsizei drawcount) {
-  gles2::GetGLContext()->MultiDrawElementsWEBGL(mode, counts, type, offsets,
-                                                drawcount);
-}
-void GL_APIENTRY
-GLES2MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                     const GLsizei* counts,
-                                     GLenum type,
-                                     const GLsizei* offsets,
-                                     const GLsizei* instance_counts,
-                                     GLsizei drawcount) {
-  gles2::GetGLContext()->MultiDrawElementsInstancedWEBGL(
-      mode, counts, type, offsets, instance_counts, drawcount);
-}
 void GL_APIENTRY GLES2StencilFunc(GLenum func, GLint ref, GLuint mask) {
   gles2::GetGLContext()->StencilFunc(func, ref, mask);
 }
@@ -2510,23 +2477,6 @@ extern const NameToFunc g_gles2_function
         reinterpret_cast<GLES2FunctionPointer>(glOrderingBarrierCHROMIUM),
     },
     {
-        "glMultiDrawArraysWEBGL",
-        reinterpret_cast<GLES2FunctionPointer>(glMultiDrawArraysWEBGL),
-    },
-    {
-        "glMultiDrawArraysInstancedWEBGL",
-        reinterpret_cast<GLES2FunctionPointer>(glMultiDrawArraysInstancedWEBGL),
-    },
-    {
-        "glMultiDrawElementsWEBGL",
-        reinterpret_cast<GLES2FunctionPointer>(glMultiDrawElementsWEBGL),
-    },
-    {
-        "glMultiDrawElementsInstancedWEBGL",
-        reinterpret_cast<GLES2FunctionPointer>(
-            glMultiDrawElementsInstancedWEBGL),
-    },
-    {
         "glStencilFunc",
         reinterpret_cast<GLES2FunctionPointer>(glStencilFunc),
     },
Index: dev/gpu/command_buffer/client/gles2_cmd_helper_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_cmd_helper_autogen.h
+++ dev/gpu/command_buffer/client/gles2_cmd_helper_autogen.h
@@ -1506,70 +1506,6 @@ void ShaderSourceBucket(GLuint shader, u
   }
 }
 
-void MultiDrawArraysWEBGL(GLenum mode,
-                          uint32_t firsts_shm_id,
-                          uint32_t firsts_shm_offset,
-                          uint32_t counts_shm_id,
-                          uint32_t counts_shm_offset,
-                          GLsizei drawcount) {
-  gles2::cmds::MultiDrawArraysWEBGL* c =
-      GetCmdSpace<gles2::cmds::MultiDrawArraysWEBGL>();
-  if (c) {
-    c->Init(mode, firsts_shm_id, firsts_shm_offset, counts_shm_id,
-            counts_shm_offset, drawcount);
-  }
-}
-
-void MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                   uint32_t firsts_shm_id,
-                                   uint32_t firsts_shm_offset,
-                                   uint32_t counts_shm_id,
-                                   uint32_t counts_shm_offset,
-                                   uint32_t instance_counts_shm_id,
-                                   uint32_t instance_counts_shm_offset,
-                                   GLsizei drawcount) {
-  gles2::cmds::MultiDrawArraysInstancedWEBGL* c =
-      GetCmdSpace<gles2::cmds::MultiDrawArraysInstancedWEBGL>();
-  if (c) {
-    c->Init(mode, firsts_shm_id, firsts_shm_offset, counts_shm_id,
-            counts_shm_offset, instance_counts_shm_id,
-            instance_counts_shm_offset, drawcount);
-  }
-}
-
-void MultiDrawElementsWEBGL(GLenum mode,
-                            uint32_t counts_shm_id,
-                            uint32_t counts_shm_offset,
-                            GLenum type,
-                            uint32_t offsets_shm_id,
-                            uint32_t offsets_shm_offset,
-                            GLsizei drawcount) {
-  gles2::cmds::MultiDrawElementsWEBGL* c =
-      GetCmdSpace<gles2::cmds::MultiDrawElementsWEBGL>();
-  if (c) {
-    c->Init(mode, counts_shm_id, counts_shm_offset, type, offsets_shm_id,
-            offsets_shm_offset, drawcount);
-  }
-}
-
-void MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                     uint32_t counts_shm_id,
-                                     uint32_t counts_shm_offset,
-                                     GLenum type,
-                                     uint32_t offsets_shm_id,
-                                     uint32_t offsets_shm_offset,
-                                     uint32_t instance_counts_shm_id,
-                                     uint32_t instance_counts_shm_offset,
-                                     GLsizei drawcount) {
-  gles2::cmds::MultiDrawElementsInstancedWEBGL* c =
-      GetCmdSpace<gles2::cmds::MultiDrawElementsInstancedWEBGL>();
-  if (c) {
-    c->Init(mode, counts_shm_id, counts_shm_offset, type, offsets_shm_id,
-            offsets_shm_offset, instance_counts_shm_id,
-            instance_counts_shm_offset, drawcount);
-  }
-}
-
 void StencilFunc(GLenum func, GLint ref, GLuint mask) {
   gles2::cmds::StencilFunc* c = GetCmdSpace<gles2::cmds::StencilFunc>();
   if (c) {
Index: dev/gpu/command_buffer/client/gles2_implementation.cc
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_implementation.cc
+++ dev/gpu/command_buffer/client/gles2_implementation.cc
@@ -40,7 +40,6 @@
 #include "gpu/command_buffer/client/readback_buffer_shadow_tracker.h"
 #include "gpu/command_buffer/client/shared_memory_limits.h"
 #include "gpu/command_buffer/client/transfer_buffer.h"
-#include "gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers.h"
 #include "gpu/command_buffer/client/vertex_array_object_manager.h"
 #include "gpu/command_buffer/common/context_creation_attribs.h"
 #include "gpu/command_buffer/common/gles2_cmd_utils.h"
@@ -2137,16 +2136,22 @@ void GLES2Implementation::BufferSubDataH
   DCHECK(buffer);
   DCHECK_GT(size, 0);
 
-  auto DoBufferSubData = [&](const std::array<uint32_t, 1>&,
-                             uint32_t copy_offset, uint32_t) {
-    helper_->BufferSubData(target, offset + copy_offset, buffer->size(),
-                           buffer->shm_id(), buffer->offset());
+  const int8_t* source = static_cast<const int8_t*>(data);
+  while (size) {
+    if (!buffer->valid() || buffer->size() == 0) {
+      buffer->Reset(size);
+      if (!buffer->valid()) {
+        return;
+      }
+    }
+    memcpy(buffer->address(), source, buffer->size());
+    helper_->BufferSubData(target, offset, buffer->size(), buffer->shm_id(),
+                           buffer->offset());
     InvalidateReadbackBufferShadowDataCHROMIUM(GetBoundBufferHelper(target));
-  };
-
-  if (!TransferArraysAndExecute(size, buffer, DoBufferSubData,
-                                static_cast<const int8_t*>(data))) {
-    SetGLError(GL_OUT_OF_MEMORY, "glBufferSubData", "out of memory");
+    offset += buffer->size();
+    source += buffer->size();
+    size -= buffer->size();
+    buffer->Release();
   }
 }
 
@@ -2163,230 +2168,6 @@ void GLES2Implementation::BufferSubData(
   CheckGLError();
 }
 
-void GLES2Implementation::MultiDrawArraysWEBGLHelper(GLenum mode,
-                                                     const GLint* firsts,
-                                                     const GLsizei* counts,
-                                                     GLsizei drawcount) {
-  DCHECK_GT(drawcount, 0);
-
-  uint32_t buffer_size = ComputeCombinedCopySize(drawcount, firsts, counts);
-  ScopedTransferBufferPtr buffer(buffer_size, helper_, transfer_buffer_);
-  // TODO(crbug.com/890539): Increment a base gl_DrawID for multiple calls to
-  // this helper
-  auto DoMultiDraw = [&](const std::array<uint32_t, 2>& offsets, uint32_t,
-                         uint32_t copy_count) {
-    helper_->MultiDrawArraysWEBGL(mode, buffer.shm_id(),
-                                  buffer.offset() + offsets[0], buffer.shm_id(),
-                                  buffer.offset() + offsets[1], copy_count);
-  };
-  if (!TransferArraysAndExecute(drawcount, &buffer, DoMultiDraw, firsts,
-                                counts)) {
-    SetGLError(GL_OUT_OF_MEMORY, "glMultiDrawArraysWEBGL", "out of memory");
-  }
-}
-
-void GLES2Implementation::MultiDrawArraysInstancedWEBGLHelper(
-    GLenum mode,
-    const GLint* firsts,
-    const GLsizei* counts,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  DCHECK_GT(drawcount, 0);
-
-  uint32_t buffer_size =
-      ComputeCombinedCopySize(drawcount, firsts, counts, instance_counts);
-  ScopedTransferBufferPtr buffer(buffer_size, helper_, transfer_buffer_);
-  // TODO(crbug.com/890539): Increment a base gl_DrawID for multiple calls to
-  // this helper
-  auto DoMultiDraw = [&](const std::array<uint32_t, 3>& offsets, uint32_t,
-                         uint32_t copy_count) {
-    helper_->MultiDrawArraysInstancedWEBGL(
-        mode, buffer.shm_id(), buffer.offset() + offsets[0], buffer.shm_id(),
-        buffer.offset() + offsets[1], buffer.shm_id(),
-        buffer.offset() + offsets[2], copy_count);
-  };
-  if (!TransferArraysAndExecute(drawcount, &buffer, DoMultiDraw, firsts, counts,
-                                instance_counts)) {
-    SetGLError(GL_OUT_OF_MEMORY, "glMultiDrawArraysInstancedWEBGL",
-               "out of memory");
-  }
-}
-
-void GLES2Implementation::MultiDrawElementsWEBGLHelper(GLenum mode,
-                                                       const GLsizei* counts,
-                                                       GLenum type,
-                                                       const GLsizei* offsets,
-                                                       GLsizei drawcount) {
-  DCHECK_GT(drawcount, 0);
-
-  uint32_t buffer_size = ComputeCombinedCopySize(drawcount, counts, offsets);
-  ScopedTransferBufferPtr buffer(buffer_size, helper_, transfer_buffer_);
-  // TODO(crbug.com/890539): Increment a base gl_DrawID for multiple calls to
-  // this helper
-  auto DoMultiDraw = [&](const std::array<uint32_t, 2>& offsets, uint32_t,
-                         uint32_t copy_count) {
-    helper_->MultiDrawElementsWEBGL(
-        mode, buffer.shm_id(), buffer.offset() + offsets[0], type,
-        buffer.shm_id(), buffer.offset() + offsets[1], copy_count);
-  };
-  if (!TransferArraysAndExecute(drawcount, &buffer, DoMultiDraw, counts,
-                                offsets)) {
-    SetGLError(GL_OUT_OF_MEMORY, "glMultiDrawElementsWEBGL", "out of memory");
-  }
-}
-
-void GLES2Implementation::MultiDrawElementsInstancedWEBGLHelper(
-    GLenum mode,
-    const GLsizei* counts,
-    GLenum type,
-    const GLsizei* offsets,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  DCHECK_GT(drawcount, 0);
-
-  uint32_t buffer_size =
-      ComputeCombinedCopySize(drawcount, counts, offsets, instance_counts);
-  ScopedTransferBufferPtr buffer(buffer_size, helper_, transfer_buffer_);
-  // TODO(crbug.com/890539): Increment a base gl_DrawID for multiple calls to
-  // this helper
-  auto DoMultiDraw = [&](const std::array<uint32_t, 3>& offsets, uint32_t,
-                         uint32_t copy_count) {
-    helper_->MultiDrawElementsInstancedWEBGL(
-        mode, buffer.shm_id(), buffer.offset() + offsets[0], type,
-        buffer.shm_id(), buffer.offset() + offsets[1], buffer.shm_id(),
-        buffer.offset() + offsets[2], copy_count);
-  };
-  if (!TransferArraysAndExecute(drawcount, &buffer, DoMultiDraw, counts,
-                                offsets, instance_counts)) {
-    SetGLError(GL_OUT_OF_MEMORY, "glMultiDrawElementsInstancedWEBGL",
-               "out of memory");
-  }
-}
-
-void GLES2Implementation::MultiDrawArraysWEBGL(GLenum mode,
-                                               const GLint* firsts,
-                                               const GLsizei* counts,
-                                               GLsizei drawcount) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glMultiDrawArraysWEBGL("
-                     << GLES2Util::GetStringDrawMode(mode) << ", " << firsts
-                     << ", " << counts << ", " << drawcount << ")");
-  if (drawcount < 0) {
-    SetGLError(GL_INVALID_VALUE, "glMultiDrawArraysWEBGL", "drawcount < 0");
-    return;
-  }
-  if (drawcount == 0) {
-    return;
-  }
-  // This is for an extension for WebGL which doesn't support client side arrays
-  if (vertex_array_object_manager_->SupportsClientSideBuffers()) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawArraysWEBGL",
-               "Missing array buffer for vertex attribute");
-    return;
-  }
-  MultiDrawArraysWEBGLHelper(mode, firsts, counts, drawcount);
-  CheckGLError();
-}
-
-void GLES2Implementation::MultiDrawArraysInstancedWEBGL(
-    GLenum mode,
-    const GLint* firsts,
-    const GLsizei* counts,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glMultiDrawArraysInstancedWEBGL("
-                     << GLES2Util::GetStringDrawMode(mode) << ", " << firsts
-                     << ", " << counts << ", " << instance_counts << ", "
-                     << drawcount << ")");
-  if (drawcount < 0) {
-    SetGLError(GL_INVALID_VALUE, "glMultiDrawArraysWEBGLInstanced",
-               "drawcount < 0");
-    return;
-  }
-  if (drawcount == 0) {
-    return;
-  }
-  // This is for an extension for WebGL which doesn't support client side arrays
-  if (vertex_array_object_manager_->SupportsClientSideBuffers()) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawArraysWEBGLInstanced",
-               "Missing array buffer for vertex attribute");
-    return;
-  }
-  MultiDrawArraysInstancedWEBGLHelper(mode, firsts, counts, instance_counts,
-                                      drawcount);
-  CheckGLError();
-}
-
-void GLES2Implementation::MultiDrawElementsWEBGL(GLenum mode,
-                                                 const GLsizei* counts,
-                                                 GLenum type,
-                                                 const GLsizei* offsets,
-                                                 GLsizei drawcount) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glMultiDrawElementsWEBGL("
-                     << GLES2Util::GetStringDrawMode(mode) << ", " << counts
-                     << ", " << GLES2Util::GetStringIndexType(type) << ", "
-                     << offsets << ", " << drawcount << ")");
-  if (drawcount < 0) {
-    SetGLError(GL_INVALID_VALUE, "glMultiDrawElementsWEBGL", "drawcount < 0");
-    return;
-  }
-  if (drawcount == 0) {
-    return;
-  }
-  // This is for an extension for WebGL which doesn't support client side arrays
-  if (vertex_array_object_manager_->bound_element_array_buffer() == 0) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawElementsWEBGL",
-               "No element array buffer");
-    return;
-  }
-  if (vertex_array_object_manager_->SupportsClientSideBuffers()) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawElementsWEBGL",
-               "Missing array buffer for vertex attribute");
-    return;
-  }
-  MultiDrawElementsWEBGLHelper(mode, counts, type, offsets, drawcount);
-  CheckGLError();
-}
-
-void GLES2Implementation::MultiDrawElementsInstancedWEBGL(
-    GLenum mode,
-    const GLsizei* counts,
-    GLenum type,
-    const GLsizei* offsets,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  GPU_CLIENT_SINGLE_THREAD_CHECK();
-  GPU_CLIENT_LOG("[" << GetLogPrefix() << "] glMultiDrawElementsInstancedWEBGL("
-                     << GLES2Util::GetStringDrawMode(mode) << ", " << counts
-                     << ", " << GLES2Util::GetStringIndexType(type) << ", "
-                     << offsets << ", " << instance_counts << ", " << drawcount
-                     << ")");
-  if (drawcount < 0) {
-    SetGLError(GL_INVALID_VALUE, "glMultiDrawElementsInstancedWEBGL",
-               "drawcount < 0");
-    return;
-  }
-  if (drawcount == 0) {
-    return;
-  }
-  // This is for an extension for WebGL which doesn't support client side arrays
-  if (vertex_array_object_manager_->bound_element_array_buffer() == 0) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawElementsInstancedWEBGL",
-               "No element array buffer");
-    return;
-  }
-  if (vertex_array_object_manager_->SupportsClientSideBuffers()) {
-    SetGLError(GL_INVALID_OPERATION, "glMultiDrawElementsInstancedWEBGL",
-               "Missing array buffer for vertex attribute");
-    return;
-  }
-  MultiDrawElementsInstancedWEBGLHelper(mode, counts, type, offsets,
-                                        instance_counts, drawcount);
-  CheckGLError();
-}
-
 void GLES2Implementation::RemoveTransferBuffer(BufferTracker::Buffer* buffer) {
   int32_t token = buffer->last_usage_token();
 
Index: dev/gpu/command_buffer/client/gles2_implementation.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_implementation.h
+++ dev/gpu/command_buffer/client/gles2_implementation.h
@@ -470,30 +470,6 @@ class GLES2_IMPL_EXPORT GLES2Implementat
       GLenum target, GLintptr offset, GLsizeiptr size, const void* data,
       ScopedTransferBufferPtr* buffer);
 
-  void MultiDrawArraysWEBGLHelper(GLenum mode,
-                                  const GLint* firsts,
-                                  const GLsizei* counts,
-                                  GLsizei drawcount);
-
-  void MultiDrawArraysInstancedWEBGLHelper(GLenum mode,
-                                           const GLint* firsts,
-                                           const GLsizei* counts,
-                                           const GLsizei* instanceCounts,
-                                           GLsizei drawcount);
-
-  void MultiDrawElementsWEBGLHelper(GLenum mode,
-                                    const GLsizei* counts,
-                                    GLenum type,
-                                    const GLsizei* offsets,
-                                    GLsizei drawcount);
-
-  void MultiDrawElementsInstancedWEBGLHelper(GLenum mode,
-                                             const GLsizei* counts,
-                                             GLenum type,
-                                             const GLsizei* offsets,
-                                             const GLsizei* instanceCounts,
-                                             GLsizei drawcount);
-
   GLuint CreateImageCHROMIUMHelper(ClientBuffer buffer,
                                    GLsizei width,
                                    GLsizei height,
Index: dev/gpu/command_buffer/client/gles2_implementation_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_implementation_autogen.h
+++ dev/gpu/command_buffer/client/gles2_implementation_autogen.h
@@ -528,30 +528,6 @@ void ShallowFlushCHROMIUM() override;
 
 void OrderingBarrierCHROMIUM() override;
 
-void MultiDrawArraysWEBGL(GLenum mode,
-                          const GLint* firsts,
-                          const GLsizei* counts,
-                          GLsizei drawcount) override;
-
-void MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                   const GLint* firsts,
-                                   const GLsizei* counts,
-                                   const GLsizei* instance_counts,
-                                   GLsizei drawcount) override;
-
-void MultiDrawElementsWEBGL(GLenum mode,
-                            const GLsizei* counts,
-                            GLenum type,
-                            const GLsizei* offsets,
-                            GLsizei drawcount) override;
-
-void MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                     const GLsizei* counts,
-                                     GLenum type,
-                                     const GLsizei* offsets,
-                                     const GLsizei* instance_counts,
-                                     GLsizei drawcount) override;
-
 void StencilFunc(GLenum func, GLint ref, GLuint mask) override;
 
 void StencilFuncSeparate(GLenum face,
Index: dev/gpu/command_buffer/client/gles2_interface_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_interface_autogen.h
+++ dev/gpu/command_buffer/client/gles2_interface_autogen.h
@@ -382,26 +382,6 @@ virtual void ShaderSource(GLuint shader,
 virtual void ShallowFinishCHROMIUM() = 0;
 virtual void ShallowFlushCHROMIUM() = 0;
 virtual void OrderingBarrierCHROMIUM() = 0;
-virtual void MultiDrawArraysWEBGL(GLenum mode,
-                                  const GLint* firsts,
-                                  const GLsizei* counts,
-                                  GLsizei drawcount) = 0;
-virtual void MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                           const GLint* firsts,
-                                           const GLsizei* counts,
-                                           const GLsizei* instance_counts,
-                                           GLsizei drawcount) = 0;
-virtual void MultiDrawElementsWEBGL(GLenum mode,
-                                    const GLsizei* counts,
-                                    GLenum type,
-                                    const GLsizei* offsets,
-                                    GLsizei drawcount) = 0;
-virtual void MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                             const GLsizei* counts,
-                                             GLenum type,
-                                             const GLsizei* offsets,
-                                             const GLsizei* instance_counts,
-                                             GLsizei drawcount) = 0;
 virtual void StencilFunc(GLenum func, GLint ref, GLuint mask) = 0;
 virtual void StencilFuncSeparate(GLenum face,
                                  GLenum func,
Index: dev/gpu/command_buffer/client/gles2_interface_stub_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_interface_stub_autogen.h
+++ dev/gpu/command_buffer/client/gles2_interface_stub_autogen.h
@@ -373,26 +373,6 @@ void ShaderSource(GLuint shader,
 void ShallowFinishCHROMIUM() override;
 void ShallowFlushCHROMIUM() override;
 void OrderingBarrierCHROMIUM() override;
-void MultiDrawArraysWEBGL(GLenum mode,
-                          const GLint* firsts,
-                          const GLsizei* counts,
-                          GLsizei drawcount) override;
-void MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                   const GLint* firsts,
-                                   const GLsizei* counts,
-                                   const GLsizei* instance_counts,
-                                   GLsizei drawcount) override;
-void MultiDrawElementsWEBGL(GLenum mode,
-                            const GLsizei* counts,
-                            GLenum type,
-                            const GLsizei* offsets,
-                            GLsizei drawcount) override;
-void MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                     const GLsizei* counts,
-                                     GLenum type,
-                                     const GLsizei* offsets,
-                                     const GLsizei* instance_counts,
-                                     GLsizei drawcount) override;
 void StencilFunc(GLenum func, GLint ref, GLuint mask) override;
 void StencilFuncSeparate(GLenum face,
                          GLenum func,
Index: dev/gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
+++ dev/gpu/command_buffer/client/gles2_interface_stub_impl_autogen.h
@@ -493,28 +493,6 @@ void GLES2InterfaceStub::ShaderSource(GL
 void GLES2InterfaceStub::ShallowFinishCHROMIUM() {}
 void GLES2InterfaceStub::ShallowFlushCHROMIUM() {}
 void GLES2InterfaceStub::OrderingBarrierCHROMIUM() {}
-void GLES2InterfaceStub::MultiDrawArraysWEBGL(GLenum /* mode */,
-                                              const GLint* /* firsts */,
-                                              const GLsizei* /* counts */,
-                                              GLsizei /* drawcount */) {}
-void GLES2InterfaceStub::MultiDrawArraysInstancedWEBGL(
-    GLenum /* mode */,
-    const GLint* /* firsts */,
-    const GLsizei* /* counts */,
-    const GLsizei* /* instance_counts */,
-    GLsizei /* drawcount */) {}
-void GLES2InterfaceStub::MultiDrawElementsWEBGL(GLenum /* mode */,
-                                                const GLsizei* /* counts */,
-                                                GLenum /* type */,
-                                                const GLsizei* /* offsets */,
-                                                GLsizei /* drawcount */) {}
-void GLES2InterfaceStub::MultiDrawElementsInstancedWEBGL(
-    GLenum /* mode */,
-    const GLsizei* /* counts */,
-    GLenum /* type */,
-    const GLsizei* /* offsets */,
-    const GLsizei* /* instance_counts */,
-    GLsizei /* drawcount */) {}
 void GLES2InterfaceStub::StencilFunc(GLenum /* func */,
                                      GLint /* ref */,
                                      GLuint /* mask */) {}
Index: dev/gpu/command_buffer/client/gles2_trace_implementation_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_trace_implementation_autogen.h
+++ dev/gpu/command_buffer/client/gles2_trace_implementation_autogen.h
@@ -373,26 +373,6 @@ void ShaderSource(GLuint shader,
 void ShallowFinishCHROMIUM() override;
 void ShallowFlushCHROMIUM() override;
 void OrderingBarrierCHROMIUM() override;
-void MultiDrawArraysWEBGL(GLenum mode,
-                          const GLint* firsts,
-                          const GLsizei* counts,
-                          GLsizei drawcount) override;
-void MultiDrawArraysInstancedWEBGL(GLenum mode,
-                                   const GLint* firsts,
-                                   const GLsizei* counts,
-                                   const GLsizei* instance_counts,
-                                   GLsizei drawcount) override;
-void MultiDrawElementsWEBGL(GLenum mode,
-                            const GLsizei* counts,
-                            GLenum type,
-                            const GLsizei* offsets,
-                            GLsizei drawcount) override;
-void MultiDrawElementsInstancedWEBGL(GLenum mode,
-                                     const GLsizei* counts,
-                                     GLenum type,
-                                     const GLsizei* offsets,
-                                     const GLsizei* instance_counts,
-                                     GLsizei drawcount) override;
 void StencilFunc(GLenum func, GLint ref, GLuint mask) override;
 void StencilFuncSeparate(GLenum face,
                          GLenum func,
Index: dev/gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
+++ dev/gpu/command_buffer/client/gles2_trace_implementation_impl_autogen.h
@@ -1065,48 +1065,6 @@ void GLES2TraceImplementation::OrderingB
   gl_->OrderingBarrierCHROMIUM();
 }
 
-void GLES2TraceImplementation::MultiDrawArraysWEBGL(GLenum mode,
-                                                    const GLint* firsts,
-                                                    const GLsizei* counts,
-                                                    GLsizei drawcount) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::MultiDrawArraysWEBGL");
-  gl_->MultiDrawArraysWEBGL(mode, firsts, counts, drawcount);
-}
-
-void GLES2TraceImplementation::MultiDrawArraysInstancedWEBGL(
-    GLenum mode,
-    const GLint* firsts,
-    const GLsizei* counts,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
-                                "GLES2Trace::MultiDrawArraysInstancedWEBGL");
-  gl_->MultiDrawArraysInstancedWEBGL(mode, firsts, counts, instance_counts,
-                                     drawcount);
-}
-
-void GLES2TraceImplementation::MultiDrawElementsWEBGL(GLenum mode,
-                                                      const GLsizei* counts,
-                                                      GLenum type,
-                                                      const GLsizei* offsets,
-                                                      GLsizei drawcount) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu", "GLES2Trace::MultiDrawElementsWEBGL");
-  gl_->MultiDrawElementsWEBGL(mode, counts, type, offsets, drawcount);
-}
-
-void GLES2TraceImplementation::MultiDrawElementsInstancedWEBGL(
-    GLenum mode,
-    const GLsizei* counts,
-    GLenum type,
-    const GLsizei* offsets,
-    const GLsizei* instance_counts,
-    GLsizei drawcount) {
-  TRACE_EVENT_BINARY_EFFICIENT0("gpu",
-                                "GLES2Trace::MultiDrawElementsInstancedWEBGL");
-  gl_->MultiDrawElementsInstancedWEBGL(mode, counts, type, offsets,
-                                       instance_counts, drawcount);
-}
-
 void GLES2TraceImplementation::StencilFunc(GLenum func,
                                            GLint ref,
                                            GLuint mask) {
Index: dev/gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers.h
===================================================================
--- dev.orig/gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers.h
+++ /dev/null
@@ -1,194 +0,0 @@
-// Copyright (c) 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#ifndef GPU_COMMAND_BUFFER_CLIENT_TRANSFER_BUFFER_CMD_COPY_HELPERS_H_
-#define GPU_COMMAND_BUFFER_CLIENT_TRANSFER_BUFFER_CMD_COPY_HELPERS_H_
-
-#include "base/bits.h"
-#include "base/numerics/safe_math.h"
-#include "gpu/command_buffer/client/transfer_buffer.h"
-
-namespace gpu {
-
-// Sum the sizes of the types in Ts as CheckedNumeric<T>.
-template <typename T, typename... Ts>
-constexpr base::CheckedNumeric<T> CheckedSizeOfPackedTypes() {
-  static_assert(sizeof...(Ts) > 0, "");
-  base::CheckedNumeric<T> checked_elements_size = 0;
-  for (size_t s : {sizeof(Ts)...}) {
-    checked_elements_size += s;
-  }
-  return checked_elements_size;
-}
-
-// Compute the number of bytes required for a struct-of-arrays where each array
-// of type T has count items. If there is an overflow, this function returns 0.
-template <typename... Ts>
-constexpr base::CheckedNumeric<uint32_t> ComputeCheckedCombinedCopySize(
-    uint32_t count) {
-  static_assert(sizeof...(Ts) > 0, "");
-  base::CheckedNumeric<uint32_t> checked_combined_size = 0;
-  base::CheckedNumeric<uint32_t> checked_count(count);
-  for (auto info : {std::make_pair(sizeof(Ts), alignof(Ts))...}) {
-    size_t alignment = info.second;
-    DCHECK(base::bits::IsPowerOfTwo(alignment));
-
-    checked_combined_size =
-        (checked_combined_size + alignment - 1) & ~(alignment - 1);
-    checked_combined_size += checked_count * info.first;
-  }
-  return checked_combined_size;
-}
-
-// Copy count items from each array in arrays starting at array[offset_count]
-// into the address pointed to by buffer
-template <typename... Ts>
-auto CopyArraysToBuffer(uint32_t count,
-                        uint32_t offset_count,
-                        void* buffer,
-                        Ts*... arrays)
-    -> std::array<uint32_t, sizeof...(arrays)> {
-  constexpr uint32_t arr_count = sizeof...(arrays);
-  static_assert(arr_count > 0, "Requires at least one array");
-  DCHECK_GT(count, 0u);
-  DCHECK(buffer);
-
-  // Length of each copy
-  std::array<size_t, arr_count> copy_lengths{{(count * sizeof(Ts))...}};
-
-  std::array<size_t, arr_count> alignments{{alignof(Ts)...}};
-
-  // Offset to the destination of each copy
-  std::array<uint32_t, arr_count> byte_offsets{};
-  byte_offsets[0] = 0;
-  base::CheckedNumeric<uint32_t> checked_byte_offset = copy_lengths[0];
-  for (uint32_t i = 1; i < arr_count; ++i) {
-    DCHECK(base::bits::IsPowerOfTwo(alignments[i]));
-    checked_byte_offset =
-        (checked_byte_offset + alignments[i] - 1) & ~(alignments[i] - 1);
-    byte_offsets[i] = checked_byte_offset.ValueOrDie();
-    checked_byte_offset += copy_lengths[i];
-  }
-
-  // Pointers to the copy sources
-  std::array<const int8_t*, arr_count> byte_pointers{
-      {(DCHECK(arrays),
-        reinterpret_cast<const int8_t*>(arrays + offset_count))...}};
-
-  for (uint32_t i = 0; i < arr_count; ++i) {
-    memcpy(static_cast<int8_t*>(buffer) + byte_offsets[i], byte_pointers[i],
-           copy_lengths[i]);
-  }
-
-  return byte_offsets;
-}
-
-// Sum the sizes of the types in Ts. This will fail to compile if the result
-// does not fit in T.
-template <typename T, typename... Ts>
-constexpr T SizeOfPackedTypes() {
-  constexpr base::CheckedNumeric<T> checked_elements_size =
-      CheckedSizeOfPackedTypes<T, Ts...>();
-  static_assert(checked_elements_size.IsValid(), "");
-  return checked_elements_size.ValueOrDie();
-}
-
-template <typename... Ts>
-constexpr uint32_t ComputeCombinedCopySize(uint32_t count) {
-  return ComputeCheckedCombinedCopySize<Ts...>(count).ValueOrDefault(
-      UINT32_MAX);
-}
-
-template <typename... Ts>
-constexpr uint32_t ComputeCombinedCopySize(uint32_t count,
-                                           const Ts*... arrays) {
-  return ComputeCheckedCombinedCopySize<Ts...>(count).ValueOrDefault(
-      UINT32_MAX);
-}
-
-// Compute the largest array size for a struct-of-arrays that can fit inside
-// a buffer
-template <typename... Ts>
-constexpr uint32_t ComputeMaxCopyCount(uint32_t buffer_size) {
-  // Start by tightly packing the elements and decrease copy_count until
-  // the total aligned copy size fits
-  constexpr uint32_t elements_size = SizeOfPackedTypes<uint32_t, Ts...>();
-  uint32_t copy_count = buffer_size / elements_size;
-
-  while (copy_count > 0) {
-    base::CheckedNumeric<uint32_t> checked_combined_size =
-        ComputeCheckedCombinedCopySize<Ts...>(copy_count);
-    uint32_t combined_size = 0;
-    if (checked_combined_size.AssignIfValid(&combined_size) &&
-        combined_size <= buffer_size) {
-      break;
-    }
-    copy_count--;
-  }
-
-  return copy_count;
-}
-
-}  // namespace gpu
-
-namespace internal {
-
-// The transfer buffer may not fit all count items from each array in arrays.
-// This function copies in equal number of items from each array into the buffer
-// and calls a callback function f. It releases the buffer and repeats until
-// all items have been consumed.
-template <typename F, typename TransferBuffer, typename... Ts>
-bool TransferArraysAndExecute(uint32_t count,
-                              TransferBuffer* buffer,
-                              const F& f,
-                              Ts*... arrays) {
-  static_assert(sizeof...(arrays) > 0, "Requires at least one array");
-  DCHECK(buffer);
-
-  uint32_t offset_count = 0;
-  while (count) {
-    uint32_t desired_size =
-        gpu::ComputeCheckedCombinedCopySize<Ts...>(count).ValueOrDefault(
-            UINT32_MAX);
-    uint32_t copy_count = gpu::ComputeMaxCopyCount<Ts...>(buffer->size());
-    if (!buffer->valid() || copy_count == 0) {
-      // Reset the buffer to the desired size
-      buffer->Reset(desired_size);
-      if (!buffer->valid()) {
-        return false;
-      }
-      // The buffer size may be less than the desired size. Recompute the number
-      // of elements to copy.
-      copy_count = gpu::ComputeMaxCopyCount<Ts...>(buffer->size());
-      if (copy_count == 0) {
-        return false;
-      }
-    }
-
-    std::array<uint32_t, sizeof...(arrays)> byte_offsets =
-        gpu::CopyArraysToBuffer(copy_count, offset_count, buffer->address(),
-                                arrays...);
-    f(byte_offsets, offset_count, copy_count);
-    buffer->Release();
-    offset_count += copy_count;
-    count -= copy_count;
-  }
-  return true;
-}
-
-}  // namespace internal
-
-namespace gpu {
-template <typename F, typename... Ts>
-bool TransferArraysAndExecute(uint32_t count,
-                              ScopedTransferBufferPtr* buffer,
-                              const F& f,
-                              Ts*... arrays) {
-  return internal::TransferArraysAndExecute<F, ScopedTransferBufferPtr, Ts...>(
-      count, buffer, f, arrays...);
-}
-
-}  // namespace gpu
-
-#endif  // GPU_COMMAND_BUFFER_CLIENT_TRANSFER_BUFFER_CMD_COPY_HELPERS_H_
Index: dev/gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers_unittest.cc
===================================================================
--- dev.orig/gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers_unittest.cc
+++ /dev/null
@@ -1,217 +0,0 @@
-// Copyright (c) 2018 The Chromium Authors. All rights reserved.
-// Use of this source code is governed by a BSD-style license that can be
-// found in the LICENSE file.
-
-#include "gpu/command_buffer/client/transfer_buffer_cmd_copy_helpers.h"
-
-#include "testing/gtest/include/gtest/gtest.h"
-
-namespace gpu {
-
-namespace {
-
-// Define a fake scoped transfer buffer to test helpers
-class FakeScopedTransferBufferPtr {
- public:
-  FakeScopedTransferBufferPtr(uint32_t max_size)
-      : valid_(false), max_size_(max_size), buffer_() {}
-
-  void Reset(uint32_t size) {
-    buffer_.resize(std::min(max_size_, size));
-    std::fill(buffer_.begin(), buffer_.end(), 0);
-    valid_ = true;
-  }
-  void Release() { buffer_.clear(); }
-  uint32_t size() const { return static_cast<uint32_t>(buffer_.size()); }
-  bool valid() const { return valid_; }
-  void* address() { return buffer_.data(); }
-
- private:
-  bool valid_;
-  uint32_t max_size_;
-  std::vector<uint8_t> buffer_;
-};
-
-constexpr uint32_t MaxCopyCount(uint32_t buffer_size) {
-  return ComputeMaxCopyCount<char, short, float, size_t>(buffer_size);
-}
-
-}  // namespace
-
-class TransferBufferCmdCopyHelpersTest : public testing::Test {
- protected:
-  struct BigStruct {
-    std::array<char, UINT32_MAX> a;
-  };
-  struct ExpectedBuffers {
-    std::vector<char> a;
-    std::vector<short> b;
-    std::vector<float> c;
-    std::vector<size_t> d;
-
-    ExpectedBuffers(uint32_t count) : a(count), b(count), c(count), d(count) {
-      uint32_t j = 0;
-      for (uint32_t i = 0; i < count; ++i) {
-        a[i] = static_cast<char>(j++);
-      }
-      for (uint32_t i = 0; i < count; ++i) {
-        b[i] = static_cast<short>(j++);
-      }
-      for (uint32_t i = 0; i < count; ++i) {
-        c[i] = static_cast<float>(j++);
-      }
-      for (uint32_t i = 0; i < count; ++i) {
-        d[i] = static_cast<size_t>(j++);
-      }
-    }
-  };
-
-  template <uint32_t BufferSize>
-  void CheckTransferArraysAndExecute(uint32_t count) {
-    FakeScopedTransferBufferPtr transfer_buffer(BufferSize);
-    ExpectedBuffers expected(count);
-
-    EXPECT_TRUE(::internal::TransferArraysAndExecute(
-        count, &transfer_buffer,
-        [&](std::array<uint32_t, 4>& byte_offsets, uint32_t copy_offset,
-            uint32_t copy_count) {
-          // Check that each sub-copy is correct
-          const uint8_t* buffer =
-              reinterpret_cast<uint8_t*>(transfer_buffer.address());
-          EXPECT_EQ(memcmp(&buffer[byte_offsets[0]], &expected.a[copy_offset],
-                           copy_count * sizeof(char)),
-                    0);
-          EXPECT_EQ(memcmp(&buffer[byte_offsets[1]], &expected.b[copy_offset],
-                           copy_count * sizeof(short)),
-                    0);
-          EXPECT_EQ(memcmp(&buffer[byte_offsets[2]], &expected.c[copy_offset],
-                           copy_count * sizeof(float)),
-                    0);
-          EXPECT_EQ(memcmp(&buffer[byte_offsets[3]], &expected.d[copy_offset],
-                           copy_count * sizeof(size_t)),
-                    0);
-        },
-        expected.a.data(), expected.b.data(), expected.c.data(),
-        expected.d.data()));
-  }
-};
-
-// Check packed size computation
-TEST_F(TransferBufferCmdCopyHelpersTest, CheckedSizeOfTypes) {
-  EXPECT_EQ((SizeOfPackedTypes<uint32_t, char>()), sizeof(bool));
-  EXPECT_EQ((SizeOfPackedTypes<uint32_t, int>()), sizeof(int));
-  EXPECT_EQ((SizeOfPackedTypes<uint32_t, float>()), sizeof(float));
-  EXPECT_EQ((SizeOfPackedTypes<uint32_t, float, int>()),
-            sizeof(float) + sizeof(int));
-  EXPECT_EQ((SizeOfPackedTypes<uint32_t, BigStruct>()), sizeof(BigStruct));
-}
-
-// Check copy size computations which do not require padding elements
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeCombinedCopySizeAligned) {
-  EXPECT_EQ((ComputeCombinedCopySize<char, int, float>(4)),
-            4 * sizeof(char) + 4 * sizeof(int) + 4 * sizeof(float));
-
-  EXPECT_EQ((ComputeCombinedCopySize<float, int, char>(3)),
-            3 * sizeof(float) + 3 * sizeof(int) + 3 * sizeof(char));
-
-  EXPECT_EQ((ComputeCombinedCopySize<BigStruct>(1)), sizeof(BigStruct));
-}
-
-// Check copy size computations where elements do require padding
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeCombinedCopySizeUnaligned) {
-  EXPECT_EQ((ComputeCombinedCopySize<char, int, float>(3)),
-            4 * sizeof(char) + 3 * sizeof(int) + 3 * sizeof(float));
-
-  EXPECT_EQ((ComputeCombinedCopySize<char, int, float>(5)),
-            8 * sizeof(char) + 5 * sizeof(int) + 5 * sizeof(float));
-}
-
-// Check that overflow in copy size computation returns UINT32_MAX
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeCombinedCopySizeOverflow) {
-  EXPECT_EQ((ComputeCombinedCopySize<BigStruct, short>(1)), UINT32_MAX);
-  EXPECT_EQ((ComputeCombinedCopySize<short, BigStruct>(1)), UINT32_MAX);
-  EXPECT_EQ((ComputeCombinedCopySize<float>(UINT32_MAX / sizeof(float) + 1)),
-            UINT32_MAX);
-  EXPECT_EQ((ComputeCombinedCopySize<BigStruct, BigStruct>(2)), UINT32_MAX);
-}
-
-// Check that the computed copy count is correct when padding is not required
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeMaxCopyCountAligned) {
-  EXPECT_EQ((ComputeMaxCopyCount<BigStruct>(UINT32_MAX)), 1u);
-  EXPECT_EQ((ComputeMaxCopyCount<int, float>(64)), 8u);
-  EXPECT_EQ((ComputeMaxCopyCount<char>(64)), 64u);
-  EXPECT_EQ((ComputeMaxCopyCount<short, char, char>(64)), 16u);
-}
-
-// Check that the computed copy count is correct when padding is required
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeMaxCopyCountUnaligned) {
-  EXPECT_EQ((ComputeMaxCopyCount<char, int, float>(64)), 7u);
-  EXPECT_EQ((ComputeMaxCopyCount<char, short, int>(64)), 9u);
-}
-
-// Check that computing copy count for a buffer of size 0 is 0;
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeMaxCopyCountZero) {
-  uint32_t buffer_size = 0;
-  EXPECT_EQ((ComputeMaxCopyCount<char>(buffer_size)), 0u);
-  EXPECT_EQ((ComputeMaxCopyCount<int, float>(buffer_size)), 0u);
-  EXPECT_EQ((ComputeMaxCopyCount<BigStruct>(buffer_size)), 0u);
-}
-
-// Check that copy count for elements whose packed size fits in the buffer
-// but computed aligned size does not is 0
-TEST_F(TransferBufferCmdCopyHelpersTest, ComputeMaxCopyCountOverflow) {
-  EXPECT_EQ((ComputeMaxCopyCount<char, float>(
-                SizeOfPackedTypes<uint32_t, char, float>())),
-            0u);
-  EXPECT_EQ((ComputeMaxCopyCount<short, float>(
-                SizeOfPackedTypes<uint32_t, short, float>())),
-            0u);
-  EXPECT_EQ((ComputeMaxCopyCount<char, size_t>(
-                SizeOfPackedTypes<uint32_t, char, size_t>())),
-            0u);
-  EXPECT_EQ((ComputeMaxCopyCount<short, size_t>(
-                SizeOfPackedTypes<uint32_t, short, size_t>())),
-            0u);
-}
-
-// Check that copied results are as expected and correctly aligned
-TEST_F(TransferBufferCmdCopyHelpersTest, TransferArraysAndExecute) {
-  // Aligned: Copy 1 element from each buffer into a transfer buffer of 256
-  // bytes
-  CheckTransferArraysAndExecute<256>(1);
-
-  // Aligned: Copy as many elements as possible from each buffer into a transfer
-  // buffer of 256 bytes
-  CheckTransferArraysAndExecute<256>(MaxCopyCount(256));
-
-  // Unaligned: Copy 1 element from each buffer into a transfer buffer of 256
-  // bytes
-  CheckTransferArraysAndExecute<257>(1);
-
-  // Unaligned: Copy as many elements as possible from each buffer into a
-  // transfer buffer of 257 bytes
-  CheckTransferArraysAndExecute<257>(MaxCopyCount(257));
-
-  // Large: Copy 1 element from each buffer into a transfer buffer of UINT32_MAX
-  // bytes
-  CheckTransferArraysAndExecute<UINT32_MAX>(1);
-
-  // Large: Copy as many elements as possible from each buffer into a transfer
-  // buffer of 256 bytes
-  CheckTransferArraysAndExecute<UINT32_MAX>(MaxCopyCount(256));
-}
-
-// Check copies that overflow and require multiple transfer buffers
-TEST_F(TransferBufferCmdCopyHelpersTest, TransferArraysAndExecuteOverflow) {
-  // Check aligned transfers
-  CheckTransferArraysAndExecute<256>(256);
-  CheckTransferArraysAndExecute<256>(512);
-  CheckTransferArraysAndExecute<4096>(64 * MaxCopyCount(4096));
-
-  // Check unaligned transfers
-  CheckTransferArraysAndExecute<257>(256);
-  CheckTransferArraysAndExecute<253>(513);
-  CheckTransferArraysAndExecute<4097>(MaxCopyCount(4097));
-}
-
-}  // namespace gpu
Index: dev/gpu/command_buffer/common/gles2_cmd_format_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/common/gles2_cmd_format_autogen.h
+++ dev/gpu/command_buffer/common/gles2_cmd_format_autogen.h
@@ -7493,328 +7493,6 @@ static_assert(offsetof(ShaderSourceBucke
 static_assert(offsetof(ShaderSourceBucket, str_bucket_id) == 8,
               "offset of ShaderSourceBucket str_bucket_id should be 8");
 
-struct MultiDrawArraysWEBGL {
-  typedef MultiDrawArraysWEBGL ValueType;
-  static const CommandId kCmdId = kMultiDrawArraysWEBGL;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLenum _mode,
-            uint32_t _firsts_shm_id,
-            uint32_t _firsts_shm_offset,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLsizei _drawcount) {
-    SetHeader();
-    mode = _mode;
-    firsts_shm_id = _firsts_shm_id;
-    firsts_shm_offset = _firsts_shm_offset;
-    counts_shm_id = _counts_shm_id;
-    counts_shm_offset = _counts_shm_offset;
-    drawcount = _drawcount;
-  }
-
-  void* Set(void* cmd,
-            GLenum _mode,
-            uint32_t _firsts_shm_id,
-            uint32_t _firsts_shm_offset,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLsizei _drawcount) {
-    static_cast<ValueType*>(cmd)->Init(_mode, _firsts_shm_id,
-                                       _firsts_shm_offset, _counts_shm_id,
-                                       _counts_shm_offset, _drawcount);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t mode;
-  uint32_t firsts_shm_id;
-  uint32_t firsts_shm_offset;
-  uint32_t counts_shm_id;
-  uint32_t counts_shm_offset;
-  int32_t drawcount;
-};
-
-static_assert(sizeof(MultiDrawArraysWEBGL) == 28,
-              "size of MultiDrawArraysWEBGL should be 28");
-static_assert(offsetof(MultiDrawArraysWEBGL, header) == 0,
-              "offset of MultiDrawArraysWEBGL header should be 0");
-static_assert(offsetof(MultiDrawArraysWEBGL, mode) == 4,
-              "offset of MultiDrawArraysWEBGL mode should be 4");
-static_assert(offsetof(MultiDrawArraysWEBGL, firsts_shm_id) == 8,
-              "offset of MultiDrawArraysWEBGL firsts_shm_id should be 8");
-static_assert(offsetof(MultiDrawArraysWEBGL, firsts_shm_offset) == 12,
-              "offset of MultiDrawArraysWEBGL firsts_shm_offset should be 12");
-static_assert(offsetof(MultiDrawArraysWEBGL, counts_shm_id) == 16,
-              "offset of MultiDrawArraysWEBGL counts_shm_id should be 16");
-static_assert(offsetof(MultiDrawArraysWEBGL, counts_shm_offset) == 20,
-              "offset of MultiDrawArraysWEBGL counts_shm_offset should be 20");
-static_assert(offsetof(MultiDrawArraysWEBGL, drawcount) == 24,
-              "offset of MultiDrawArraysWEBGL drawcount should be 24");
-
-struct MultiDrawArraysInstancedWEBGL {
-  typedef MultiDrawArraysInstancedWEBGL ValueType;
-  static const CommandId kCmdId = kMultiDrawArraysInstancedWEBGL;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLenum _mode,
-            uint32_t _firsts_shm_id,
-            uint32_t _firsts_shm_offset,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            uint32_t _instance_counts_shm_id,
-            uint32_t _instance_counts_shm_offset,
-            GLsizei _drawcount) {
-    SetHeader();
-    mode = _mode;
-    firsts_shm_id = _firsts_shm_id;
-    firsts_shm_offset = _firsts_shm_offset;
-    counts_shm_id = _counts_shm_id;
-    counts_shm_offset = _counts_shm_offset;
-    instance_counts_shm_id = _instance_counts_shm_id;
-    instance_counts_shm_offset = _instance_counts_shm_offset;
-    drawcount = _drawcount;
-  }
-
-  void* Set(void* cmd,
-            GLenum _mode,
-            uint32_t _firsts_shm_id,
-            uint32_t _firsts_shm_offset,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            uint32_t _instance_counts_shm_id,
-            uint32_t _instance_counts_shm_offset,
-            GLsizei _drawcount) {
-    static_cast<ValueType*>(cmd)->Init(
-        _mode, _firsts_shm_id, _firsts_shm_offset, _counts_shm_id,
-        _counts_shm_offset, _instance_counts_shm_id,
-        _instance_counts_shm_offset, _drawcount);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t mode;
-  uint32_t firsts_shm_id;
-  uint32_t firsts_shm_offset;
-  uint32_t counts_shm_id;
-  uint32_t counts_shm_offset;
-  uint32_t instance_counts_shm_id;
-  uint32_t instance_counts_shm_offset;
-  int32_t drawcount;
-};
-
-static_assert(sizeof(MultiDrawArraysInstancedWEBGL) == 36,
-              "size of MultiDrawArraysInstancedWEBGL should be 36");
-static_assert(offsetof(MultiDrawArraysInstancedWEBGL, header) == 0,
-              "offset of MultiDrawArraysInstancedWEBGL header should be 0");
-static_assert(offsetof(MultiDrawArraysInstancedWEBGL, mode) == 4,
-              "offset of MultiDrawArraysInstancedWEBGL mode should be 4");
-static_assert(
-    offsetof(MultiDrawArraysInstancedWEBGL, firsts_shm_id) == 8,
-    "offset of MultiDrawArraysInstancedWEBGL firsts_shm_id should be 8");
-static_assert(
-    offsetof(MultiDrawArraysInstancedWEBGL, firsts_shm_offset) == 12,
-    "offset of MultiDrawArraysInstancedWEBGL firsts_shm_offset should be 12");
-static_assert(
-    offsetof(MultiDrawArraysInstancedWEBGL, counts_shm_id) == 16,
-    "offset of MultiDrawArraysInstancedWEBGL counts_shm_id should be 16");
-static_assert(
-    offsetof(MultiDrawArraysInstancedWEBGL, counts_shm_offset) == 20,
-    "offset of MultiDrawArraysInstancedWEBGL counts_shm_offset should be 20");
-static_assert(offsetof(MultiDrawArraysInstancedWEBGL, instance_counts_shm_id) ==
-                  24,
-              "offset of MultiDrawArraysInstancedWEBGL instance_counts_shm_id "
-              "should be 24");
-static_assert(offsetof(MultiDrawArraysInstancedWEBGL,
-                       instance_counts_shm_offset) == 28,
-              "offset of MultiDrawArraysInstancedWEBGL "
-              "instance_counts_shm_offset should be 28");
-static_assert(offsetof(MultiDrawArraysInstancedWEBGL, drawcount) == 32,
-              "offset of MultiDrawArraysInstancedWEBGL drawcount should be 32");
-
-struct MultiDrawElementsWEBGL {
-  typedef MultiDrawElementsWEBGL ValueType;
-  static const CommandId kCmdId = kMultiDrawElementsWEBGL;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLenum _mode,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLenum _type,
-            uint32_t _offsets_shm_id,
-            uint32_t _offsets_shm_offset,
-            GLsizei _drawcount) {
-    SetHeader();
-    mode = _mode;
-    counts_shm_id = _counts_shm_id;
-    counts_shm_offset = _counts_shm_offset;
-    type = _type;
-    offsets_shm_id = _offsets_shm_id;
-    offsets_shm_offset = _offsets_shm_offset;
-    drawcount = _drawcount;
-  }
-
-  void* Set(void* cmd,
-            GLenum _mode,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLenum _type,
-            uint32_t _offsets_shm_id,
-            uint32_t _offsets_shm_offset,
-            GLsizei _drawcount) {
-    static_cast<ValueType*>(cmd)->Init(
-        _mode, _counts_shm_id, _counts_shm_offset, _type, _offsets_shm_id,
-        _offsets_shm_offset, _drawcount);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t mode;
-  uint32_t counts_shm_id;
-  uint32_t counts_shm_offset;
-  uint32_t type;
-  uint32_t offsets_shm_id;
-  uint32_t offsets_shm_offset;
-  int32_t drawcount;
-};
-
-static_assert(sizeof(MultiDrawElementsWEBGL) == 32,
-              "size of MultiDrawElementsWEBGL should be 32");
-static_assert(offsetof(MultiDrawElementsWEBGL, header) == 0,
-              "offset of MultiDrawElementsWEBGL header should be 0");
-static_assert(offsetof(MultiDrawElementsWEBGL, mode) == 4,
-              "offset of MultiDrawElementsWEBGL mode should be 4");
-static_assert(offsetof(MultiDrawElementsWEBGL, counts_shm_id) == 8,
-              "offset of MultiDrawElementsWEBGL counts_shm_id should be 8");
-static_assert(
-    offsetof(MultiDrawElementsWEBGL, counts_shm_offset) == 12,
-    "offset of MultiDrawElementsWEBGL counts_shm_offset should be 12");
-static_assert(offsetof(MultiDrawElementsWEBGL, type) == 16,
-              "offset of MultiDrawElementsWEBGL type should be 16");
-static_assert(offsetof(MultiDrawElementsWEBGL, offsets_shm_id) == 20,
-              "offset of MultiDrawElementsWEBGL offsets_shm_id should be 20");
-static_assert(
-    offsetof(MultiDrawElementsWEBGL, offsets_shm_offset) == 24,
-    "offset of MultiDrawElementsWEBGL offsets_shm_offset should be 24");
-static_assert(offsetof(MultiDrawElementsWEBGL, drawcount) == 28,
-              "offset of MultiDrawElementsWEBGL drawcount should be 28");
-
-struct MultiDrawElementsInstancedWEBGL {
-  typedef MultiDrawElementsInstancedWEBGL ValueType;
-  static const CommandId kCmdId = kMultiDrawElementsInstancedWEBGL;
-  static const cmd::ArgFlags kArgFlags = cmd::kFixed;
-  static const uint8_t cmd_flags = CMD_FLAG_SET_TRACE_LEVEL(2);
-
-  static uint32_t ComputeSize() {
-    return static_cast<uint32_t>(sizeof(ValueType));  // NOLINT
-  }
-
-  void SetHeader() { header.SetCmd<ValueType>(); }
-
-  void Init(GLenum _mode,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLenum _type,
-            uint32_t _offsets_shm_id,
-            uint32_t _offsets_shm_offset,
-            uint32_t _instance_counts_shm_id,
-            uint32_t _instance_counts_shm_offset,
-            GLsizei _drawcount) {
-    SetHeader();
-    mode = _mode;
-    counts_shm_id = _counts_shm_id;
-    counts_shm_offset = _counts_shm_offset;
-    type = _type;
-    offsets_shm_id = _offsets_shm_id;
-    offsets_shm_offset = _offsets_shm_offset;
-    instance_counts_shm_id = _instance_counts_shm_id;
-    instance_counts_shm_offset = _instance_counts_shm_offset;
-    drawcount = _drawcount;
-  }
-
-  void* Set(void* cmd,
-            GLenum _mode,
-            uint32_t _counts_shm_id,
-            uint32_t _counts_shm_offset,
-            GLenum _type,
-            uint32_t _offsets_shm_id,
-            uint32_t _offsets_shm_offset,
-            uint32_t _instance_counts_shm_id,
-            uint32_t _instance_counts_shm_offset,
-            GLsizei _drawcount) {
-    static_cast<ValueType*>(cmd)->Init(
-        _mode, _counts_shm_id, _counts_shm_offset, _type, _offsets_shm_id,
-        _offsets_shm_offset, _instance_counts_shm_id,
-        _instance_counts_shm_offset, _drawcount);
-    return NextCmdAddress<ValueType>(cmd);
-  }
-
-  gpu::CommandHeader header;
-  uint32_t mode;
-  uint32_t counts_shm_id;
-  uint32_t counts_shm_offset;
-  uint32_t type;
-  uint32_t offsets_shm_id;
-  uint32_t offsets_shm_offset;
-  uint32_t instance_counts_shm_id;
-  uint32_t instance_counts_shm_offset;
-  int32_t drawcount;
-};
-
-static_assert(sizeof(MultiDrawElementsInstancedWEBGL) == 40,
-              "size of MultiDrawElementsInstancedWEBGL should be 40");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL, header) == 0,
-              "offset of MultiDrawElementsInstancedWEBGL header should be 0");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL, mode) == 4,
-              "offset of MultiDrawElementsInstancedWEBGL mode should be 4");
-static_assert(
-    offsetof(MultiDrawElementsInstancedWEBGL, counts_shm_id) == 8,
-    "offset of MultiDrawElementsInstancedWEBGL counts_shm_id should be 8");
-static_assert(
-    offsetof(MultiDrawElementsInstancedWEBGL, counts_shm_offset) == 12,
-    "offset of MultiDrawElementsInstancedWEBGL counts_shm_offset should be 12");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL, type) == 16,
-              "offset of MultiDrawElementsInstancedWEBGL type should be 16");
-static_assert(
-    offsetof(MultiDrawElementsInstancedWEBGL, offsets_shm_id) == 20,
-    "offset of MultiDrawElementsInstancedWEBGL offsets_shm_id should be 20");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL, offsets_shm_offset) ==
-                  24,
-              "offset of MultiDrawElementsInstancedWEBGL offsets_shm_offset "
-              "should be 24");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL,
-                       instance_counts_shm_id) == 28,
-              "offset of MultiDrawElementsInstancedWEBGL "
-              "instance_counts_shm_id should be 28");
-static_assert(offsetof(MultiDrawElementsInstancedWEBGL,
-                       instance_counts_shm_offset) == 32,
-              "offset of MultiDrawElementsInstancedWEBGL "
-              "instance_counts_shm_offset should be 32");
-static_assert(
-    offsetof(MultiDrawElementsInstancedWEBGL, drawcount) == 36,
-    "offset of MultiDrawElementsInstancedWEBGL drawcount should be 36");
-
 struct StencilFunc {
   typedef StencilFunc ValueType;
   static const CommandId kCmdId = kStencilFunc;
Index: dev/gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
+++ dev/gpu/command_buffer/common/gles2_cmd_format_test_autogen.h
@@ -2298,90 +2298,6 @@ TEST_F(GLES2FormatTest, ShaderSourceBuck
   CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
 }
 
-TEST_F(GLES2FormatTest, MultiDrawArraysWEBGL) {
-  cmds::MultiDrawArraysWEBGL& cmd = *GetBufferAs<cmds::MultiDrawArraysWEBGL>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLenum>(11), static_cast<uint32_t>(12),
-              static_cast<uint32_t>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15), static_cast<GLsizei>(16));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::MultiDrawArraysWEBGL::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLenum>(11), cmd.mode);
-  EXPECT_EQ(static_cast<uint32_t>(12), cmd.firsts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.firsts_shm_offset);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.counts_shm_offset);
-  EXPECT_EQ(static_cast<GLsizei>(16), cmd.drawcount);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, MultiDrawArraysInstancedWEBGL) {
-  cmds::MultiDrawArraysInstancedWEBGL& cmd =
-      *GetBufferAs<cmds::MultiDrawArraysInstancedWEBGL>();
-  void* next_cmd =
-      cmd.Set(&cmd, static_cast<GLenum>(11), static_cast<uint32_t>(12),
-              static_cast<uint32_t>(13), static_cast<uint32_t>(14),
-              static_cast<uint32_t>(15), static_cast<uint32_t>(16),
-              static_cast<uint32_t>(17), static_cast<GLsizei>(18));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::MultiDrawArraysInstancedWEBGL::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLenum>(11), cmd.mode);
-  EXPECT_EQ(static_cast<uint32_t>(12), cmd.firsts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.firsts_shm_offset);
-  EXPECT_EQ(static_cast<uint32_t>(14), cmd.counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.counts_shm_offset);
-  EXPECT_EQ(static_cast<uint32_t>(16), cmd.instance_counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(17), cmd.instance_counts_shm_offset);
-  EXPECT_EQ(static_cast<GLsizei>(18), cmd.drawcount);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, MultiDrawElementsWEBGL) {
-  cmds::MultiDrawElementsWEBGL& cmd =
-      *GetBufferAs<cmds::MultiDrawElementsWEBGL>();
-  void* next_cmd = cmd.Set(&cmd, static_cast<GLenum>(11),
-                           static_cast<uint32_t>(12), static_cast<uint32_t>(13),
-                           static_cast<GLenum>(14), static_cast<uint32_t>(15),
-                           static_cast<uint32_t>(16), static_cast<GLsizei>(17));
-  EXPECT_EQ(static_cast<uint32_t>(cmds::MultiDrawElementsWEBGL::kCmdId),
-            cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLenum>(11), cmd.mode);
-  EXPECT_EQ(static_cast<uint32_t>(12), cmd.counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.counts_shm_offset);
-  EXPECT_EQ(static_cast<GLenum>(14), cmd.type);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.offsets_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(16), cmd.offsets_shm_offset);
-  EXPECT_EQ(static_cast<GLsizei>(17), cmd.drawcount);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
-TEST_F(GLES2FormatTest, MultiDrawElementsInstancedWEBGL) {
-  cmds::MultiDrawElementsInstancedWEBGL& cmd =
-      *GetBufferAs<cmds::MultiDrawElementsInstancedWEBGL>();
-  void* next_cmd = cmd.Set(&cmd, static_cast<GLenum>(11),
-                           static_cast<uint32_t>(12), static_cast<uint32_t>(13),
-                           static_cast<GLenum>(14), static_cast<uint32_t>(15),
-                           static_cast<uint32_t>(16), static_cast<uint32_t>(17),
-                           static_cast<uint32_t>(18), static_cast<GLsizei>(19));
-  EXPECT_EQ(
-      static_cast<uint32_t>(cmds::MultiDrawElementsInstancedWEBGL::kCmdId),
-      cmd.header.command);
-  EXPECT_EQ(sizeof(cmd), cmd.header.size * 4u);
-  EXPECT_EQ(static_cast<GLenum>(11), cmd.mode);
-  EXPECT_EQ(static_cast<uint32_t>(12), cmd.counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(13), cmd.counts_shm_offset);
-  EXPECT_EQ(static_cast<GLenum>(14), cmd.type);
-  EXPECT_EQ(static_cast<uint32_t>(15), cmd.offsets_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(16), cmd.offsets_shm_offset);
-  EXPECT_EQ(static_cast<uint32_t>(17), cmd.instance_counts_shm_id);
-  EXPECT_EQ(static_cast<uint32_t>(18), cmd.instance_counts_shm_offset);
-  EXPECT_EQ(static_cast<GLsizei>(19), cmd.drawcount);
-  CheckBytesWrittenMatchesExpectedSize(next_cmd, sizeof(cmd));
-}
-
 TEST_F(GLES2FormatTest, StencilFunc) {
   cmds::StencilFunc& cmd = *GetBufferAs<cmds::StencilFunc>();
   void* next_cmd = cmd.Set(&cmd, static_cast<GLenum>(11),
Index: dev/gpu/command_buffer/common/gles2_cmd_ids_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/common/gles2_cmd_ids_autogen.h
+++ dev/gpu/command_buffer/common/gles2_cmd_ids_autogen.h
@@ -165,10 +165,6 @@
   OP(Scissor)                                              /* 406 */ \
   OP(ShaderBinary)                                         /* 407 */ \
   OP(ShaderSourceBucket)                                   /* 408 */ \
-  OP(MultiDrawArraysWEBGL)                                 /* 409 */ \
-  OP(MultiDrawArraysInstancedWEBGL)                        /* 410 */ \
-  OP(MultiDrawElementsWEBGL)                               /* 411 */ \
-  OP(MultiDrawElementsInstancedWEBGL)                      /* 412 */ \
   OP(StencilFunc)                                          /* 413 */ \
   OP(StencilFuncSeparate)                                  /* 414 */ \
   OP(StencilMask)                                          /* 415 */ \
Index: dev/gpu/command_buffer/gles2_cmd_buffer_functions.txt
===================================================================
--- dev.orig/gpu/command_buffer/gles2_cmd_buffer_functions.txt
+++ dev/gpu/command_buffer/gles2_cmd_buffer_functions.txt
@@ -158,10 +158,6 @@ GL_APICALL void         GL_APIENTRY glSh
 GL_APICALL void         GL_APIENTRY glShallowFinishCHROMIUM (void);
 GL_APICALL void         GL_APIENTRY glShallowFlushCHROMIUM (void);
 GL_APICALL void         GL_APIENTRY glOrderingBarrierCHROMIUM (void);
-GL_APICALL void         GL_APIENTRY glMultiDrawArraysWEBGL (GLenumDrawMode mode, const GLint* firsts, const GLsizei* counts, GLsizei drawcount);
-GL_APICALL void         GL_APIENTRY glMultiDrawArraysInstancedWEBGL (GLenumDrawMode mode, const GLint* firsts, const GLsizei* counts, const GLsizei* instance_counts, GLsizei drawcount);
-GL_APICALL void         GL_APIENTRY glMultiDrawElementsWEBGL (GLenumDrawMode mode, const GLsizei* counts, GLenumIndexType type, const GLsizei* offsets, GLsizei drawcount);
-GL_APICALL void         GL_APIENTRY glMultiDrawElementsInstancedWEBGL (GLenumDrawMode mode, const GLsizei* counts, GLenumIndexType type, const GLsizei* offsets, const GLsizei* instance_counts, GLsizei drawcount);
 GL_APICALL void         GL_APIENTRY glStencilFunc (GLenumCmpFunction func, GLint ref, GLuint mask);
 GL_APICALL void         GL_APIENTRY glStencilFuncSeparate (GLenumFaceType face, GLenumCmpFunction func, GLint ref, GLuint mask);
 GL_APICALL void         GL_APIENTRY glStencilMask (GLuint mask);
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder.cc
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder.cc
@@ -11362,193 +11362,6 @@ error::Error GLES2DecoderImpl::HandleDra
       static_cast<GLenum>(c.type), &offset, &primcount, 1);
 }
 
-error::Error GLES2DecoderImpl::HandleMultiDrawArraysWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawArraysWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawArraysWEBGL*>(cmd_data);
-  if (!features().webgl_multi_draw) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t firsts_size, counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLint)).AssignIfValid(&firsts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLint* firsts = GetSharedMemoryAs<const GLint*>(
-      c.firsts_shm_id, c.firsts_shm_offset, firsts_size);
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  if (firsts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLint> firsts_copy(firsts, firsts + drawcount);
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  DoMultiDrawArraysWEBGL(mode, firsts_copy.data(), counts_copy.data(),
-                         drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderImpl::HandleMultiDrawArraysInstancedWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawArraysInstancedWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawArraysInstancedWEBGL*>(
-          cmd_data);
-  if (!features().webgl_multi_draw_instanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t firsts_size, counts_size, instance_counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLint)).AssignIfValid(&firsts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&instance_counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLint* firsts = GetSharedMemoryAs<const GLint*>(
-      c.firsts_shm_id, c.firsts_shm_offset, firsts_size);
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* instance_counts = GetSharedMemoryAs<const GLsizei*>(
-      c.instance_counts_shm_id, c.instance_counts_shm_offset,
-      instance_counts_size);
-  if (firsts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (instance_counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLint> firsts_copy(firsts, firsts + drawcount);
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  std::vector<GLsizei> instance_counts_copy(instance_counts,
-                                            instance_counts + drawcount);
-  DoMultiDrawArraysInstancedWEBGL(mode, firsts_copy.data(), counts_copy.data(),
-                                  instance_counts_copy.data(), drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderImpl::HandleMultiDrawElementsWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawElementsWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawElementsWEBGL*>(
-          cmd_data);
-  if (!features().webgl_multi_draw) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLenum type = static_cast<GLenum>(c.type);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t counts_size, offsets_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&offsets_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* offsets = GetSharedMemoryAs<const GLsizei*>(
-      c.offsets_shm_id, c.offsets_shm_offset, offsets_size);
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (offsets == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  std::vector<GLsizei> offsets_copy(offsets, offsets + drawcount);
-  DoMultiDrawElementsWEBGL(mode, counts_copy.data(), type, offsets_copy.data(),
-                           drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderImpl::HandleMultiDrawElementsInstancedWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawElementsInstancedWEBGL& c = *static_cast<
-      const volatile gles2::cmds::MultiDrawElementsInstancedWEBGL*>(cmd_data);
-  if (!features().webgl_multi_draw_instanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLenum type = static_cast<GLenum>(c.type);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t counts_size, offsets_size, instance_counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&offsets_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&instance_counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* offsets = GetSharedMemoryAs<const GLsizei*>(
-      c.offsets_shm_id, c.offsets_shm_offset, offsets_size);
-  const GLsizei* instance_counts = GetSharedMemoryAs<const GLsizei*>(
-      c.instance_counts_shm_id, c.instance_counts_shm_offset,
-      instance_counts_size);
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (offsets == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (instance_counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  std::vector<GLsizei> offsets_copy(offsets, offsets + drawcount);
-  std::vector<GLsizei> instance_counts_copy(instance_counts,
-                                            instance_counts + drawcount);
-  DoMultiDrawElementsInstancedWEBGL(mode, counts_copy.data(), type,
-                                    offsets_copy.data(),
-                                    instance_counts_copy.data(), drawcount);
-  return error::kNoError;
-}
-
 GLuint GLES2DecoderImpl::DoGetMaxValueInBufferCHROMIUM(
     GLuint buffer_id, GLsizei count, GLenum type, GLuint offset) {
   GLuint max_vertex_accessed = 0;
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doer_prototypes.h
@@ -430,26 +430,6 @@ error::Error DoLineWidth(GLfloat width);
 error::Error DoLinkProgram(GLuint program);
 error::Error DoMemoryBarrierEXT(GLbitfield barriers);
 error::Error DoMemoryBarrierByRegion(GLbitfield barriers);
-error::Error DoMultiDrawArraysWEBGL(GLenum mode,
-                                    const GLint* firsts,
-                                    const GLsizei* counts,
-                                    GLsizei drawcount);
-error::Error DoMultiDrawArraysInstancedWEBGL(GLenum mode,
-                                             const GLint* firsts,
-                                             const GLsizei* counts,
-                                             const GLsizei* instanceCounts,
-                                             GLsizei drawcount);
-error::Error DoMultiDrawElementsWEBGL(GLenum mode,
-                                      const GLsizei* counts,
-                                      GLenum type,
-                                      const GLvoid* const* indices,
-                                      GLsizei drawcount);
-error::Error DoMultiDrawElementsInstancedWEBGL(GLenum mode,
-                                               const GLsizei* counts,
-                                               GLenum type,
-                                               const GLvoid* const* indices,
-                                               const GLsizei* instanceCounts,
-                                               GLsizei drawcount);
 error::Error DoPauseTransformFeedback();
 error::Error DoPixelStorei(GLenum pname, GLint param);
 error::Error DoPolygonOffset(GLfloat factor, GLfloat units);
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_doers.cc
@@ -2165,48 +2165,6 @@ error::Error GLES2DecoderPassthroughImpl
   return error::kNoError;
 }
 
-error::Error GLES2DecoderPassthroughImpl::DoMultiDrawArraysWEBGL(
-    GLenum mode,
-    const GLint* firsts,
-    const GLsizei* counts,
-    GLsizei drawcount) {
-  api()->glMultiDrawArraysANGLEFn(mode, firsts, counts, drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoMultiDrawArraysInstancedWEBGL(
-    GLenum mode,
-    const GLint* firsts,
-    const GLsizei* counts,
-    const GLsizei* instanceCounts,
-    GLsizei drawcount) {
-  api()->glMultiDrawArraysInstancedANGLEFn(mode, firsts, counts, instanceCounts,
-                                           drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoMultiDrawElementsWEBGL(
-    GLenum mode,
-    const GLsizei* counts,
-    GLenum type,
-    const GLvoid* const* indices,
-    GLsizei drawcount) {
-  api()->glMultiDrawElementsANGLEFn(mode, counts, type, indices, drawcount);
-  return error::kNoError;
-}
-
-error::Error GLES2DecoderPassthroughImpl::DoMultiDrawElementsInstancedWEBGL(
-    GLenum mode,
-    const GLsizei* counts,
-    GLenum type,
-    const GLvoid* const* indices,
-    const GLsizei* instanceCounts,
-    GLsizei drawcount) {
-  api()->glMultiDrawElementsInstancedANGLEFn(mode, counts, type, indices,
-                                             instanceCounts, drawcount);
-  return error::kNoError;
-}
-
 error::Error GLES2DecoderPassthroughImpl::DoPauseTransformFeedback() {
   api()->glPauseTransformFeedbackFn();
   return error::kNoError;
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_passthrough_handlers.cc
@@ -1615,202 +1615,6 @@ error::Error GLES2DecoderPassthroughImpl
   return DoDrawElementsInstancedANGLE(mode, count, type, indices, primcount);
 }
 
-error::Error GLES2DecoderPassthroughImpl::HandleMultiDrawArraysWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawArraysWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawArraysWEBGL*>(cmd_data);
-  if (!features().webgl_multi_draw) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t firsts_size, counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLint)).AssignIfValid(&firsts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLint* firsts = GetSharedMemoryAs<const GLint*>(
-      c.firsts_shm_id, c.firsts_shm_offset, firsts_size);
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  if (firsts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLint> firsts_copy(firsts, firsts + drawcount);
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  return DoMultiDrawArraysWEBGL(mode, firsts_copy.data(), counts_copy.data(),
-                                drawcount);
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleMultiDrawArraysInstancedWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawArraysInstancedWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawArraysInstancedWEBGL*>(
-          cmd_data);
-  if (!features().webgl_multi_draw_instanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t firsts_size, counts_size, instance_counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLint)).AssignIfValid(&firsts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&instance_counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLint* firsts = GetSharedMemoryAs<const GLint*>(
-      c.firsts_shm_id, c.firsts_shm_offset, firsts_size);
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* instance_counts = GetSharedMemoryAs<const GLsizei*>(
-      c.instance_counts_shm_id, c.instance_counts_shm_offset,
-      instance_counts_size);
-  if (firsts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (instance_counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLint> firsts_copy(firsts, firsts + drawcount);
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  std::vector<GLsizei> instance_counts_copy(instance_counts,
-                                            instance_counts + drawcount);
-  return DoMultiDrawArraysInstancedWEBGL(
-      mode, firsts_copy.data(), counts_copy.data(), instance_counts_copy.data(),
-      drawcount);
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleMultiDrawElementsWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawElementsWEBGL& c =
-      *static_cast<const volatile gles2::cmds::MultiDrawElementsWEBGL*>(
-          cmd_data);
-  if (!features().webgl_multi_draw) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLenum type = static_cast<GLenum>(c.type);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t counts_size, offsets_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&offsets_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* offsets = GetSharedMemoryAs<const GLsizei*>(
-      c.offsets_shm_id, c.offsets_shm_offset, offsets_size);
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (offsets == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // The do-er for this function calls the ANGLE implementation which
-  // requires an array of pointers, not 32-bit integers
-  std::vector<const GLvoid*> indices(drawcount);
-  for (GLsizei draw_id = 0; draw_id < drawcount; ++draw_id) {
-    indices[draw_id] =
-        reinterpret_cast<GLvoid*>(static_cast<GLintptr>(offsets[draw_id]));
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  return DoMultiDrawElementsWEBGL(mode, counts_copy.data(), type,
-                                  indices.data(), drawcount);
-}
-
-error::Error GLES2DecoderPassthroughImpl::HandleMultiDrawElementsInstancedWEBGL(
-    uint32_t immediate_data_size,
-    const volatile void* cmd_data) {
-  const volatile gles2::cmds::MultiDrawElementsInstancedWEBGL& c = *static_cast<
-      const volatile gles2::cmds::MultiDrawElementsInstancedWEBGL*>(cmd_data);
-  if (!features().webgl_multi_draw_instanced) {
-    return error::kUnknownCommand;
-  }
-
-  GLenum mode = static_cast<GLenum>(c.mode);
-  GLenum type = static_cast<GLenum>(c.type);
-  GLsizei drawcount = static_cast<GLsizei>(c.drawcount);
-
-  uint32_t counts_size, offsets_size, instance_counts_size;
-  base::CheckedNumeric<uint32_t> checked_size(drawcount);
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&counts_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&offsets_size)) {
-    return error::kOutOfBounds;
-  }
-  if (!(checked_size * sizeof(GLsizei)).AssignIfValid(&instance_counts_size)) {
-    return error::kOutOfBounds;
-  }
-  const GLsizei* counts = GetSharedMemoryAs<const GLsizei*>(
-      c.counts_shm_id, c.counts_shm_offset, counts_size);
-  const GLsizei* offsets = GetSharedMemoryAs<const GLsizei*>(
-      c.offsets_shm_id, c.offsets_shm_offset, offsets_size);
-  const GLsizei* instance_counts = GetSharedMemoryAs<const GLsizei*>(
-      c.instance_counts_shm_id, c.instance_counts_shm_offset,
-      instance_counts_size);
-  if (counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (offsets == nullptr) {
-    return error::kOutOfBounds;
-  }
-  if (instance_counts == nullptr) {
-    return error::kOutOfBounds;
-  }
-  // The do-er for this function calls the ANGLE implementation which
-  // requires an array of pointers, not 32-bit integers
-  std::vector<const GLvoid*> indices(drawcount);
-  for (GLsizei draw_id = 0; draw_id < drawcount; ++draw_id) {
-    indices[draw_id] =
-        reinterpret_cast<GLvoid*>(static_cast<GLintptr>(offsets[draw_id]));
-  }
-  // Copy these arrays out of shared memory because it is possible
-  // for the shared memory to be modified after validation but
-  // before drawing.
-  std::vector<GLsizei> counts_copy(counts, counts + drawcount);
-  std::vector<GLsizei> instance_counts_copy(instance_counts,
-                                            instance_counts + drawcount);
-  return DoMultiDrawElementsInstancedWEBGL(
-      mode, counts_copy.data(), type, indices.data(),
-      instance_counts_copy.data(), drawcount);
-}
-
 error::Error GLES2DecoderPassthroughImpl::HandleVertexAttribDivisorANGLE(
     uint32_t immediate_data_size,
     const volatile void* cmd_data) {
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2.cc
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2.cc
@@ -836,6 +836,12 @@ void GLES2DecoderTestBase::SpecializedSe
 };
 
 template <>
+void GLES2DecoderTestBase::SpecializedSetup<
+    cmds::UniformMatrix2x3fvImmediate, 0>(bool /* valid */) {
+  SetupShaderForUniform(GL_FLOAT_MAT2x3);
+};
+
+template <>
 void GLES2DecoderTestBase::SpecializedSetup<cmds::TexParameterf, 0>(
     bool /* valid */) {
   DoBindTexture(GL_TEXTURE_2D, client_texture_id_, kServiceTextureId);
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2_autogen.h
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_2_autogen.h
@@ -1340,4 +1340,17 @@ TEST_P(GLES2DecoderTest2, Uniform4ivImme
   EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(temp)));
   EXPECT_EQ(GL_NO_ERROR, GetGLError());
 }
+
+TEST_P(GLES3DecoderTest2, UniformMatrix2x3fvImmediateValidArgs) {
+  cmds::UniformMatrix2x3fvImmediate& cmd =
+      *GetImmediateAs<cmds::UniformMatrix2x3fvImmediate>();
+  SpecializedSetup<cmds::UniformMatrix2x3fvImmediate, 0>(true);
+  GLfloat temp[6 * 2] = {
+      0,
+  };
+  EXPECT_CALL(*gl_, UniformMatrix2x3fv(1, 2, true, PointsToArray(temp, 6)));
+  cmd.Init(1, 2, true, &temp[0]);
+  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(temp)));
+  EXPECT_EQ(GL_NO_ERROR, GetGLError());
+}
 #endif  // GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_DECODER_UNITTEST_2_AUTOGEN_H_
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3.cc
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3.cc
@@ -65,12 +65,6 @@ void GLES2DecoderTestBase::SpecializedSe
 };
 
 template <>
-void GLES2DecoderTestBase::SpecializedSetup<UniformMatrix2x3fvImmediate, 0>(
-    bool /* valid */) {
-  SetupShaderForUniform(GL_FLOAT_MAT2x3);
-};
-
-template <>
 void GLES2DecoderTestBase::SpecializedSetup<
     UniformMatrix2x4fvImmediate, 0>(bool /* valid */) {
   SetupShaderForUniform(GL_FLOAT_MAT2x4);
Index: dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3_autogen.h
===================================================================
--- dev.orig/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3_autogen.h
+++ dev/gpu/command_buffer/service/gles2_cmd_decoder_unittest_3_autogen.h
@@ -12,19 +12,6 @@
 #ifndef GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_DECODER_UNITTEST_3_AUTOGEN_H_
 #define GPU_COMMAND_BUFFER_SERVICE_GLES2_CMD_DECODER_UNITTEST_3_AUTOGEN_H_
 
-TEST_P(GLES3DecoderTest3, UniformMatrix2x3fvImmediateValidArgs) {
-  cmds::UniformMatrix2x3fvImmediate& cmd =
-      *GetImmediateAs<cmds::UniformMatrix2x3fvImmediate>();
-  SpecializedSetup<cmds::UniformMatrix2x3fvImmediate, 0>(true);
-  GLfloat temp[6 * 2] = {
-      0,
-  };
-  EXPECT_CALL(*gl_, UniformMatrix2x3fv(1, 2, true, PointsToArray(temp, 6)));
-  cmd.Init(1, 2, true, &temp[0]);
-  EXPECT_EQ(error::kNoError, ExecuteImmediateCmd(cmd, sizeof(temp)));
-  EXPECT_EQ(GL_NO_ERROR, GetGLError());
-}
-
 TEST_P(GLES3DecoderTest3, UniformMatrix2x4fvImmediateValidArgs) {
   cmds::UniformMatrix2x4fvImmediate& cmd =
       *GetImmediateAs<cmds::UniformMatrix2x4fvImmediate>();
