Index: dev.trusty/src/chrome/browser/extensions/api/module/module.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/extensions/api/module/module.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/extensions/api/module/module.cc	2014-04-16 21:32:38.325228182 -0400
@@ -7,13 +7,23 @@
 #include <string>
 
 #include "base/values.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/extension_util.h"
+#include "chrome/browser/ui/browser.h"
 #include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/extensions/manifest_url_handler.h"
 #include "extensions/browser/extension_prefs.h"
 #include "extensions/browser/extension_system.h"
 
+namespace {
+
+const char kNoCurrentWindowError[] = "No current window";
+const char kCouldNotIdentifyTab[] = "Could not find tab with specified ID";
+
+} // namespace {
+
 namespace extensions {
 
 namespace extension {
@@ -63,4 +73,36 @@
   return true;
 }
 
+bool ExtensionIsChromelessWindowFunction::RunImpl() {
+  bool is_chromeless = false;
+
+  int tab_id = -1;
+  if (!args_->GetInteger(0, &tab_id)) {
+    Browser* browser = GetCurrentBrowser();
+    if (!browser) {
+      error_ = kNoCurrentWindowError;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+  else {
+    Browser* browser = NULL;
+    if (!ExtensionTabUtil::GetTabById(tab_id,
+                                      GetProfile(),
+                                      NULL,
+                                      &browser,
+                                      NULL,
+                                      NULL,
+                                      NULL)) {
+      error_ = kCouldNotIdentifyTab;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+
+  SetResult(new base::FundamentalValue(is_chromeless));
+
+  return true;
+}
+
 }  // namespace extensions
Index: dev.trusty/src/chrome/browser/extensions/api/module/module.h
===================================================================
--- dev.trusty.orig/src/chrome/browser/extensions/api/module/module.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/extensions/api/module/module.h	2014-04-16 21:32:38.325228182 -0400
@@ -54,6 +54,18 @@
   virtual bool RunImpl() OVERRIDE;
 };
 
+class ExtensionIsChromelessWindowFunction : public ChromeSyncExtensionFunction {
+ public:
+  DECLARE_EXTENSION_FUNCTION("extension.isChromelessWindow",
+                             EXTENSION_IS_CHROMELESS_WINDOW);
+
+ protected:
+  virtual ~ExtensionIsChromelessWindowFunction() {}
+
+  // ExtensionFunction:
+  virtual bool RunImpl() OVERRIDE;
+};
+
 }  // namespace extensions
 
 #endif  // CHROME_BROWSER_EXTENSIONS_API_MODULE_MODULE_H_
Index: dev.trusty/src/extensions/browser/extension_function_histogram_value.h
===================================================================
--- dev.trusty.orig/src/extensions/browser/extension_function_histogram_value.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/extensions/browser/extension_function_histogram_value.h	2014-04-16 21:32:38.325228182 -0400
@@ -390,6 +390,7 @@
   SYSTEMINDICATOR_DISABLE,
   DELETED_SCRIPTBADGE_SETPOPUP,
   EXTENSION_ISALLOWEDFILESCHEMEACCESS,
+  EXTENSION_IS_CHROMELESS_WINDOW,
   EXPERIMENTAL_IDENTITY_LAUNCHWEBAUTHFLOW,
   FILEBROWSERPRIVATE_GETDRIVECONNECTIONSTATE,
   TABS_DETECTLANGUAGE,
Index: dev.trusty/src/chrome/browser/sessions/session_service.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/sessions/session_service.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/sessions/session_service.cc	2014-04-16 21:32:38.329228327 -0400
@@ -1585,6 +1585,7 @@
   }
   AppType app_type = browser->is_app() ? TYPE_APP : TYPE_NORMAL;
   return should_track_changes_for_browser_type(browser->type(), app_type);
+           !browser->is_chromeless_mode();
 }
 
 bool SessionService::should_track_changes_for_browser_type(Browser::Type type,
Index: dev.trusty/src/chrome/browser/ui/browser.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser.cc	2014-04-16 21:32:38.333228474 -0400
@@ -253,6 +253,7 @@
     : type(TYPE_TABBED),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       trusted_source(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -265,6 +266,7 @@
     : type(type),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       trusted_source(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -272,6 +274,16 @@
 }
 
 // static
+Browser::CreateParams Browser::CreateParams::CreateChromeless(
+    Profile * profile,
+    chrome::HostDesktopType host_desktop_type)
+{
+  CreateParams params(profile, host_desktop_type);
+  params.is_chromeless_mode = true;
+  return params;
+}
+
+// static
 Browser::CreateParams Browser::CreateParams::CreateForApp(
     const std::string& app_name,
     bool trusted_source,
@@ -335,6 +347,7 @@
       tab_strip_model_(new TabStripModel(tab_strip_model_delegate_.get(),
                                          params.profile)),
       app_name_(params.app_name),
+      is_chromeless_mode_(params.is_chromeless_mode),
       is_trusted_source_(params.trusted_source),
       cancel_download_confirmation_state_(NOT_PROMPTED),
       override_bounds_(params.initial_bounds),
@@ -533,6 +546,10 @@
   return find_bar_controller_.get() != NULL;
 }
 
+bool Browser::is_chromeless_mode () const {
+  return is_chromeless_mode_;
+}
+
 bool Browser::is_app() const {
   return !app_name_.empty();
 }
@@ -578,7 +595,7 @@
     return title;
 #endif
   // Don't append the app name to window titles on app frames and app popups
-  return is_app() ?
+  return (is_app() || is_chromeless_mode()) ?
       title :
       l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);
 }
@@ -664,7 +681,8 @@
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 #endif
 
-  if (tab_restore_service && is_type_tabbed() && tab_strip_model_->count())
+  if (tab_restore_service && is_type_tabbed() &&
+          tab_strip_model_->count() && !is_chromeless_mode())
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 
   // TODO(sky): convert session/tab restore to use notification.
@@ -2250,7 +2268,8 @@
   // Normally apps do not show a location bar.
   if (app_name() == DevToolsWindow::kDevToolsApp ||
       !CommandLine::ForCurrentProcess()->HasSwitch(
-          switches::kEnableStreamlinedHostedApps)) {
+          switches::kEnableStreamlinedHostedApps) ||
+          is_chromeless_mode()) {
     return false;
   }
 
@@ -2271,17 +2290,17 @@
 
   unsigned int features = FEATURE_INFOBAR | FEATURE_DOWNLOADSHELF;
 
-  if (is_type_tabbed())
+  if (is_type_tabbed() && !is_chromeless_mode())
     features |= FEATURE_BOOKMARKBAR;
 
   if (!hide_ui_for_fullscreen) {
-    if (!is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TITLEBAR;
 
     if (is_type_tabbed())
       features |= FEATURE_TABSTRIP;
 
-    if (is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TOOLBAR;
 
     if (ShouldShowLocationBar())
Index: dev.trusty/src/chrome/browser/ui/browser.h
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser.h	2014-04-16 21:32:38.337228621 -0400
@@ -155,6 +155,11 @@
                                      Profile* profile,
                                      chrome::HostDesktopType host_desktop_type);
 
+    // Like Create, but creates a chromeless browser.
+    static CreateParams CreateChromeless(
+        Profile * profile,
+        chrome::HostDesktopType host_desktop_type);
+
     static CreateParams CreateForDevTools(
         Profile* profile,
         chrome::HostDesktopType host_desktop_type);
@@ -171,6 +176,9 @@
     // Specifies the browser is_trusted_source_ value.
     bool trusted_source;
 
+    // If the browser instance is supposed to be a chromeless one.
+    bool is_chromeless_mode;
+
     // The bounds of the window to open.
     gfx::Rect initial_bounds;
 
@@ -451,6 +459,7 @@
   bool is_type_tabbed() const { return type_ == TYPE_TABBED; }
   bool is_type_popup() const { return type_ == TYPE_POPUP; }
 
+  bool is_chromeless_mode() const;
   bool is_app() const;
   bool is_devtools() const;
 
@@ -825,6 +834,8 @@
   // 2) we launch an undocked devtool window.
   std::string app_name_;
 
+   bool is_chromeless_mode_;
+
   // True if the source is trusted (i.e. we do not need to show the URL in a
   // a popup window). Also used to determine which app windows to save and
   // restore on Chrome OS.
Index: dev.trusty/src/chrome/browser/ui/browser_command_controller.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser_command_controller.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser_command_controller.cc	2014-04-16 21:32:38.337228621 -0400
@@ -876,7 +876,8 @@
 
 bool BrowserCommandController::IsShowingMainUI() {
   bool should_hide_ui = window() && window()->ShouldHideUIForFullscreen();
-  return browser_->is_type_tabbed() && !should_hide_ui;
+  return browser_->is_type_tabbed() && !should_hide_ui &&
+      !browser_->is_chromeless_mode();
 }
 
 void BrowserCommandController::InitCommandState() {
@@ -891,9 +892,11 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_WINDOW, true);
-  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB,
+                                        !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
+                                        !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB, false);
 #if defined(OS_WIN) && defined(USE_ASH)
   if (browser_->host_desktop_type() != chrome::HOST_DESKTOP_TYPE_ASH)
@@ -967,20 +970,23 @@
   command_updater_.UpdateCommandEnabled(IDC_ZOOM_MINUS, true);
 
   // Show various bits of UI
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_CREATE_SHORTCUTS, false);
   UpdateCommandsForDevTools();
   command_updater_.UpdateCommandEnabled(IDC_TASK_MANAGER, CanOpenTaskManager());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_HISTORY,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_KEYBOARD, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_MENU, true);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARKS_MENU,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_RECENT_TABS_MENU,
                                         !profile()->IsGuestSession() &&
-                                        !profile()->IsOffTheRecord());
+                                        !profile()->IsOffTheRecord() &&
+                                        !browser_->is_chromeless_mode());
 #if defined(OS_CHROMEOS)
   command_updater_.UpdateCommandEnabled(IDC_TAKE_SCREENSHOT, true);
 #endif
@@ -995,7 +1001,8 @@
       IDC_HOME,
       normal_window || (CommandLine::ForCurrentProcess()->HasSwitch(
                             switches::kEnableStreamlinedHostedApps) &&
-                        browser_->is_app()));
+                        browser_->is_app()) &&
+                        !browser_->is_chromeless_mode());
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_SELECT_NEXT_TAB, normal_window);
@@ -1028,7 +1035,9 @@
 #endif
 
   // Show various bits of UI
-  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA,
+                                        normal_window &&
+                                            !browser_->is_chromeless_mode());
 
   // The upgrade entry and the view incompatibility entry should always be
   // enabled. Whether they are visible is a separate matter determined on menu
@@ -1052,15 +1061,18 @@
 // static
 void BrowserCommandController::UpdateSharedCommandsForIncognitoAvailability(
     CommandUpdater* command_updater,
-    Profile* profile) {
+    Profile* profile,
+    bool started_in_chromeless) {
   IncognitoModePrefs::Availability incognito_availability =
       IncognitoModePrefs::GetAvailability(profile->GetPrefs());
   command_updater->UpdateCommandEnabled(
       IDC_NEW_WINDOW,
-      incognito_availability != IncognitoModePrefs::FORCED);
+      incognito_availability != IncognitoModePrefs::FORCED &&
+      !started_in_chromeless);
   command_updater->UpdateCommandEnabled(
       IDC_NEW_INCOGNITO_WINDOW,
-      incognito_availability != IncognitoModePrefs::DISABLED);
+      incognito_availability != IncognitoModePrefs::DISABLED &&
+      !started_in_chromeless);
 
   // Bookmark manager and settings page/subpages are forced to open in normal
   // mode. For this reason we disable these commands when incognito is forced.
@@ -1069,7 +1081,8 @@
       !profile->IsGuestSession();
   command_updater->UpdateCommandEnabled(
       IDC_SHOW_BOOKMARK_MANAGER,
-      browser_defaults::bookmarks_enabled && command_enabled);
+      browser_defaults::bookmarks_enabled && command_enabled &&
+      !started_in_chromeless);
   ExtensionService* extension_service = profile->GetExtensionService();
   bool enable_extensions =
       extension_service && extension_service->extensions_enabled();
@@ -1082,7 +1095,10 @@
 }
 
 void BrowserCommandController::UpdateCommandsForIncognitoAvailability() {
-  UpdateSharedCommandsForIncognitoAvailability(&command_updater_, profile());
+  UpdateSharedCommandsForIncognitoAvailability(
+      &command_updater_,
+      profile(),
+      browser_->is_chromeless_mode());
 
   if (!IsShowingMainUI()) {
     command_updater_.UpdateCommandEnabled(IDC_IMPORT_SETTINGS, false);
@@ -1107,17 +1123,20 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
-      !browser_->is_app() && CanDuplicateTab(browser_));
+      !browser_->is_chromeless_mode() && !browser_->is_app()
+          && CanDuplicateTab(browser_));
 
   // Page-related commands
   window()->SetStarredState(
       BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());
   window()->ZoomChangedForActiveTab(false);
   command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,
-                                        CanViewSource(browser_));
+                                        CanViewSource(browser_)
+                                            && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,
-                                        CanEmailPageLocation(browser_));
-  if (browser_->is_devtools())
+                                        CanEmailPageLocation(browser_)
+                                            && !browser_->is_chromeless_mode());
+  if (browser_->is_devtools() && browser_->is_chromeless_mode())
     command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);
 
   // Changing the encoding is not possible on Chrome-internal webpages.
@@ -1133,9 +1152,11 @@
 #if !defined(OS_MACOSX)
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_SHORTCUTS,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+          && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_CREATE_HOSTED_APP,
-                                        CanCreateBookmarkApp(browser_));
+                                        CanCreateBookmarkApp(browser_)
+                                            && !browser_->is_chromeless_mode());
 #endif
 
   command_updater_.UpdateCommandEnabled(
@@ -1176,24 +1197,38 @@
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkEditing() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+        || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_PAGE,
-                                        CanBookmarkCurrentPage(browser_));
+                                        CanBookmarkCurrentPage(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_ALL_TABS,
-                                        CanBookmarkAllTabs(browser_));
+                                        CanBookmarkAllTabs(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_PIN_TO_START_SCREEN,
-                                        true);
+                                        !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkBar() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_BAR,
       browser_defaults::bookmarks_enabled &&
       !profile()->GetPrefs()->IsManagedPreference(prefs::kShowBookmarkBar) &&
-      IsShowingMainUI());
+      IsShowingMainUI() && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFileSelectionDialogs() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   UpdateSaveAsState();
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFullscreenMode() {
@@ -1322,13 +1357,14 @@
 
 // static
 void BrowserCommandController::UpdateOpenFileState(
-    CommandUpdater* command_updater) {
+      CommandUpdater* command_updater, bool started_in_chromeless) {
   bool enabled = true;
   PrefService* local_state = g_browser_process->local_state();
   if (local_state)
     enabled = local_state->GetBoolean(prefs::kAllowFileSelectionDialogs);
 
-  command_updater->UpdateCommandEnabled(IDC_OPEN_FILE, enabled);
+  command_updater->UpdateCommandEnabled(IDC_OPEN_FILE,
+                                        enabled && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateReloadStopState(bool is_loading,
Index: dev.trusty/src/chrome/browser/ui/browser_command_controller.h
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser_command_controller.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser_command_controller.h	2014-04-16 21:32:38.341228767 -0400
@@ -68,13 +68,15 @@
   // outside code.
 
   // Updates the open-file state.
-  static void UpdateOpenFileState(CommandUpdater* command_updater);
+  static void UpdateOpenFileState(CommandUpdater* command_updater,
+                                  bool started_in_chromeless);
 
   // Update commands whose state depends on incognito mode availability and that
   // only depend on the profile.
   static void UpdateSharedCommandsForIncognitoAvailability(
       CommandUpdater* command_updater,
-      Profile* profile);
+      Profile* profile,
+      bool started_in_chromeless);
 
  private:
   class InterstitialObserver;
Index: dev.trusty/src/chrome/browser/ui/browser_commands.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser_commands.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser_commands.cc	2014-04-16 21:32:38.341228767 -0400
@@ -553,6 +553,9 @@
 }
 
 void NewTab(Browser* browser) {
+  if (browser && browser->is_chromeless_mode())
+    return;
+
   content::RecordAction(UserMetricsAction("NewTab"));
   // TODO(asvitkine): This is invoked programmatically from several places.
   // Audit the code and change it so that the histogram only gets collected for
@@ -586,7 +589,7 @@
   content::RecordAction(UserMetricsAction("RestoreTab"));
   TabRestoreService* service =
       TabRestoreServiceFactory::GetForProfile(browser->profile());
-  if (service)
+  if (service && !browser->is_chromeless_mode())
     service->RestoreMostRecentEntry(browser->tab_restore_service_delegate(),
                                     browser->host_desktop_type());
 }
Index: dev.trusty/src/chrome/browser/ui/browser_finder.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/browser_finder.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/browser_finder.cc	2014-04-16 21:32:38.341228767 -0400
@@ -24,6 +24,7 @@
 const int kMatchOriginalProfile         = 1 << 0;
 const int kMatchCanSupportWindowFeature = 1 << 1;
 const int kMatchTabbed                  = 1 << 2;
+const int kMatchNonChromeless           = 1 << 3;
 
 // Returns true if the specified |browser| matches the specified arguments.
 // |match_types| is a bitmask dictating what parameters to match:
@@ -51,7 +52,11 @@
   }
 
   if (match_types & kMatchTabbed)
-    return browser->is_type_tabbed();
+    return browser->is_type_tabbed() &&
+      !browser->is_chromeless_mode();
+
+  if (match_types & kMatchNonChromeless)
+    return !browser->is_chromeless_mode();
 
   return true;
 }
@@ -79,7 +84,7 @@
   BrowserList* browser_list_impl = BrowserList::GetInstance(desktop_type);
   if (!browser_list_impl)
     return NULL;
-  uint32 match_types = kMatchAny;
+  uint32 match_types = kMatchNonChromeless;
   if (match_tabbed)
     match_types |= kMatchTabbed;
   if (match_original_profiles)
Index: dev.trusty/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2014-04-16 21:32:38.345228914 -0400
@@ -384,6 +384,12 @@
   } else {
     RecordLaunchModeHistogram(urls_to_open.empty() ?
                               LM_TO_BE_DECIDED : LM_WITH_URLS);
+    
+    if (IsChromelessLaunch(NULL)) {
+      // Open user-specified URLs like pinned tabs and startup tabs.
+      if (ProcessSpecifiedURLs(urls_to_open, desktop_type))
+	return true;
+    }
 
     ProcessLaunchURLs(process_startup, urls_to_open, desktop_type);
 
@@ -413,6 +419,16 @@
   return true;
 }
 
+bool StartupBrowserCreatorImpl::IsChromelessLaunch(std::string* url)
+{
+  if (command_line_.HasSwitch(switches::kChromeless)) {
+    if (url)
+      *url = command_line_.GetSwitchValueASCII(switches::kChromeless);
+    return true;
+  }
+  return false;
+}
+
 bool StartupBrowserCreatorImpl::IsAppLaunch(std::string* app_url,
                                             std::string* app_id) {
   if (command_line_.HasSwitch(switches::kApp)) {
@@ -700,7 +716,8 @@
   // mode. Also, no pages should be opened automatically if the session
   // crashed. Otherwise it might trigger another crash, locking the user out of
   // chrome. The crash infobar is shown in this case.
-  if (!IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
+  if (!IsChromelessLaunch(NULL) &&
+      !IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
                                                  profile_->GetPrefs()) &&
       !HasPendingUncleanExit(profile_)) {
     tabs = PinnedTabCodec::ReadPinnedTabs(profile_);
@@ -779,6 +796,10 @@
   if (!profile_ && browser)
     profile_ = browser->profile();
 
+  if (IsChromelessLaunch(NULL)) {
+    browser = new Browser(Browser::CreateParams::CreateChromeless(profile_, chrome::HOST_DESKTOP_TYPE_NATIVE));
+  }
+
   if (!browser || !browser->is_type_tabbed()) {
     browser = new Browser(Browser::CreateParams(profile_, desktop_type));
   } else {
@@ -855,6 +876,11 @@
   if (!browser || !profile_ || browser->tab_strip_model()->count() == 0)
     return;
 
+  // We consider that being in a chromeless launch, we are to minimize
+  // as much as possible the most obvious "classic" Chromium behavior.
+  if (IsChromelessLaunch(NULL))
+      return;
+
   if (HasPendingUncleanExit(browser->profile()))
     SessionCrashedInfoBarDelegate::Create(browser);
 
Index: dev.trusty/src/chrome/browser/ui/startup/startup_browser_creator_impl.h
===================================================================
--- dev.trusty.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2014-04-16 21:32:38.345228914 -0400
@@ -79,6 +79,11 @@
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, RestorePinnedTabs);
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, AppIdSwitch);
 
+  // If the process was launched with the chromeless command line flag,
+  // e.g. --chromeless=http://www.google.com/ return true.
+  // In this case |url| is populated if they're non-null.
+  bool IsChromelessLaunch(std::string* url);
+
   // If the process was launched with the web application command line flags,
   // e.g. --app=http://www.google.com/ or --app_id=... return true.
   // In this case |app_url| or |app_id| are populated if they're non-null.
Index: dev.trusty/src/chrome/common/chrome_switches.cc
===================================================================
--- dev.trusty.orig/src/chrome/common/chrome_switches.cc	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/common/chrome_switches.cc	2014-04-16 21:32:38.345228914 -0400
@@ -150,6 +150,9 @@
 const char kCheckCloudPrintConnectorPolicy[] =
     "check-cloud-print-connector-policy";
 
+// Specifies a given URL to be opened in a chromeless mode.
+const char kChromeless[]                    = "chromeless";
+
 // Comma-separated list of SSL cipher suites to disable.
 const char kCipherSuiteBlacklist[]          = "cipher-suite-blacklist";
 
Index: dev.trusty/src/chrome/common/chrome_switches.h
===================================================================
--- dev.trusty.orig/src/chrome/common/chrome_switches.h	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/common/chrome_switches.h	2014-04-16 21:32:38.345228914 -0400
@@ -56,6 +56,7 @@
 extern const char kCertificateTransparencyLog[];
 extern const char kCheckForUpdateIntervalSec[];
 extern const char kCheckCloudPrintConnectorPolicy[];
+extern const char kChromeless[];
 extern const char kCipherSuiteBlacklist[];
 extern const char kCloudPrintFile[];
 extern const char kCloudPrintJobTitle[];
Index: dev.trusty/src/chrome/common/extensions/api/extension.json
===================================================================
--- dev.trusty.orig/src/chrome/common/extensions/api/extension.json	2014-04-16 21:32:38.561236822 -0400
+++ dev.trusty/src/chrome/common/extensions/api/extension.json	2014-04-16 21:32:38.349229060 -0400
@@ -138,6 +138,33 @@
         }
       },
       {
+        "name": "isChromelessWindow",
+        "nocompile": true,
+        "nodoc": true,
+        "type": "function",
+        "description": "Checks is a given extension runs part of a chromeless window.",
+        "parameters": [
+          {
+            "type": "integer",
+            "name": "tabId",
+            "optional": true,
+            "description": "The tab id corresponding to the window to restrict the request to."
+          }
+          ,
+          {
+            "type": "function",
+            "name": "callback",
+            "parameters": [
+              {
+                "name": "isChromelessWindow",
+                "type": "boolean",
+                "description": "True if the extension runs part of a chromeless window, false otherwise."
+              }
+            ]
+          }
+        ]
+      },
+      {
         "name": "isAllowedIncognitoAccess",
         "type": "function",
         "description": "Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.",
