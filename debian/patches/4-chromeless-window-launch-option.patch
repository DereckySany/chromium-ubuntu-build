Index: src/src/chrome/browser/extensions/api/module/module.cc
===================================================================
--- src.orig/src/chrome/browser/extensions/api/module/module.cc	2013-03-06 06:26:24.000000000 -0600
+++ src/src/chrome/browser/extensions/api/module/module.cc	2013-03-08 22:23:04.908856983 -0600
@@ -6,9 +6,28 @@
 
 #include <string>
 
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#endif
+
 #include "chrome/browser/extensions/extension_prefs.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/ui/browser.h"
 #include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_switches.h"
+
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+
+namespace {
+
+const char kNoCurrentWindowError[] = "No current window";
+const char kCouldNotIdentifyTab[] = "Could not find tab with specified ID";
+
+} // namespace {
+
+#endif
 
 namespace extensions {
 
@@ -42,4 +61,36 @@
   return true;
 }
 
+bool IsChromelessWindowFunction::RunImpl() {
+  bool is_chromeless = false;
+
+  int tab_id = -1;
+  if (!args_->GetInteger(0, &tab_id)) {
+    Browser* browser = GetCurrentBrowser();
+    if (!browser) {
+      error_ = kNoCurrentWindowError;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+  else {
+    Browser* browser = NULL;
+    if (!ExtensionTabUtil::GetTabById(tab_id,
+                                      profile(),
+                                      NULL,
+                                      &browser,
+                                      NULL,
+                                      NULL,
+                                      NULL)) {
+      error_ = kCouldNotIdentifyTab;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+
+  SetResult(Value::CreateBooleanValue(is_chromeless));
+
+  return true;
+}
+
 }  // namespace extensions
Index: src/src/chrome/browser/extensions/api/module/module.h
===================================================================
--- src.orig/src/chrome/browser/extensions/api/module/module.h	2013-03-06 06:26:24.000000000 -0600
+++ src/src/chrome/browser/extensions/api/module/module.h	2013-03-08 22:09:55.038227381 -0600
@@ -51,6 +51,12 @@
   virtual bool RunImpl() OVERRIDE;
 };
 
+class IsChromelessWindowFunction : public SyncExtensionFunction {
+ protected:
+  virtual bool RunImpl() OVERRIDE;
+  DECLARE_EXTENSION_FUNCTION("extension.isChromelessWindow",
+                              );
+};
+
 }  // namespace extensions
 
 #endif  // CHROME_BROWSER_EXTENSIONS_API_MODULE_MODULE_H__
Index: src/src/chrome/browser/extensions/extension_function_registry.cc
===================================================================
--- src.orig/src/chrome/browser/extensions/extension_function_registry.cc	2013-03-06 06:26:18.000000000 -0600
+++ src/src/chrome/browser/extensions/extension_function_registry.cc	2013-03-08 22:11:47.714024530 -0600
@@ -72,6 +72,8 @@
   RegisterFunction<extensions::GetWebGLStatusFunction>();
   RegisterFunction<extensions::GetIsLauncherEnabledFunction>();
 
+  RegisterFunction<IsChromelessWindowFunction>();
+
   // Runtime
   RegisterFunction<extensions::RuntimeGetBackgroundPageFunction>();
   RegisterFunction<extensions::RuntimeReloadFunction>();
Index: src/src/chrome/browser/ui/browser.cc
===================================================================
--- src.orig/src/chrome/browser/ui/browser.cc	2013-03-07 17:21:01.000000000 -0600
+++ src/src/chrome/browser/ui/browser.cc	2013-03-08 19:55:10.680317766 -0600
@@ -253,6 +253,7 @@
       profile(profile),
       host_desktop_type(host_desktop_type),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
@@ -265,6 +266,7 @@
       profile(profile),
       host_desktop_type(host_desktop_type),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
@@ -289,6 +291,14 @@
 }
 
 // static
+Browser::CreateParams Browser::CreateParams::CreateChromeless(Profile * profile)
+{
+  CreateParams params(profile);
+  params.is_chromeless_mode = true;
+  return params;
+}
+
+// static
 Browser::CreateParams Browser::CreateParams::CreateForDevTools(
     Profile* profile,
     chrome::HostDesktopType host_desktop_type) {
@@ -336,6 +346,7 @@
       tab_strip_model_(new TabStripModel(tab_strip_model_delegate_.get(),
                                          params.profile)),
       app_name_(params.app_name),
+      is_chromeless_mode_(params.is_chromeless_mode),
       app_type_(params.app_type),
       chrome_updater_factory_(this),
       cancel_download_confirmation_state_(NOT_PROMPTED),
@@ -534,6 +545,10 @@
   return find_bar_controller_.get() != NULL;
 }
 
+bool Browser::is_chromeless_mode () const {
+  return is_chromeless_mode_;
+}
+
 bool Browser::is_app() const {
   return !app_name_.empty();
 }
@@ -579,7 +594,7 @@
     return title;
 #endif
   // Don't append the app name to window titles on app frames and app popups
-  return is_app() ?
+  return is_app() || is_chromeless_mode() ?
       title :
       l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);
 }
@@ -639,7 +654,7 @@
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 #endif
 
-  if (tab_restore_service && is_type_tabbed() && tab_strip_model_->count())
+  if (tab_restore_service && is_type_tabbed() && !is_chromeless_mode() && tab_strip_model_->count())
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 
   // TODO(sky): convert session/tab restore to use notification.
@@ -2099,20 +2114,20 @@
 
   unsigned int features = FEATURE_INFOBAR | FEATURE_DOWNLOADSHELF;
 
-  if (is_type_tabbed())
+  if (is_type_tabbed() && !is_chromeless_mode())
     features |= FEATURE_BOOKMARKBAR;
 
   if (!hide_ui_for_fullscreen) {
-    if (!is_type_tabbed())
+    if (!is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TITLEBAR;
 
     if (is_type_tabbed())
       features |= FEATURE_TABSTRIP;
 
-    if (is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TOOLBAR;
 
-    if (!is_app())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_LOCATIONBAR;
   }
   return !!(features & feature);
Index: src/src/chrome/browser/ui/browser.h
===================================================================
--- src.orig/src/chrome/browser/ui/browser.h	2013-03-07 17:21:01.000000000 -0600
+++ src/src/chrome/browser/ui/browser.h	2013-03-08 21:49:11.880533825 -0600
@@ -163,6 +163,9 @@
                                      Profile* profile,
                                      chrome::HostDesktopType host_desktop_type);
 
+    // Like Create, but creates a chromeless browser.
+    static CreateParams CreateChromeless(Profile * profile);
+
     static CreateParams CreateForDevTools(
         Profile* profile,
         chrome::HostDesktopType host_desktop_type);
@@ -185,6 +188,9 @@
     // Type of app (host or child). See description of AppType.
     AppType app_type;
 
+    // If the browser instance is supposed to be a chromeless one.
+    bool is_chromeless_mode;
+
     // The bounds of the window to open.
     gfx::Rect initial_bounds;
 
@@ -441,6 +447,7 @@
   bool is_type_popup() const { return type_ == TYPE_POPUP; }
   bool is_type_panel() const { return type_ == TYPE_PANEL; }
 
+  bool is_chromeless_mode() const;
   bool is_app() const;
   bool is_devtools() const;
 
@@ -822,6 +829,8 @@
   // Type of app (host or child). See description of AppType.
   AppType app_type_;
 
+  bool is_chromeless_mode_;
+
   // Unique identifier of this browser for session restore. This id is only
   // unique within the current session, and is not guaranteed to be unique
   // across sessions.
Index: src/src/chrome/browser/ui/browser_command_controller.cc
===================================================================
--- src.orig/src/chrome/browser/ui/browser_command_controller.cc	2013-03-06 06:27:39.000000000 -0600
+++ src/src/chrome/browser/ui/browser_command_controller.cc	2013-03-08 20:48:54.094031624 -0600
@@ -27,6 +27,7 @@
 #include "chrome/browser/ui/tabs/tab_strip_model_utils.h"
 #include "chrome/browser/ui/webui/sync_promo/sync_promo_ui.h"
 #include "chrome/common/chrome_notification_types.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/common/profiling.h"
 #include "content/public/browser/native_web_keyboard_event.h"
@@ -812,6 +813,9 @@
   // (like Back & Forward with initial page load) must have their state
   // initialized here, otherwise they will be forever disabled.
 
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless);
+
   // Navigation commands
   command_updater_.UpdateCommandEnabled(IDC_RELOAD, true);
   command_updater_.UpdateCommandEnabled(IDC_RELOAD_IGNORING_CACHE, true);
@@ -819,10 +823,12 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_WINDOW, true);
-  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB, false);
+  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
+                                        !started_in_chromeless);
+  command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB,
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_EXIT, true);
   command_updater_.UpdateCommandEnabled(IDC_DEBUG_FRAME_TOGGLE, true);
 #if defined(OS_WIN) && defined(USE_ASH) && !defined(NDEBUG)
@@ -884,15 +890,18 @@
   UpdateCommandsForDevTools();
   command_updater_.UpdateCommandEnabled(IDC_TASK_MANAGER, CanOpenTaskManager());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_HISTORY,
-                                        !profile()->IsGuestSession());
-  command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS, true);
+                                        !profile()->IsGuestSession() && !started_in_chromeless);
+  command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS,
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_KEYBOARD, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_MENU, true);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARKS_MENU,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_RECENT_TABS_MENU,
                                         !profile()->IsGuestSession() &&
-                                        !profile()->IsOffTheRecord());
+                                        !profile()->IsOffTheRecord() &&
+                                        !started_in_chromeless);
 
   UpdateShowSyncState(true);
 
@@ -900,7 +909,9 @@
   bool normal_window = browser_->is_type_tabbed();
 
   // Navigation commands
-  command_updater_.UpdateCommandEnabled(IDC_HOME, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_HOME,
+                                        normal_window
+                                          && !started_in_chromeless);
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_SELECT_NEXT_TAB, normal_window);
@@ -928,7 +939,9 @@
   command_updater_.UpdateCommandEnabled(IDC_TABPOSE, normal_window);
 
   // Show various bits of UI
-  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA,
+                                        normal_window
+                                          && !started_in_chromeless);
 
   // The upgrade entry and the view incompatibility entry should always be
   // enabled. Whether they are visible is a separate matter determined on menu
@@ -938,7 +951,8 @@
 
   // View Background Pages entry is always enabled, but is hidden if there are
   // no background pages.
-  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES, true);
+  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES,
+                                        !started_in_chromeless);
 
   // Toggle speech input
   command_updater_.UpdateCommandEnabled(IDC_TOGGLE_SPEECH_INPUT, true);
@@ -957,19 +971,25 @@
 void BrowserCommandController::UpdateSharedCommandsForIncognitoAvailability(
     CommandUpdater* command_updater,
     Profile* profile) {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
   IncognitoModePrefs::Availability incognito_availability =
       IncognitoModePrefs::GetAvailability(profile->GetPrefs());
   command_updater->UpdateCommandEnabled(
       IDC_NEW_WINDOW,
-      incognito_availability != IncognitoModePrefs::FORCED);
+      incognito_availability != IncognitoModePrefs::FORCED
+        && !started_in_chromeless);
   command_updater->UpdateCommandEnabled(
       IDC_NEW_INCOGNITO_WINDOW,
-      incognito_availability != IncognitoModePrefs::DISABLED);
+      incognito_availability != IncognitoModePrefs::DISABLED
+        && !started_in_chromeless);
 
   // Bookmark manager and settings page/subpages are forced to open in normal
   // mode. For this reason we disable these commands when incognito is forced.
   const bool command_enabled =
-      incognito_availability != IncognitoModePrefs::FORCED;
+      incognito_availability != IncognitoModePrefs::FORCED
+      && !started_in_chromeless;
   command_updater->UpdateCommandEnabled(
       IDC_SHOW_BOOKMARK_MANAGER,
       browser_defaults::bookmarks_enabled && command_enabled);
@@ -1009,17 +1029,20 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
-      !browser_->is_app() && CanDuplicateTab(browser_));
+      !browser_->is_chromeless_mode() && !browser_->is_app()
+        && CanDuplicateTab(browser_));
 
   // Page-related commands
   window()->SetStarredState(
       BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());
   window()->ZoomChangedForActiveTab(false);
   command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,
-                                        CanViewSource(browser_));
+                                        CanViewSource(browser_)
+                                          && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,
-                                        CanEmailPageLocation(browser_));
-  if (browser_->is_devtools())
+                                        CanEmailPageLocation(browser_)
+                                          && !browser_->is_chromeless_mode());
+  if (browser_->is_devtools() && browser_->is_chromeless_mode())
     command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);
 
   // Changing the encoding is not possible on Chrome-internal webpages.
@@ -1035,7 +1058,8 @@
 #if !defined(OS_MACOSX)
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_SHORTCUTS,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+        && !browser_->is_chromeless_mode());
 #endif
 
   command_updater_.UpdateCommandEnabled(
@@ -1074,19 +1098,29 @@
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkEditing() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_PAGE,
-                                        CanBookmarkCurrentPage(browser_));
+                                        CanBookmarkCurrentPage(browser_)
+                                          && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_ALL_TABS,
-                                        CanBookmarkAllTabs(browser_));
+                                        CanBookmarkAllTabs(browser_)
+                                          && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_PIN_TO_START_SCREEN,
-                                        true);
+                                          !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkBar() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_BAR,
       browser_defaults::bookmarks_enabled &&
       !profile()->GetPrefs()->IsManagedPreference(prefs::kShowBookmarkBar) &&
-      IsShowingMainUI());
+      IsShowingMainUI() && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFileSelectionDialogs() {
@@ -1145,7 +1179,7 @@
   // Disable explicit fullscreen toggling for app-panels and when in metro snap
   // mode.
   bool fullscreen_enabled =
-      !(browser_->is_type_panel() && browser_->is_app()) &&
+      !(browser_->is_type_panel() && browser_->is_app() && started_in_chromeless) &&
       fullscreen_mode != FULLSCREEN_METRO_SNAP;
 #if defined(OS_MACOSX)
   // The Mac implementation doesn't support switching to fullscreen while
@@ -1209,7 +1243,12 @@
   if (local_state)
     enabled = local_state->GetBoolean(prefs::kAllowFileSelectionDialogs);
 
-  command_updater->UpdateCommandEnabled(IDC_OPEN_FILE, enabled);
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
+  command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE,
+                                        enabled && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateReloadStopState(bool is_loading,
Index: src/src/chrome/browser/ui/browser_commands.cc
===================================================================
--- src.orig/src/chrome/browser/ui/browser_commands.cc	2013-03-06 06:27:12.000000000 -0600
+++ src/src/chrome/browser/ui/browser_commands.cc	2013-03-08 20:00:22.043386772 -0600
@@ -454,6 +454,10 @@
 
 void NewTab(Browser* browser) {
   content::RecordAction(UserMetricsAction("NewTab"));
+
+  if (browser->is_chromeless_mode())
+    return;
+
   // TODO(asvitkine): This is invoked programmatically from several places.
   // Audit the code and change it so that the histogram only gets collected for
   // user-initiated commands.
Index: src/src/chrome/browser/ui/gtk/browser_window_gtk.cc
===================================================================
--- src.orig/src/chrome/browser/ui/gtk/browser_window_gtk.cc	2013-03-07 17:21:01.000000000 -0600
+++ src/src/chrome/browser/ui/gtk/browser_window_gtk.cc	2013-03-08 19:46:27.549891930 -0600
@@ -301,6 +301,9 @@
     gtk_window_util::SetWindowCustomClass(window_,
         std::string(gdk_get_program_class()) + " (" + user_data_dir + ")");
   }
+  else if (browser_->is_chromeless_mode()) {
+    SetWindowCustomClass(window_, web_app::GetWMClassFromAppName("chromeless"));
+  }
 
   // For popups, we initialize widgets then set the window geometry, because
   // popups need the widgets inited before they can set the window size
@@ -889,7 +892,7 @@
 }
 
 void BrowserWindowGtk::SetFocusToLocationBar(bool select_all) {
-  if (!IsFullscreen())
+  if (!IsFullscreen() && IsToolbarSupported())
     GetLocationBar()->FocusLocation(select_all);
 }
 
@@ -2210,7 +2213,7 @@
 
 bool BrowserWindowGtk::UseCustomFrame() const {
   // We don't use the custom frame for app mode windows or app window popups.
-  return use_custom_frame_pref_.GetValue() && !browser_->is_app();
+  return use_custom_frame_pref_.GetValue() && !browser_->is_app() && !browser_->is_chromeless_mode();
 }
 
 void BrowserWindowGtk::PlaceBookmarkBar(bool is_floating) {
Index: src/src/chrome/browser/ui/gtk/global_menu_bar.cc
===================================================================
--- src.orig/src/chrome/browser/ui/gtk/global_menu_bar.cc	2013-03-06 06:27:16.000000000 -0600
+++ src/src/chrome/browser/ui/gtk/global_menu_bar.cc	2013-03-08 19:44:35.786002878 -0600
@@ -25,35 +25,44 @@
 #include "ui/base/gtk/menu_label_accelerator_util.h"
 #include "ui/base/l10n/l10n_util.h"
 
+typedef bool (*GlobalMenuBarVisibilityHandler) (Browser * browser);
+
 struct GlobalMenuBarCommand {
   int str_id;
   int command;
   int tag;
+  GlobalMenuBarVisibilityHandler visibility_handler;
 };
 
 namespace {
 
+// static
+static bool GlobalMenuBarVisibilityHandler_NotInChromelessMode(
+    Browser * browser) {
+  return browser && !browser->is_chromeless_mode();
+}
+
 const int MENU_SEPARATOR =-1;
 const int MENU_END = -2;
 const int MENU_DISABLED_LABEL = -3;
 
 GlobalMenuBarCommand file_menu[] = {
-  { IDS_NEW_TAB, IDC_NEW_TAB },
-  { IDS_NEW_WINDOW, IDC_NEW_WINDOW },
-  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW },
-  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB },
-  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE },
-  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION },
+  { IDS_NEW_TAB, IDC_NEW_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_WINDOW, IDC_NEW_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS },
+  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_CLOSE_WINDOW_LINUX, IDC_CLOSE_WINDOW },
   { IDS_CLOSE_TAB_LINUX, IDC_CLOSE_TAB },
-  { IDS_SAVE_PAGE, IDC_SAVE_PAGE },
+  { IDS_SAVE_PAGE, IDC_SAVE_PAGE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_SEPARATOR, MENU_SEPARATOR },
 
@@ -71,17 +80,17 @@
 
   { IDS_FIND, IDC_FIND },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_PREFERENCES, IDC_OPTIONS },
+  { IDS_PREFERENCES, IDC_OPTIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand view_menu[] = {
-  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR },
+  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_STOP_MENU_LINUX, IDC_STOP },
   { IDS_RELOAD_MENU_LINUX, IDC_RELOAD },
@@ -97,48 +106,48 @@
 };
 
 GlobalMenuBarCommand history_menu[] = {
-  { IDS_HISTORY_HOME_LINUX, IDC_HOME },
-  { IDS_HISTORY_BACK_LINUX, IDC_BACK },
-  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD },
+  { IDS_HISTORY_HOME_LINUX, IDC_HOME, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_BACK_LINUX, IDC_BACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_VISITED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_MOST_VISITED_HEADER },
+    GlobalMenuBar::TAG_MOST_VISITED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_CLOSED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER },
+    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY },
+  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand tools_menu[] = {
-  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS },
-  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY },
-  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS },
+  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_TASK_MANAGER, IDC_TASK_MANAGER },
-  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA },
+  { IDS_TASK_MANAGER, IDC_TASK_MANAGER, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE },
-  { IDS_DEV_TOOLS, IDC_DEV_TOOLS },
-  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE },
+  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS, IDC_DEV_TOOLS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand help_menu[] = {
-  { IDS_FEEDBACK, IDC_FEEDBACK },
+  { IDS_FEEDBACK, IDC_FEEDBACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
   { IDS_HELP_PAGE , IDC_HELP_PAGE_VIA_MENU },
   { MENU_END, MENU_END }
 };
@@ -191,11 +200,13 @@
   }
 
   pref_change_registrar_.Init(browser_->profile()->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kShowBookmarkBar,
-      base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
-                 base::Unretained(this)));
-  OnBookmarkBarVisibilityChanged();
+  if (! browser_->is_chromeless_mode()) {
+    pref_change_registrar_.Add(
+        prefs::kShowBookmarkBar,
+        base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
+                   base::Unretained(this)));
+    OnBookmarkBarVisibilityChanged();
+  }
 }
 
 GlobalMenuBar::~GlobalMenuBar() {
@@ -218,8 +229,22 @@
     std::map<int, GtkWidget*>* id_to_menu_item,
     GlobalMenuBarCommand* commands,
     GlobalMenuOwner* owner) {
+  // first pass to count the number of "visible" items
+  size_t count = 0;
+  for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (!commands[i].visibility_handler || commands[i].visibility_handler(browser_)) {
+      count++;
+    }
+  }
+  if (0 == count) {
+    return;
+  }
+
   GtkWidget* menu = gtk_menu_new();
   for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (commands[i].visibility_handler && !commands[i].visibility_handler(browser_)) {
+      continue;
+    }
     GtkWidget* menu_item = BuildMenuItem(
         commands[i].str_id, commands[i].command, commands[i].tag,
         id_to_menu_item, menu);
Index: src/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
===================================================================
--- src.orig/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc	2013-03-06 06:27:16.000000000 -0600
+++ src/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc	2013-03-08 19:28:28.292240956 -0600
@@ -786,9 +786,11 @@
   g_signal_connect(tabstrip_.get(), "drag-data-received",
                    G_CALLBACK(OnDragDataReceivedThunk), this);
 
-  newtab_button_.reset(MakeNewTabButton());
-  newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
-                                 newtab_button_->SurfaceHeight());
+  if (window_ && window_->browser() && ! window_->browser()->is_chromeless_mode()) {
+    newtab_button_.reset(MakeNewTabButton());
+    newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
+                                   newtab_button_->SurfaceHeight());
+  }
 
   gtk_widget_show_all(tabstrip_.get());
 
@@ -1461,6 +1463,9 @@
 
 void TabStripGtk::LayoutNewTabButton(double last_tab_right,
                                      double unselected_width) {
+  if (window_ && window_->browser() && window_->browser()->is_chromeless_mode())
+    return;
+
   GtkWidget* toplevel = gtk_widget_get_ancestor(widget(), GTK_TYPE_WINDOW);
   bool is_maximized = false;
   if (toplevel) {
@@ -1514,8 +1519,10 @@
   int available_width = tabstrip_allocation.width;
   if (available_width_for_tabs_ < 0) {
     available_width = bounds_.width();
-    available_width -=
+    if (newtab_button_.get() != NULL) {
+      available_width -=
         (kNewTabButtonHOffset + newtab_button_->WidgetAllocation().width);
+    }
   } else {
     // Interesting corner case: if |available_width_for_tabs_| > the result
     // of the calculation in the conditional arm above, the strip is in
@@ -2072,9 +2079,11 @@
   event->area.height = bounds_.height();
   gdk_region_union_with_rect(event->region, &event->area);
 
-  // Paint the New Tab button.
-  gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
-      newtab_button_->widget(), event);
+  if (newtab_button_.get() != NULL) {
+    // Paint the New Tab button.
+    gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
+                                   newtab_button_->widget(), event);
+  }
 
   // Paint the tabs in reverse order, so they stack to the left.
   TabGtk* selected_tab = NULL;
@@ -2271,6 +2280,9 @@
 }
 
 void TabStripGtk::SetNewTabButtonBackground() {
+  if (newtab_button_.get() == NULL) {
+    return;
+  }
   SkColor color = theme_service_->GetColor(
       ThemeProperties::COLOR_BUTTON_BACKGROUND);
   SkBitmap background = theme_service_->GetImageNamed(
Index: src/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc
===================================================================
--- src.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2013-03-06 06:27:27.000000000 -0600
+++ src/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2013-03-08 19:21:21.565356706 -0600
@@ -400,6 +400,16 @@
   }
 }
 
+bool StartupBrowserCreatorImpl::IsChromelessLaunch(std::string* url)
+{
+  if (command_line_.HasSwitch(switches::kChromeless)) {
+    if (url)
+      *url = command_line_.GetSwitchValueASCII(switches::kChromeless);
+    return true;
+  }
+  return false;
+}
+
 bool StartupBrowserCreatorImpl::IsAppLaunch(std::string* app_url,
                                             std::string* app_id) {
   if (command_line_.HasSwitch(switches::kApp)) {
@@ -532,6 +542,12 @@
     return;
   }
 
+  if (IsChromelessLaunch(NULL)) {
+    // Open user-specified URLs like pinned tabs and startup tabs.
+    if (ProcessSpecifiedURLs(urls_to_open))
+      return;
+  }
+
   if (process_startup && ProcessStartupURLs(urls_to_open)) {
     // ProcessStartupURLs processed the urls, nothing else to do.
     return;
@@ -677,7 +693,8 @@
   // mode. Also, no pages should be opened automatically if the session
   // crashed. Otherwise it might trigger another crash, locking the user out of
   // chrome. The crash infobar is shown in this case.
-  if (!IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
+  if (!IsChromelessLaunch(NULL) &&
+      !IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
                                                  profile_->GetPrefs()) &&
       !HasPendingUncleanExit(profile_)) {
     tabs = PinnedTabCodec::ReadPinnedTabs(profile_);
@@ -753,6 +770,10 @@
   if (!profile_ && browser)
     profile_ = browser->profile();
 
+  if (IsChromelessLaunch(NULL)) {
+    browser = new Browser(Browser::CreateParams::CreateChromeless(profile_));
+  }
+
   if (!browser || !browser->is_type_tabbed()) {
     // The startup code only executes for browsers launched in desktop mode.
     // i.e. HOST_DESKTOP_TYPE_NATIVE. Ash should never get here.
@@ -831,6 +852,12 @@
   if (!browser || !profile_ || browser->tab_strip_model()->count() == 0)
     return;
 
+  // We consider that being in a chromeless launch, we are to minimize as much as
+  // possible the most obvious "classic" Chromium behavior.
+  if (IsChromelessLaunch(NULL)) {
+    return;
+  }
+
   if (HasPendingUncleanExit(browser->profile()))
     SessionCrashedInfoBarDelegate::Create(browser);
 
Index: src/src/chrome/browser/ui/startup/startup_browser_creator_impl.h
===================================================================
--- src.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2013-03-06 06:27:27.000000000 -0600
+++ src/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2013-03-08 19:22:32.191814179 -0600
@@ -79,6 +79,11 @@
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, RestorePinnedTabs);
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, AppIdSwitch);
 
+  // If the process was launched with the chromeless command line flag,
+  // e.g. --chromeless=http://www.google.com/ return true.
+  // In this case |url| is populated if they're non-null.
+  bool IsChromelessLaunch(std::string* url);
+
   // Extracts optional application window size passed in command line.
   void ExtractOptionalAppWindowSize(gfx::Rect* bounds);
 
Index: src/src/chrome/common/chrome_switches.cc
===================================================================
--- src.orig/src/chrome/common/chrome_switches.cc	2013-03-07 17:21:08.000000000 -0600
+++ src/src/chrome/common/chrome_switches.cc	2013-03-08 22:26:14.783261996 -0600
@@ -150,6 +150,9 @@
 // Chrome Frame automation channel is closed.
 const char kChromeFrameShutdownDelay[]      = "chrome-frame-shutdown-delay";
 
+// Specifies a given URL to be opened in a chromeless mode.
+const char kChromeless[]                    = "chromeless";
+
 // Tells chrome to load the specified version of chrome.dll on Windows. If this
 // version cannot be loaded, Chrome will exit.
 const char kChromeVersion[]                 = "chrome-version";
Index: src/src/chrome/common/chrome_switches.h
===================================================================
--- src.orig/src/chrome/common/chrome_switches.h	2013-03-07 17:21:08.000000000 -0600
+++ src/src/chrome/common/chrome_switches.h	2013-03-08 22:26:33.403890193 -0600
@@ -56,6 +56,7 @@
 extern const char kCheckForUpdateIntervalSec[];
 extern const char kCheckCloudPrintConnectorPolicy[];
 extern const char kChromeFrameShutdownDelay[];
+extern const char kChromeless[];
 extern const char kChromeVersion[];
 extern const char kCipherSuiteBlacklist[];
 extern const char kClearTokenService[];
Index: src/src/chrome/common/extensions/api/extension.json
===================================================================
--- src.orig/src/chrome/common/extensions/api/extension.json	2013-03-06 06:30:52.000000000 -0600
+++ src/src/chrome/common/extensions/api/extension.json	2013-03-08 22:25:16.189285313 -0600
@@ -139,6 +139,32 @@
         }
       },
       {
+        "name": "isChromelessWindow",
+        "type": "function",
+        "unprivileged": true,
+        "description": "Checks is a given extension runs part of a chromeless window.",
+        "parameters": [
+          {
+            "type": "integer",
+            "name": "tabId",
+            "optional": true,
+            "description": "The tab id corresponding to the window to restrict the request to."
+          }
+          ,
+          {
+            "type": "function",
+            "name": "callback",
+            "parameters": [
+              {
+                "name": "isChromelessWindow",
+                "type": "boolean",
+                "description": "True if the extension runs part of a chromeless window, false otherwise."
+              }
+            ]
+          }
+        ]
+      },
+      {
         "name": "isAllowedIncognitoAccess",
         "type": "function",
         "description": "Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.",
