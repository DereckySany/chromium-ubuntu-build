Index: dev.saucy/src/chrome/browser/extensions/api/module/module.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/extensions/api/module/module.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/extensions/api/module/module.cc	2013-05-25 10:36:07.580881211 -0500
@@ -8,9 +8,28 @@
 
 #include "base/values.h"
 #include "chrome/browser/extensions/extension_prefs.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/extensions/extension_service.h"
 #include "chrome/browser/extensions/extension_system.h"
+#include "chrome/browser/ui/browser.h"
 #include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_switches.h"
+
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#endif
+
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+
+namespace {
+
+const char kNoCurrentWindowError[] = "No current window";
+const char kCouldNotIdentifyTab[] = "Could not find tab with specified ID";
+
+} // namespace {
+
+#endif
 
 namespace extensions {
 
@@ -65,4 +84,36 @@
   return true;
 }
 
+bool ExtensionIsChromelessWindowFunction::RunImpl() {
+  bool is_chromeless = false;
+
+  int tab_id = -1;
+  if (!args_->GetInteger(0, &tab_id)) {
+    Browser* browser = GetCurrentBrowser();
+    if (!browser) {
+      error_ = kNoCurrentWindowError;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+  else {
+    Browser* browser = NULL;
+    if (!ExtensionTabUtil::GetTabById(tab_id,
+                                      profile(),
+                                      NULL,
+                                      &browser,
+                                      NULL,
+                                      NULL,
+                                      NULL)) {
+      error_ = kCouldNotIdentifyTab;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+
+  SetResult(Value::CreateBooleanValue(is_chromeless));
+
+  return true;
+}
+
 }  // namespace extensions
Index: dev.saucy/src/chrome/browser/extensions/api/module/module.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/extensions/api/module/module.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/extensions/api/module/module.h	2013-05-25 10:36:07.580881211 -0500
@@ -53,6 +53,13 @@
   virtual bool RunImpl() OVERRIDE;
 };
 
+class IsChromelessWindowFunction : public SyncExtensionFunction {
+ protected:
+  virtual bool RunImpl() OVERRIDE;
+  DECLARE_EXTENSION_FUNCTION("extension.isChromelessWindow",
+                             EXTENSION_ISCHROMELESSWINDOW);
+};
+
 }  // namespace extensions
 
 #endif  // CHROME_BROWSER_EXTENSIONS_API_MODULE_MODULE_H_
Index: dev.saucy/src/chrome/browser/extensions/extension_function_histogram_value.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/extensions/extension_function_histogram_value.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/extensions/extension_function_histogram_value.h	2013-05-25 10:36:07.580881211 -0500
@@ -391,6 +391,7 @@
   SYSTEMINDICATOR_DISABLE,
   SCRIPTBADGE_SETPOPUP,
   EXTENSION_ISALLOWEDFILESCHEMEACCESS,
+  EXTENSION_ISCHROMELESSWINDOW,
   EXPERIMENTAL_IDENTITY_LAUNCHWEBAUTHFLOW,
   FILEBROWSERPRIVATE_GETDRIVECONNECTIONSTATE,
   TABS_DETECTLANGUAGE,
Index: dev.saucy/src/chrome/browser/sessions/session_service.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/sessions/session_service.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/sessions/session_service.cc	2013-05-25 10:36:07.584881351 -0500
@@ -1549,7 +1549,8 @@
 bool SessionService::ShouldTrackBrowser(Browser* browser) const {
   AppType app_type = browser->is_app() ? TYPE_APP : TYPE_NORMAL;
   return browser->profile() == profile() &&
-         should_track_changes_for_browser_type(browser->type(), app_type);
+         should_track_changes_for_browser_type(browser->type(), app_type) &&
+         !browser->is_chromeless_mode();
 }
 
 bool SessionService::should_track_changes_for_browser_type(Browser::Type type,
Index: dev.saucy/src/chrome/browser/ui/browser.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser.cc	2013-05-25 10:36:07.588881491 -0500
@@ -245,6 +245,7 @@
     : type(TYPE_TABBED),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       app_type(APP_TYPE_HOST),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -257,6 +258,7 @@
     : type(type),
       profile(profile),
       host_desktop_type(host_desktop_type),
+      is_chromeless_mode(false),
       app_type(APP_TYPE_HOST),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
@@ -264,6 +266,14 @@
 }
 
 // static
+Browser::CreateParams Browser::CreateParams::CreateChromeless(Profile * profile)
+{
+  CreateParams params(profile);
+  params.is_chromeless_mode = true;
+  return params;
+}
+
+// static
 Browser::CreateParams Browser::CreateParams::CreateForApp(
     Type type,
     const std::string& app_name,
@@ -327,6 +337,7 @@
       tab_strip_model_(new TabStripModel(tab_strip_model_delegate_.get(),
                                          params.profile)),
       app_name_(params.app_name),
+      is_chromeless_mode_(params.is_chromeless_mode),
       app_type_(params.app_type),
       chrome_updater_factory_(this),
       cancel_download_confirmation_state_(NOT_PROMPTED),
@@ -514,6 +525,10 @@
   return find_bar_controller_.get() != NULL;
 }
 
+bool Browser::is_chromeless_mode () const {
+  return is_chromeless_mode_;
+}
+
 bool Browser::is_app() const {
   return !app_name_.empty();
 }
@@ -559,7 +574,7 @@
     return title;
 #endif
   // Don't append the app name to window titles on app frames and app popups
-  return is_app() ?
+  return (is_app() || is_chromeless_mode()) ?
       title :
       l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);
 }
@@ -619,7 +634,8 @@
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 #endif
 
-  if (tab_restore_service && is_type_tabbed() && tab_strip_model_->count())
+  if (tab_restore_service && is_type_tabbed() &&
+          tab_strip_model_->count() && !is_chromeless_mode())
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 
   // TODO(sky): convert session/tab restore to use notification.
@@ -2057,20 +2073,20 @@
 
   unsigned int features = FEATURE_INFOBAR | FEATURE_DOWNLOADSHELF;
 
-  if (is_type_tabbed())
+  if (is_type_tabbed() && !is_chromeless_mode())
     features |= FEATURE_BOOKMARKBAR;
 
   if (!hide_ui_for_fullscreen) {
-    if (!is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TITLEBAR;
 
     if (is_type_tabbed())
       features |= FEATURE_TABSTRIP;
 
-    if (is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TOOLBAR;
 
-    if (!is_app())
+    if (!is_app() && !is_chromeless_mode())
       features |= FEATURE_LOCATIONBAR;
   }
   return !!(features & feature);
Index: dev.saucy/src/chrome/browser/ui/browser.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser.h	2013-05-25 10:36:07.588881491 -0500
@@ -163,6 +163,9 @@
                                      Profile* profile,
                                      chrome::HostDesktopType host_desktop_type);
 
+    // Like Create, but creates a chromeless browser.
+    static CreateParams CreateChromeless(Profile * profile);
+
     static CreateParams CreateForDevTools(
         Profile* profile,
         chrome::HostDesktopType host_desktop_type);
@@ -185,6 +188,9 @@
     // Type of app (host or child). See description of AppType.
     AppType app_type;
 
+    // If the browser instance is supposed to be a chromeless one.
+    bool is_chromeless_mode;
+
     // The bounds of the window to open.
     gfx::Rect initial_bounds;
 
@@ -435,6 +441,7 @@
   bool is_type_tabbed() const { return type_ == TYPE_TABBED; }
   bool is_type_popup() const { return type_ == TYPE_POPUP; }
 
+  bool is_chromeless_mode() const;
   bool is_app() const;
   bool is_devtools() const;
 
@@ -806,6 +813,8 @@
   // 2) we launch an undocked devtool window.
   std::string app_name_;
 
+  bool is_chromeless_mode_;
+
   // Type of app (host or child). See description of AppType.
   AppType app_type_;
 
Index: dev.saucy/src/chrome/browser/ui/browser_command_controller.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser_command_controller.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser_command_controller.cc	2013-05-25 10:36:07.596881771 -0500
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/browser_command_controller.h"
 
+#include "base/command_line.h"
 #include "base/prefs/pref_service.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/browser_process.h"
@@ -27,6 +28,7 @@
 #include "chrome/browser/ui/tabs/tab_strip_model_utils.h"
 #include "chrome/browser/ui/webui/sync_promo/sync_promo_ui.h"
 #include "chrome/common/chrome_notification_types.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/common/profiling.h"
 #include "content/public/browser/native_web_keyboard_event.h"
@@ -814,7 +816,8 @@
 
 bool BrowserCommandController::IsShowingMainUI() {
   bool should_hide_ui = window() && window()->ShouldHideUIForFullscreen();
-  return browser_->is_type_tabbed() && !should_hide_ui;
+  return browser_->is_type_tabbed() && !should_hide_ui &&
+      !browser_->is_chromeless_mode();
 }
 
 void BrowserCommandController::InitCommandState() {
@@ -822,6 +825,9 @@
   // (like Back & Forward with initial page load) must have their state
   // initialized here, otherwise they will be forever disabled.
 
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless);
+
   // Navigation commands
   command_updater_.UpdateCommandEnabled(IDC_RELOAD, true);
   command_updater_.UpdateCommandEnabled(IDC_RELOAD_IGNORING_CACHE, true);
@@ -829,9 +835,10 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_WINDOW, true);
-  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB, false);
 #if defined(OS_WIN) && defined(USE_ASH)
   if (browser_->host_desktop_type() != chrome::HOST_DESKTOP_TYPE_ASH)
@@ -894,20 +901,23 @@
   command_updater_.UpdateCommandEnabled(IDC_ZOOM_MINUS, true);
 
   // Show various bits of UI
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_CREATE_SHORTCUTS, false);
   UpdateCommandsForDevTools();
   command_updater_.UpdateCommandEnabled(IDC_TASK_MANAGER, CanOpenTaskManager());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_HISTORY,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_KEYBOARD, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_MENU, true);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARKS_MENU,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_RECENT_TABS_MENU,
                                         !profile()->IsGuestSession() &&
-                                        !profile()->IsOffTheRecord());
+                                        !profile()->IsOffTheRecord() &&
+                                        !started_in_chromeless);
 
   UpdateShowSyncState(true);
 
@@ -915,7 +925,9 @@
   bool normal_window = browser_->is_type_tabbed();
 
   // Navigation commands
-  command_updater_.UpdateCommandEnabled(IDC_HOME, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_HOME,
+                                        normal_window &&
+                                        !started_in_chromeless);
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_SELECT_NEXT_TAB, normal_window);
@@ -943,7 +955,9 @@
   command_updater_.UpdateCommandEnabled(IDC_TABPOSE, normal_window);
 
   // Show various bits of UI
-  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA,
+                                        normal_window &&
+                                            !started_in_chromeless);
 
   // The upgrade entry and the view incompatibility entry should always be
   // enabled. Whether they are visible is a separate matter determined on menu
@@ -953,7 +967,8 @@
 
   // View Background Pages entry is always enabled, but is hidden if there are
   // no background pages.
-  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES, true);
+  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES,
+                                        !started_in_chromeless);
 
   // Toggle speech input
   command_updater_.UpdateCommandEnabled(IDC_TOGGLE_SPEECH_INPUT, true);
@@ -971,15 +986,18 @@
 // static
 void BrowserCommandController::UpdateSharedCommandsForIncognitoAvailability(
     CommandUpdater* command_updater,
-    Profile* profile) {
+    Profile* profile,
+    bool started_in_chromeless) {
   IncognitoModePrefs::Availability incognito_availability =
       IncognitoModePrefs::GetAvailability(profile->GetPrefs());
   command_updater->UpdateCommandEnabled(
       IDC_NEW_WINDOW,
-      incognito_availability != IncognitoModePrefs::FORCED);
+      incognito_availability != IncognitoModePrefs::FORCED &&
+      !started_in_chromeless);
   command_updater->UpdateCommandEnabled(
       IDC_NEW_INCOGNITO_WINDOW,
-      incognito_availability != IncognitoModePrefs::DISABLED);
+      incognito_availability != IncognitoModePrefs::DISABLED &&
+      !started_in_chromeless);
 
   // Bookmark manager and settings page/subpages are forced to open in normal
   // mode. For this reason we disable these commands when incognito is forced.
@@ -987,7 +1005,8 @@
       incognito_availability != IncognitoModePrefs::FORCED;
   command_updater->UpdateCommandEnabled(
       IDC_SHOW_BOOKMARK_MANAGER,
-      browser_defaults::bookmarks_enabled && command_enabled);
+      browser_defaults::bookmarks_enabled && command_enabled &&
+      !started_in_chromeless);
   ExtensionService* extension_service = profile->GetExtensionService();
   bool enable_extensions =
       extension_service && extension_service->extensions_enabled();
@@ -999,7 +1018,10 @@
 }
 
 void BrowserCommandController::UpdateCommandsForIncognitoAvailability() {
-  UpdateSharedCommandsForIncognitoAvailability(&command_updater_, profile());
+  UpdateSharedCommandsForIncognitoAvailability(
+      &command_updater_,
+      profile(),
+      browser_->is_chromeless_mode());
 
   if (!IsShowingMainUI()) {
     command_updater_.UpdateCommandEnabled(IDC_IMPORT_SETTINGS, false);
@@ -1024,17 +1046,20 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
-      !browser_->is_app() && CanDuplicateTab(browser_));
+      !browser_->is_chromeless_mode() && !browser_->is_app()
+          && CanDuplicateTab(browser_));
 
   // Page-related commands
   window()->SetStarredState(
       BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());
   window()->ZoomChangedForActiveTab(false);
   command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,
-                                        CanViewSource(browser_));
+                                        CanViewSource(browser_)
+                                            && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,
-                                        CanEmailPageLocation(browser_));
-  if (browser_->is_devtools())
+                                        CanEmailPageLocation(browser_)
+                                            && !browser_->is_chromeless_mode());
+  if (browser_->is_devtools() && browser_->is_chromeless_mode())
     command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);
 
   // Changing the encoding is not possible on Chrome-internal webpages.
@@ -1050,7 +1075,8 @@
 #if !defined(OS_MACOSX)
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_SHORTCUTS,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+          && !browser_->is_chromeless_mode());
 #endif
 
   command_updater_.UpdateCommandEnabled(
@@ -1089,24 +1115,38 @@
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkEditing() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+        || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_PAGE,
-                                        CanBookmarkCurrentPage(browser_));
+                                        CanBookmarkCurrentPage(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_ALL_TABS,
-                                        CanBookmarkAllTabs(browser_));
+                                        CanBookmarkAllTabs(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_PIN_TO_START_SCREEN,
-                                        true);
+                                        !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkBar() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_BAR,
       browser_defaults::bookmarks_enabled &&
       !profile()->GetPrefs()->IsManagedPreference(prefs::kShowBookmarkBar) &&
-      IsShowingMainUI());
+      IsShowingMainUI() && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFileSelectionDialogs() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   UpdateSaveAsState();
-  UpdateOpenFileState(&command_updater_);
+  UpdateOpenFileState(&command_updater_, started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFullscreenMode(
Index: dev.saucy/src/chrome/browser/ui/browser_command_controller.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser_command_controller.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser_command_controller.h	2013-05-25 10:36:07.596881771 -0500
@@ -68,13 +68,15 @@
   // outside code.
 
   // Updates the open-file state.
-  static void UpdateOpenFileState(CommandUpdater* command_updater);
+  static void UpdateOpenFileState(CommandUpdater* command_updater,
+                                  bool started_in_chromeless);
 
   // Update commands whose state depends on incognito mode availability and that
   // only depend on the profile.
   static void UpdateSharedCommandsForIncognitoAvailability(
       CommandUpdater* command_updater,
-      Profile* profile);
+      Profile* profile,
+      bool started_in_chromeless);
 
  private:
   class InterstitialObserver;
Index: dev.saucy/src/chrome/browser/ui/browser_commands.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser_commands.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser_commands.cc	2013-05-25 10:36:07.604882051 -0500
@@ -463,6 +463,9 @@
 }
 
 void NewTab(Browser* browser) {
+  if (browser && browser->is_chromeless_mode())
+    return;
+
   content::RecordAction(UserMetricsAction("NewTab"));
   // TODO(asvitkine): This is invoked programmatically from several places.
   // Audit the code and change it so that the histogram only gets collected for
@@ -496,7 +499,7 @@
   content::RecordAction(UserMetricsAction("RestoreTab"));
   TabRestoreService* service =
       TabRestoreServiceFactory::GetForProfile(browser->profile());
-  if (service)
+  if (service && !browser->is_chromeless_mode())
     service->RestoreMostRecentEntry(browser->tab_restore_service_delegate(),
                                     browser->host_desktop_type());
 }
Index: dev.saucy/src/chrome/browser/ui/browser_finder.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/browser_finder.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/browser_finder.cc	2013-05-25 10:36:07.604882051 -0500
@@ -24,6 +24,7 @@
 const int kMatchOriginalProfile         = 1 << 0;
 const int kMatchCanSupportWindowFeature = 1 << 1;
 const int kMatchTabbed                  = 1 << 2;
+const int kMatchNonChromeless           = 1 << 3;
 
 // Returns true if the specified |browser| matches the specified arguments.
 // |match_types| is a bitmask dictating what parameters to match:
@@ -51,7 +52,11 @@
   }
 
   if (match_types & kMatchTabbed)
-    return browser->is_type_tabbed();
+    return browser->is_type_tabbed() &&
+      !browser->is_chromeless_mode();
+
+  if (match_types & kMatchNonChromeless)
+    return !browser->is_chromeless_mode();
 
   return true;
 }
@@ -79,7 +84,7 @@
   BrowserList* browser_list_impl = BrowserList::GetInstance(desktop_type);
   if (!browser_list_impl)
     return NULL;
-  uint32 match_types = kMatchAny;
+  uint32 match_types = kMatchNonChromeless;
   if (match_tabbed)
     match_types |= kMatchTabbed;
   if (match_original_profiles)
Index: dev.saucy/src/chrome/browser/ui/gtk/browser_window_gtk.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/gtk/browser_window_gtk.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/gtk/browser_window_gtk.cc	2013-05-25 10:36:07.608882191 -0500
@@ -308,6 +308,13 @@
     gtk_window_util::SetWindowCustomClass(window_,
         std::string(gdk_get_program_class()) + " (" + user_data_dir + ")");
   }
+  else if (browser_->is_chromeless_mode()) {
+    // The web application's url associated with the chromeless launch
+    // is appended for later reference.
+    // TODO: very so-so, find a better approach.
+    gtk_window_util::SetWindowCustomClass(window_,
+        web_app::GetWMClassFromAppName("chromeless"));
+  }
 
   // For popups, we initialize widgets then set the window geometry, because
   // popups need the widgets inited before they can set the window size
@@ -919,7 +926,7 @@
 }
 
 void BrowserWindowGtk::SetFocusToLocationBar(bool select_all) {
-  if (!IsFullscreen())
+  if (!IsFullscreen() && IsToolbarSupported())
     GetLocationBar()->FocusLocation(select_all);
 }
 
@@ -1218,6 +1225,20 @@
   gtk_util::SetWindowIcon(window_, browser_->profile());
 }
 
+void BrowserWindowGtk::HandleTabCountChange(bool is_deleting) {
+  if (browser_ == NULL || browser_->tab_strip_model() == NULL)
+    return;
+
+  int count = browser_->tab_strip_model()->count();
+  const int HIDE_TAB_COUNT = is_deleting ? 2 : 1;
+  if (count == HIDE_TAB_COUNT) {
+    tabstrip_->Hide();
+  }
+  else {
+    tabstrip_->Show();
+  }
+}
+
 void BrowserWindowGtk::TabDetachedAt(WebContents* contents, int index) {
   // We use index here rather than comparing |contents| because by this time
   // the model has already removed |contents| from its list, so
@@ -1228,6 +1249,23 @@
     UpdateDevToolsForContents(NULL);
   }
   contents_container_->DetachTab(contents);
+
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabInsertedAt(content::WebContents* contents,
+                                     int index,
+                                     bool foreground) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabClosingAt(TabStripModel* tab_strip_model,
+                                    content::WebContents* contents,
+                                    int index) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(true);
 }
 
 void BrowserWindowGtk::ActiveTabChanged(WebContents* old_contents,
@@ -2182,8 +2220,12 @@
 }
 
 void BrowserWindowGtk::ShowSupportedWindowFeatures() {
-  if (IsTabStripSupported())
-    tabstrip_->Show();
+  if (IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Show();
+  }
 
   if (IsToolbarSupported()) {
     toolbar_->Show();
@@ -2196,8 +2238,12 @@
 }
 
 void BrowserWindowGtk::HideUnsupportedWindowFeatures() {
-  if (!IsTabStripSupported())
-    tabstrip_->Hide();
+  if (!IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Hide();
+  }
 
   if (!IsToolbarSupported())
     toolbar_->Hide();
@@ -2237,7 +2283,8 @@
 
 bool BrowserWindowGtk::UseCustomFrame() const {
   // We don't use the custom frame for app mode windows or app window popups.
-  return use_custom_frame_pref_.GetValue() && !browser_->is_app();
+  return use_custom_frame_pref_.GetValue() &&
+      !browser_->is_app() && !browser_->is_chromeless_mode();
 }
 
 void BrowserWindowGtk::PlaceBookmarkBar(bool is_floating) {
Index: dev.saucy/src/chrome/browser/ui/gtk/browser_window_gtk.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/gtk/browser_window_gtk.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/gtk/browser_window_gtk.h	2013-05-25 10:36:07.608882191 -0500
@@ -190,6 +190,13 @@
                                 int index,
                                 int reason) OVERRIDE;
 
+  virtual void TabInsertedAt(content::WebContents* contents,
+                             int index,
+                             bool foreground) OVERRIDE;
+  virtual void TabClosingAt(TabStripModel* tab_strip_model,
+                            content::WebContents* contents,
+                            int index) OVERRIDE;
+
   // Overridden from ActiveWindowWatcherXObserver.
   virtual void ActiveWindowChanged(GdkWindow* active_window) OVERRIDE;
 
@@ -333,6 +340,9 @@
   // ctrl-l, etc.).
   void ConnectAccelerators();
 
+  // 
+  void HandleTabCountChange(bool is_deleting);
+
   // Whether we should draw the tab background instead of the theme_frame
   // background because this window is a popup.
   bool UsingCustomPopupFrame() const;
Index: dev.saucy/src/chrome/browser/ui/gtk/global_menu_bar.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/gtk/global_menu_bar.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/gtk/global_menu_bar.cc	2013-05-25 10:36:07.608882191 -0500
@@ -25,35 +25,43 @@
 #include "ui/base/gtk/menu_label_accelerator_util.h"
 #include "ui/base/l10n/l10n_util.h"
 
+typedef bool (*GlobalMenuBarVisibilityHandler) (Browser * browser);
+
 struct GlobalMenuBarCommand {
   int str_id;
   int command;
   int tag;
+  GlobalMenuBarVisibilityHandler visibility_handler;
 };
 
 namespace {
 
+bool GlobalMenuBarVisibilityHandler_NotInChromelessMode(
+    Browser * browser) {
+  return browser && !browser->is_chromeless_mode();
+}
+
 const int MENU_SEPARATOR =-1;
 const int MENU_END = -2;
 const int MENU_DISABLED_LABEL = -3;
 
 GlobalMenuBarCommand file_menu[] = {
-  { IDS_NEW_TAB, IDC_NEW_TAB },
-  { IDS_NEW_WINDOW, IDC_NEW_WINDOW },
-  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW },
-  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB },
-  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE },
-  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION },
+  { IDS_NEW_TAB, IDC_NEW_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_WINDOW, IDC_NEW_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS },
+  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_CLOSE_WINDOW_LINUX, IDC_CLOSE_WINDOW },
   { IDS_CLOSE_TAB_LINUX, IDC_CLOSE_TAB },
-  { IDS_SAVE_PAGE, IDC_SAVE_PAGE },
+  { IDS_SAVE_PAGE, IDC_SAVE_PAGE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_SEPARATOR, MENU_SEPARATOR },
 
@@ -71,17 +79,17 @@
 
   { IDS_FIND, IDC_FIND },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_PREFERENCES, IDC_OPTIONS },
+  { IDS_PREFERENCES, IDC_OPTIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand view_menu[] = {
-  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR },
+  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_STOP_MENU_LINUX, IDC_STOP },
   { IDS_RELOAD_MENU_LINUX, IDC_RELOAD },
@@ -97,48 +105,48 @@
 };
 
 GlobalMenuBarCommand history_menu[] = {
-  { IDS_HISTORY_HOME_LINUX, IDC_HOME },
-  { IDS_HISTORY_BACK_LINUX, IDC_BACK },
-  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD },
+  { IDS_HISTORY_HOME_LINUX, IDC_HOME, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_BACK_LINUX, IDC_BACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_VISITED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_MOST_VISITED_HEADER },
+    GlobalMenuBar::TAG_MOST_VISITED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_CLOSED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER },
+    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY },
+  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand tools_menu[] = {
-  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS },
-  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY },
-  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS },
+  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_TASK_MANAGER, IDC_TASK_MANAGER },
-  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA },
+  { IDS_TASK_MANAGER, IDC_TASK_MANAGER, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE },
-  { IDS_DEV_TOOLS, IDC_DEV_TOOLS },
-  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE },
+  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS, IDC_DEV_TOOLS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand help_menu[] = {
-  { IDS_FEEDBACK, IDC_FEEDBACK },
+  { IDS_FEEDBACK, IDC_FEEDBACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
   { IDS_HELP_PAGE , IDC_HELP_PAGE_VIA_MENU },
   { MENU_END, MENU_END }
 };
@@ -191,11 +199,12 @@
   }
 
   pref_change_registrar_.Init(browser_->profile()->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kShowBookmarkBar,
-      base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
-                 base::Unretained(this)));
-  OnBookmarkBarVisibilityChanged();
+  if (! browser_->is_chromeless_mode()) {
+    pref_change_registrar_.Add(
+        prefs::kShowBookmarkBar,
+        base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
+                   base::Unretained(this)));
+ }
 }
 
 GlobalMenuBar::~GlobalMenuBar() {
@@ -218,8 +227,22 @@
     std::map<int, GtkWidget*>* id_to_menu_item,
     GlobalMenuBarCommand* commands,
     GlobalMenuOwner* owner) {
+  // first pass to count the number of "visible" items
+  size_t count = 0;
+  for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (!commands[i].visibility_handler || commands[i].visibility_handler(browser_)) {
+      count++;
+    }
+  }
+  if (0 == count) {
+    return;
+  }
+
   GtkWidget* menu = gtk_menu_new();
   for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (commands[i].visibility_handler && !commands[i].visibility_handler(browser_)) {
+      continue;
+    }
     GtkWidget* menu_item = BuildMenuItem(
         commands[i].str_id, commands[i].command, commands[i].tag,
         id_to_menu_item, menu);
Index: dev.saucy/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc	2013-05-25 10:36:07.612882330 -0500
@@ -786,9 +786,12 @@
   g_signal_connect(tabstrip_.get(), "drag-data-received",
                    G_CALLBACK(OnDragDataReceivedThunk), this);
 
-  newtab_button_.reset(MakeNewTabButton());
-  newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
-                                 newtab_button_->SurfaceHeight());
+  if (window_ && window_->browser() &&
+          ! window_->browser()->is_chromeless_mode()) {
+    newtab_button_.reset(MakeNewTabButton());
+    newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
+                                   newtab_button_->SurfaceHeight());
+  }
 
   gtk_widget_show_all(tabstrip_.get());
 
@@ -1461,6 +1464,9 @@
 
 void TabStripGtk::LayoutNewTabButton(double last_tab_right,
                                      double unselected_width) {
+  if (window_ && window_->browser() && window_->browser()->is_chromeless_mode())
+    return;
+
   GtkWidget* toplevel = gtk_widget_get_ancestor(widget(), GTK_TYPE_WINDOW);
   bool is_maximized = false;
   if (toplevel) {
@@ -1514,8 +1520,10 @@
   int available_width = tabstrip_allocation.width;
   if (available_width_for_tabs_ < 0) {
     available_width = bounds_.width();
-    available_width -=
+    if (newtab_button_.get() != NULL) {
+      available_width -=
         (kNewTabButtonHOffset + newtab_button_->WidgetAllocation().width);
+    }
   } else {
     // Interesting corner case: if |available_width_for_tabs_| > the result
     // of the calculation in the conditional arm above, the strip is in
@@ -2073,8 +2081,11 @@
   gdk_region_union_with_rect(event->region, &event->area);
 
   // Paint the New Tab button.
-  gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
-      newtab_button_->widget(), event);
+  if (newtab_button_.get() != NULL) {
+    // Paint the New Tab button.
+    gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
+        newtab_button_->widget(), event);
+  }
 
   // Paint the tabs in reverse order, so they stack to the left.
   TabGtk* selected_tab = NULL;
@@ -2271,6 +2282,9 @@
 }
 
 void TabStripGtk::SetNewTabButtonBackground() {
+  if (newtab_button_.get() == NULL) {
+    return;
+  }
   SkColor color = theme_service_->GetColor(
       ThemeProperties::COLOR_BUTTON_BACKGROUND);
   SkBitmap background = theme_service_->GetImageNamed(
Index: dev.saucy/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc	2013-05-25 10:36:07.616882470 -0500
@@ -446,6 +446,16 @@
   }
 }
 
+bool StartupBrowserCreatorImpl::IsChromelessLaunch(std::string* url)
+{
+  if (command_line_.HasSwitch(switches::kChromeless)) {
+    if (url)
+      *url = command_line_.GetSwitchValueASCII(switches::kChromeless);
+    return true;
+  }
+  return false;
+}
+
 bool StartupBrowserCreatorImpl::IsAppLaunch(std::string* app_url,
                                             std::string* app_id) {
   if (command_line_.HasSwitch(switches::kApp)) {
@@ -590,6 +600,12 @@
   }
 #endif
 
+  if (IsChromelessLaunch(NULL)) {
+    // Open user-specified URLs like pinned tabs and startup tabs.
+    if (ProcessSpecifiedURLs(urls_to_open))
+      return;
+  }
+
   if (process_startup && ProcessStartupURLs(urls_to_open)) {
     // ProcessStartupURLs processed the urls, nothing else to do.
     return;
@@ -732,7 +748,8 @@
   // mode. Also, no pages should be opened automatically if the session
   // crashed. Otherwise it might trigger another crash, locking the user out of
   // chrome. The crash infobar is shown in this case.
-  if (!IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
+  if (!IsChromelessLaunch(NULL) &&
+      !IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
                                                  profile_->GetPrefs()) &&
       !HasPendingUncleanExit(profile_)) {
     tabs = PinnedTabCodec::ReadPinnedTabs(profile_);
@@ -813,6 +830,10 @@
   if (!profile_ && browser)
     profile_ = browser->profile();
 
+  if (IsChromelessLaunch(NULL)) {
+    browser = new Browser(Browser::CreateParams::CreateChromeless(profile_));
+  }
+
   if (!browser || !browser->is_type_tabbed()) {
     // The startup code only executes for browsers launched in desktop mode.
     // i.e. HOST_DESKTOP_TYPE_NATIVE. Ash should never get here.
@@ -892,6 +913,11 @@
   if (!browser || !profile_ || browser->tab_strip_model()->count() == 0)
     return;
 
+  // We consider that being in a chromeless launch, we are to minimize
+  // as much as possible the most obvious "classic" Chromium behavior.
+  if (IsChromelessLaunch(NULL))
+      return;
+
   if (HasPendingUncleanExit(browser->profile()))
     SessionCrashedInfoBarDelegate::Create(browser);
 
Index: dev.saucy/src/chrome/browser/ui/startup/startup_browser_creator_impl.h
===================================================================
--- dev.saucy.orig/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/browser/ui/startup/startup_browser_creator_impl.h	2013-05-25 10:36:07.616882470 -0500
@@ -79,6 +79,11 @@
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, RestorePinnedTabs);
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, AppIdSwitch);
 
+  // If the process was launched with the chromeless command line flag,
+  // e.g. --chromeless=http://www.google.com/ return true.
+  // In this case |url| is populated if they're non-null.
+  bool IsChromelessLaunch(std::string* url);
+
   // Extracts optional application window size passed in command line.
   void ExtractOptionalAppWindowSize(gfx::Rect* bounds);
 
Index: dev.saucy/src/chrome/common/chrome_switches.cc
===================================================================
--- dev.saucy.orig/src/chrome/common/chrome_switches.cc	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/common/chrome_switches.cc	2013-05-25 10:36:07.620882610 -0500
@@ -158,6 +158,9 @@
 // as a dependent process of the Chrome Frame plugin.
 const char kChromeFrame[]                   = "chrome-frame";
 
+// Specifies a given URL to be opened in a chromeless mode.
+const char kChromeless[]                    = "chromeless";
+
 // Tells chrome to load the specified version of chrome.dll on Windows. If this
 // version cannot be loaded, Chrome will exit.
 const char kChromeVersion[]                 = "chrome-version";
Index: dev.saucy/src/chrome/common/chrome_switches.h
===================================================================
--- dev.saucy.orig/src/chrome/common/chrome_switches.h	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/common/chrome_switches.h	2013-05-25 10:36:07.620882610 -0500
@@ -59,6 +59,7 @@
 extern const char kCheckForUpdateIntervalSec[];
 extern const char kCheckCloudPrintConnectorPolicy[];
 extern const char kChromeFrame[];
+extern const char kChromeless[];
 extern const char kChromeVersion[];
 extern const char kCipherSuiteBlacklist[];
 extern const char kClearTokenService[];
Index: dev.saucy/src/chrome/common/extensions/api/extension.json
===================================================================
--- dev.saucy.orig/src/chrome/common/extensions/api/extension.json	2013-05-25 10:36:07.640883310 -0500
+++ dev.saucy/src/chrome/common/extensions/api/extension.json	2013-05-25 10:36:07.620882610 -0500
@@ -138,6 +138,32 @@
         }
       },
       {
+        "name": "isChromelessWindow",
+        "type": "function",
+        "unprivileged": true,
+        "description": "Checks is a given extension runs part of a chromeless window.",
+        "parameters": [
+          {
+            "type": "integer",
+            "name": "tabId",
+            "optional": true,
+            "description": "The tab id corresponding to the window to restrict the request to."
+          }
+          ,
+          {
+            "type": "function",
+            "name": "callback",
+            "parameters": [
+              {
+                "name": "isChromelessWindow",
+                "type": "boolean",
+                "description": "True if the extension runs part of a chromeless window, false otherwise."
+              }
+            ]
+          }
+        ]
+      },
+      {
         "name": "isAllowedIncognitoAccess",
         "type": "function",
         "description": "Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.",
