--- a/src/chrome/browser/ui/browser.cc
+++ b/src/chrome/browser/ui/browser.cc
@@ -271,6 +271,7 @@
       profile(profile),
       host_desktop_type(kDefaultHostDesktopType),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
@@ -282,6 +283,7 @@
       profile(profile),
       host_desktop_type(kDefaultHostDesktopType),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
@@ -293,6 +295,7 @@
       profile(profile),
       host_desktop_type(host_desktop_type),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
@@ -305,12 +308,21 @@
       profile(profile),
       host_desktop_type(host_desktop_type),
       app_type(APP_TYPE_HOST),
+      is_chromeless_mode(false),
       initial_show_state(ui::SHOW_STATE_DEFAULT),
       is_session_restore(false),
       window(NULL) {
 }
 
 // static
+Browser::CreateParams Browser::CreateParams::CreateChromeless(Profile * profile)
+{
+  CreateParams params(profile);
+  params.is_chromeless_mode = true;
+  return params;
+}
+
+// static
 Browser::CreateParams Browser::CreateParams::CreateForApp(
     Type type,
     const std::string& app_name,
@@ -348,6 +360,7 @@
       tab_strip_model_(new TabStripModel(tab_strip_model_delegate_.get(),
                                          params.profile)),
       app_name_(params.app_name),
+      is_chromeless_mode_(params.is_chromeless_mode),
       app_type_(params.app_type),
       chrome_updater_factory_(this),
       cancel_download_confirmation_state_(NOT_PROMPTED),
@@ -561,6 +574,10 @@
   return find_bar_controller_.get() != NULL;
 }
 
+bool Browser::is_chromeless_mode () const {
+  return is_chromeless_mode_;
+}
+
 bool Browser::is_app() const {
   return !app_name_.empty();
 }
@@ -606,7 +623,7 @@
     return title;
 #endif
   // Don't append the app name to window titles on app frames and app popups
-  return is_app() ?
+  return (is_app() || is_chromeless_mode()) ?
       title :
       l10n_util::GetStringFUTF16(IDS_BROWSER_WINDOW_TITLE_FORMAT, title);
 }
@@ -664,7 +681,8 @@
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 #endif
 
-  if (tab_restore_service && is_type_tabbed() && tab_count())
+  if (tab_restore_service && is_type_tabbed() &&
+          !is_chromeless_mode() && tab_count())
     tab_restore_service->BrowserClosing(tab_restore_service_delegate());
 
   // TODO(sky): convert session/tab restore to use notification.
@@ -2285,20 +2303,20 @@
 
   unsigned int features = FEATURE_INFOBAR | FEATURE_DOWNLOADSHELF;
 
-  if (is_type_tabbed())
+  if (is_type_tabbed() && !is_chromeless_mode())
     features |= FEATURE_BOOKMARKBAR;
 
   if (!hide_ui_for_fullscreen) {
-    if (!is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TITLEBAR;
 
     if (is_type_tabbed())
       features |= FEATURE_TABSTRIP;
 
-    if (is_type_tabbed())
+    if (is_type_tabbed() && !is_chromeless_mode())
       features |= FEATURE_TOOLBAR;
 
-    if (!is_app())
+    if (!is_app() && !is_chromeless_mode())
       features |= FEATURE_LOCATIONBAR;
   }
   return !!(features & feature);
--- a/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
+++ b/src/chrome/browser/ui/gtk/tabs/tab_strip_gtk.cc
@@ -781,9 +781,12 @@
   g_signal_connect(tabstrip_.get(), "drag-data-received",
                    G_CALLBACK(OnDragDataReceivedThunk), this);
 
-  newtab_button_.reset(MakeNewTabButton());
-  newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
-                                 newtab_button_->SurfaceHeight());
+  if (window_ && window_->browser() &&
+          ! window_->browser()->is_chromeless_mode()) {
+    newtab_button_.reset(MakeNewTabButton());
+    newtab_surface_bounds_.SetRect(0, 0, newtab_button_->SurfaceWidth(),
+                                   newtab_button_->SurfaceHeight());
+  }
 
   gtk_widget_show_all(tabstrip_.get());
 
@@ -1456,6 +1459,9 @@
 
 void TabStripGtk::LayoutNewTabButton(double last_tab_right,
                                      double unselected_width) {
+  if (window_ && window_->browser() && window_->browser()->is_chromeless_mode())
+    return;
+
   GtkWidget* toplevel = gtk_widget_get_ancestor(widget(), GTK_TYPE_WINDOW);
   bool is_maximized = false;
   if (toplevel) {
@@ -1509,8 +1515,10 @@
   int available_width = tabstrip_allocation.width;
   if (available_width_for_tabs_ < 0) {
     available_width = bounds_.width();
-    available_width -=
+    if (newtab_button_.get() != NULL) {
+      available_width -=
         (kNewTabButtonHOffset + newtab_button_->WidgetAllocation().width);
+    }
   } else {
     // Interesting corner case: if |available_width_for_tabs_| > the result
     // of the calculation in the conditional arm above, the strip is in
@@ -2068,8 +2076,11 @@
   gdk_region_union_with_rect(event->region, &event->area);
 
   // Paint the New Tab button.
-  gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
-      newtab_button_->widget(), event);
+  if (newtab_button_.get() != NULL) {
+    // Paint the New Tab button.
+    gtk_container_propagate_expose(GTK_CONTAINER(tabstrip_.get()),
+        newtab_button_->widget(), event);
+  }
 
   // Paint the tabs in reverse order, so they stack to the left.
   TabGtk* selected_tab = NULL;
@@ -2265,6 +2276,9 @@
 }
 
 void TabStripGtk::SetNewTabButtonBackground() {
+  if (newtab_button_.get() == NULL) {
+    return;
+  }
   SkColor color = theme_service_->GetColor(
       ThemeService::COLOR_BUTTON_BACKGROUND);
   SkBitmap background = theme_service_->GetImageNamed(
--- a/src/chrome/browser/ui/gtk/browser_window_gtk.cc
+++ b/src/chrome/browser/ui/gtk/browser_window_gtk.cc
@@ -314,6 +314,13 @@
     gtk_window_util::SetWindowCustomClass(window_,
         std::string(gdk_get_program_class()) + " (" + user_data_dir + ")");
   }
+  else if (browser_->is_chromeless_mode()) {
+    // The web application's url associated with the chromeless launch
+    // is appended for later reference.
+    // TODO: very so-so, find a better approach.
+    gtk_window_util::SetWindowCustomClass(window_,
+        web_app::GetWMClassFromAppName("chromeless"));
+  }
 
   // For popups, we initialize widgets then set the window geometry, because
   // popups need the widgets inited before they can set the window size
@@ -896,7 +903,7 @@
 }
 
 void BrowserWindowGtk::SetFocusToLocationBar(bool select_all) {
-  if (!IsFullscreen())
+  if (!IsFullscreen() && IsToolbarSupported())
     GetLocationBar()->FocusLocation(select_all);
 }
 
@@ -1209,6 +1216,20 @@
   gtk_util::SetWindowIcon(window_, browser_->profile());
 }
 
+void BrowserWindowGtk::HandleTabCountChange(bool is_deleting) {
+  if (browser_ == NULL || browser_->tab_strip_model() == NULL)
+    return;
+
+  int count = browser_->tab_strip_model()->count();
+  const int HIDE_TAB_COUNT = is_deleting ? 2 : 1;
+  if (count == HIDE_TAB_COUNT) {
+    tabstrip_->Hide();
+  }
+  else {
+    tabstrip_->Show();
+  }
+}
+
 void BrowserWindowGtk::TabDetachedAt(WebContents* contents, int index) {
   // We use index here rather than comparing |contents| because by this time
   // the model has already removed |contents| from its list, so
@@ -1219,6 +1240,23 @@
     UpdateDevToolsForContents(NULL);
   }
   contents_container_->DetachTab(contents);
+
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabInsertedAt(content::WebContents* contents,
+                                     int index,
+                                     bool foreground) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(false);
+}
+
+void BrowserWindowGtk::TabClosingAt(TabStripModel* tab_strip_model,
+                                    content::WebContents* contents,
+                                    int index) {
+  if (browser_->is_chromeless_mode())
+    HandleTabCountChange(true);
 }
 
 void BrowserWindowGtk::ActiveTabChanged(WebContents* old_contents,
@@ -2169,8 +2207,12 @@
 }
 
 void BrowserWindowGtk::ShowSupportedWindowFeatures() {
-  if (IsTabStripSupported())
-    tabstrip_->Show();
+  if (IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Show();
+  }
 
   if (IsToolbarSupported()) {
     toolbar_->Show();
@@ -2183,8 +2225,12 @@
 }
 
 void BrowserWindowGtk::HideUnsupportedWindowFeatures() {
-  if (!IsTabStripSupported())
-    tabstrip_->Hide();
+  if (!IsTabStripSupported()) {
+    if (browser_->is_chromeless_mode())
+      HandleTabCountChange(false);
+    else
+      tabstrip_->Hide();
+  }
 
   if (!IsToolbarSupported())
     toolbar_->Hide();
@@ -2270,7 +2316,8 @@
 
 bool BrowserWindowGtk::UseCustomFrame() const {
   // We don't use the custom frame for app mode windows or app window popups.
-  return use_custom_frame_pref_.GetValue() && !browser_->is_app();
+  return use_custom_frame_pref_.GetValue() &&
+      !browser_->is_app() && !browser_->is_chromeless_mode();
 }
 
 void BrowserWindowGtk::PlaceBookmarkBar(bool is_floating) {
--- a/src/chrome/browser/ui/gtk/global_menu_bar.cc
+++ b/src/chrome/browser/ui/gtk/global_menu_bar.cc
@@ -25,35 +25,43 @@
 #include "ui/base/gtk/menu_label_accelerator_util.h"
 #include "ui/base/l10n/l10n_util.h"
 
+typedef bool (*GlobalMenuBarVisibilityHandler) (Browser * browser);
+
 struct GlobalMenuBarCommand {
   int str_id;
   int command;
   int tag;
+  GlobalMenuBarVisibilityHandler visibility_handler;
 };
 
 namespace {
 
+bool GlobalMenuBarVisibilityHandler_NotInChromelessMode(
+    Browser * browser) {
+  return browser && !browser->is_chromeless_mode();
+}
+
 const int MENU_SEPARATOR =-1;
 const int MENU_END = -2;
 const int MENU_DISABLED_LABEL = -3;
 
 GlobalMenuBarCommand file_menu[] = {
-  { IDS_NEW_TAB, IDC_NEW_TAB },
-  { IDS_NEW_WINDOW, IDC_NEW_WINDOW },
-  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW },
-  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB },
-  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE },
-  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION },
+  { IDS_NEW_TAB, IDC_NEW_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_WINDOW, IDC_NEW_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_NEW_INCOGNITO_WINDOW, IDC_NEW_INCOGNITO_WINDOW, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_REOPEN_CLOSED_TABS_LINUX, IDC_RESTORE_TAB, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_FILE_LINUX, IDC_OPEN_FILE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_OPEN_LOCATION_LINUX, IDC_FOCUS_LOCATION, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS },
+  { IDS_CREATE_SHORTCUTS, IDC_CREATE_SHORTCUTS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_CLOSE_WINDOW_LINUX, IDC_CLOSE_WINDOW },
   { IDS_CLOSE_TAB_LINUX, IDC_CLOSE_TAB },
-  { IDS_SAVE_PAGE, IDC_SAVE_PAGE },
+  { IDS_SAVE_PAGE, IDC_SAVE_PAGE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_SEPARATOR, MENU_SEPARATOR },
 
@@ -71,17 +79,17 @@
 
   { IDS_FIND, IDC_FIND },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_PREFERENCES, IDC_OPTIONS },
+  { IDS_PREFERENCES, IDC_OPTIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand view_menu[] = {
-  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR },
+  { IDS_SHOW_BOOKMARK_BAR, IDC_SHOW_BOOKMARK_BAR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_STOP_MENU_LINUX, IDC_STOP },
   { IDS_RELOAD_MENU_LINUX, IDC_RELOAD },
@@ -97,48 +105,48 @@
 };
 
 GlobalMenuBarCommand history_menu[] = {
-  { IDS_HISTORY_HOME_LINUX, IDC_HOME },
-  { IDS_HISTORY_BACK_LINUX, IDC_BACK },
-  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD },
+  { IDS_HISTORY_HOME_LINUX, IDC_HOME, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_BACK_LINUX, IDC_BACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_HISTORY_FORWARD_LINUX, IDC_FORWARD, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_VISITED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_MOST_VISITED_HEADER },
+    GlobalMenuBar::TAG_MOST_VISITED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { IDS_HISTORY_CLOSED_LINUX, MENU_DISABLED_LABEL,
-    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER },
+    GlobalMenuBar::TAG_RECENTLY_CLOSED_HEADER, GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY },
+  { IDS_SHOWFULLHISTORY_LINK, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand tools_menu[] = {
-  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS },
-  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY },
-  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS },
+  { IDS_SHOW_DOWNLOADS, IDC_SHOW_DOWNLOADS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_HISTORY, IDC_SHOW_HISTORY, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_SHOW_EXTENSIONS, IDC_MANAGE_EXTENSIONS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_TASK_MANAGER, IDC_TASK_MANAGER },
-  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA },
+  { IDS_TASK_MANAGER, IDC_TASK_MANAGER, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_CLEAR_BROWSING_DATA, IDC_CLEAR_BROWSING_DATA, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { MENU_SEPARATOR, MENU_SEPARATOR },
+  { MENU_SEPARATOR, MENU_SEPARATOR, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
-  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE },
-  { IDS_DEV_TOOLS, IDC_DEV_TOOLS },
-  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE },
+  { IDS_VIEW_SOURCE, IDC_VIEW_SOURCE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS, IDC_DEV_TOOLS, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
+  { IDS_DEV_TOOLS_CONSOLE, IDC_DEV_TOOLS_CONSOLE, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
 
   { MENU_END, MENU_END }
 };
 
 GlobalMenuBarCommand help_menu[] = {
-  { IDS_FEEDBACK, IDC_FEEDBACK },
+  { IDS_FEEDBACK, IDC_FEEDBACK, int(), GlobalMenuBarVisibilityHandler_NotInChromelessMode },
   { IDS_HELP_PAGE , IDC_HELP_PAGE_VIA_MENU },
   { MENU_END, MENU_END }
 };
@@ -191,11 +199,12 @@
   }
 
   pref_change_registrar_.Init(browser_->profile()->GetPrefs());
-  pref_change_registrar_.Add(
-      prefs::kShowBookmarkBar,
-      base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
-                 base::Unretained(this)));
-  OnBookmarkBarVisibilityChanged();
+  if (! browser_->is_chromeless_mode()) {
+    pref_change_registrar_.Add(
+        prefs::kShowBookmarkBar,
+        base::Bind(&GlobalMenuBar::OnBookmarkBarVisibilityChanged,
+                   base::Unretained(this)));
+ }
 }
 
 GlobalMenuBar::~GlobalMenuBar() {
@@ -218,8 +227,22 @@
     std::map<int, GtkWidget*>* id_to_menu_item,
     GlobalMenuBarCommand* commands,
     GlobalMenuOwner* owner) {
+  // first pass to count the number of "visible" items
+  size_t count = 0;
+  for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (!commands[i].visibility_handler || commands[i].visibility_handler(browser_)) {
+      count++;
+    }
+  }
+  if (0 == count) {
+    return;
+  }
+
   GtkWidget* menu = gtk_menu_new();
   for (int i = 0; commands[i].str_id != MENU_END; ++i) {
+    if (commands[i].visibility_handler && !commands[i].visibility_handler(browser_)) {
+      continue;
+    }
     GtkWidget* menu_item = BuildMenuItem(
         commands[i].str_id, commands[i].command, commands[i].tag,
         id_to_menu_item, menu);
--- a/src/chrome/browser/ui/gtk/browser_window_gtk.h
+++ b/src/chrome/browser/ui/gtk/browser_window_gtk.h
@@ -189,6 +189,13 @@
                                 int index,
                                 bool user_gesture) OVERRIDE;
 
+  virtual void TabInsertedAt(content::WebContents* contents,
+                             int index,
+                             bool foreground) OVERRIDE;
+  virtual void TabClosingAt(TabStripModel* tab_strip_model,
+                            content::WebContents* contents,
+                            int index) OVERRIDE;
+
   // Overridden from ActiveWindowWatcherXObserver.
   virtual void ActiveWindowChanged(GdkWindow* active_window) OVERRIDE;
 
@@ -329,6 +336,9 @@
   // ctrl-l, etc.).
   void ConnectAccelerators();
 
+  // 
+  void HandleTabCountChange(bool is_deleting);
+
   // Whether we should draw the tab background instead of the theme_frame
   // background because this window is a popup.
   bool UsingCustomPopupFrame() const;
--- a/src/chrome/browser/ui/startup/startup_browser_creator_impl.h
+++ b/src/chrome/browser/ui/startup/startup_browser_creator_impl.h
@@ -72,6 +72,11 @@
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, RestorePinnedTabs);
   FRIEND_TEST_ALL_PREFIXES(BrowserTest, AppIdSwitch);
 
+  // If the process was launched with the chromeless command line flag,
+  // e.g. --chromeless=http://www.google.com/ return true.
+  // In this case |url| is populated if they're non-null.
+  bool IsChromelessLaunch(std::string* url);
+
   // Extracts optional application window size passed in command line.
   void ExtractOptionalAppWindowSize(gfx::Rect* bounds);
 
--- a/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc
+++ b/src/chrome/browser/ui/startup/startup_browser_creator_impl.cc
@@ -416,6 +416,16 @@
   }
 }
 
+bool StartupBrowserCreatorImpl::IsChromelessLaunch(std::string* url)
+{
+  if (command_line_.HasSwitch(switches::kChromeless)) {
+    if (url)
+      *url = command_line_.GetSwitchValueASCII(switches::kChromeless);
+    return true;
+  }
+  return false;
+}
+
 bool StartupBrowserCreatorImpl::IsAppLaunch(Profile* profile,
                                             std::string* app_url,
                                             std::string* app_id) {
@@ -555,6 +565,12 @@
     return;
   }
 
+  if (IsChromelessLaunch(NULL)) {
+    // Open user-specified URLs like pinned tabs and startup tabs.
+    if (ProcessSpecifiedURLs(urls_to_open))
+      return;
+  }
+
   if (process_startup && ProcessStartupURLs(urls_to_open)) {
     // ProcessStartupURLs processed the urls, nothing else to do.
     return;
@@ -699,7 +715,8 @@
   // mode. Also, no pages should be opened automatically if the session
   // crashed. Otherwise it might trigger another crash, locking the user out of
   // chrome. The crash infobar is shown in this case.
-  if (!IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
+  if (!IsChromelessLaunch(NULL) &&
+      !IncognitoModePrefs::ShouldLaunchIncognito(command_line_,
                                                  profile_->GetPrefs()) &&
       !HasPendingUncleanExit(profile_)) {
     tabs = PinnedTabCodec::ReadPinnedTabs(profile_);
@@ -775,6 +792,10 @@
   if (!profile_ && browser)
     profile_ = browser->profile();
 
+  if (IsChromelessLaunch(NULL)) {
+    browser = new Browser(Browser::CreateParams::CreateChromeless(profile_));
+  }
+
   if (!browser || !browser->is_type_tabbed()) {
     // The startup code only executes for browsers launched in desktop mode.
     // i.e. HOST_DESKTOP_TYPE_NATIVE. Ash should never get here.
@@ -854,6 +875,11 @@
   if (!browser || !profile_ || browser->tab_count() == 0)
     return;
 
+  // We consider that being in a chromeless launch, we are to minimize
+  // as much as possible the most obvious "classic" Chromium behavior.
+  if (IsChromelessLaunch(NULL))
+      return;
+
   if (HasPendingUncleanExit(browser->profile()))
     chrome::ShowSessionCrashedPrompt(browser);
 
--- a/src/chrome/browser/ui/browser_commands.cc
+++ b/src/chrome/browser/ui/browser_commands.cc
@@ -456,6 +456,9 @@
 }
 
 void NewTab(Browser* browser) {
+  if (browser && browser->is_chromeless_mode())
+    return;
+
   content::RecordAction(UserMetricsAction("NewTab"));
   // TODO(asvitkine): This is invoked programmatically from several places.
   // Audit the code and change it so that the histogram only gets collected for
@@ -495,7 +498,8 @@
 bool CanRestoreTab(const Browser* browser) {
   TabRestoreService* service =
       TabRestoreServiceFactory::GetForProfile(browser->profile());
-  return service && !service->entries().empty();
+  return service && !service->entries().empty()
+    && !browser->is_chromeless_mode();
 }
 
 void SelectNextTab(Browser* browser) {
--- a/src/chrome/browser/ui/browser.h
+++ b/src/chrome/browser/ui/browser.h
@@ -174,6 +174,9 @@
                                      const gfx::Rect& window_bounds,
                                      Profile* profile);
 
+    // Like Create, but creates a chromeless browser.
+    static CreateParams CreateChromeless(Profile * profile);
+
     static CreateParams CreateForDevTools(Profile* profile);
 
     // The browser type.
@@ -194,6 +197,9 @@
     // Type of app (host or child). See description of AppType.
     AppType app_type;
 
+    // If the browser instance is supposed to be a chromeless one.
+    bool is_chromeless_mode;
+
     // The bounds of the window to open.
     gfx::Rect initial_bounds;
 
@@ -468,6 +474,7 @@
   bool is_type_popup() const { return type_ == TYPE_POPUP; }
   bool is_type_panel() const { return type_ == TYPE_PANEL; }
 
+  bool is_chromeless_mode() const;
   bool is_app() const;
   bool is_devtools() const;
 
@@ -849,6 +856,8 @@
   // 2) we launch an undocked devtool window.
   std::string app_name_;
 
+  bool is_chromeless_mode_;
+
   // Type of app (host or child). See description of AppType.
   AppType app_type_;
 
--- a/src/chrome/browser/ui/browser_command_controller.cc
+++ b/src/chrome/browser/ui/browser_command_controller.cc
@@ -4,6 +4,7 @@
 
 #include "chrome/browser/ui/browser_command_controller.h"
 
+#include "base/command_line.h"
 #include "chrome/app/chrome_command_ids.h"
 #include "chrome/browser/browser_process.h"
 #include "chrome/browser/defaults.h"
@@ -28,6 +29,7 @@
 #include "chrome/browser/ui/tabs/tab_strip_model_utils.h"
 #include "chrome/browser/ui/webui/sync_promo/sync_promo_ui.h"
 #include "chrome/common/chrome_notification_types.h"
+#include "chrome/common/chrome_switches.h"
 #include "chrome/common/pref_names.h"
 #include "chrome/common/profiling.h"
 #include "content/public/browser/native_web_keyboard_event.h"
@@ -768,7 +770,8 @@
 
 bool BrowserCommandController::IsShowingMainUI(bool is_fullscreen) {
 #if !defined(OS_MACOSX)
-  return browser_->is_type_tabbed() && !is_fullscreen;
+  return browser_->is_type_tabbed() && !is_fullscreen &&
+      !browser_->is_chromeless_mode();
 #else
   return browser_->is_type_tabbed();
 #endif
@@ -779,6 +782,9 @@
   // (like Back & Forward with initial page load) must have their state
   // initialized here, otherwise they will be forever disabled.
 
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless);
+
   // Navigation commands
   command_updater_.UpdateCommandEnabled(IDC_RELOAD, true);
   command_updater_.UpdateCommandEnabled(IDC_RELOAD_IGNORING_CACHE, true);
@@ -786,9 +792,10 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_WINDOW, true);
-  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_NEW_TAB, !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_CLOSE_TAB, true);
-  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB, true);
+  command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_RESTORE_TAB, false);
   command_updater_.UpdateCommandEnabled(IDC_EXIT, true);
   command_updater_.UpdateCommandEnabled(IDC_DEBUG_FRAME_TOGGLE, true);
@@ -850,24 +857,32 @@
   UpdateCommandsForDevTools();
   command_updater_.UpdateCommandEnabled(IDC_TASK_MANAGER, CanOpenTaskManager());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_HISTORY,
-                                        !profile()->IsGuestSession());
-  command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS, true);
+                                        !profile()->IsGuestSession() &&
+                                            !started_in_chromeless);
+  command_updater_.UpdateCommandEnabled(IDC_SHOW_DOWNLOADS,
+                                        !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_KEYBOARD, true);
   command_updater_.UpdateCommandEnabled(IDC_HELP_PAGE_VIA_MENU, true);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARKS_MENU,
-                                        !profile()->IsGuestSession());
+                                        !profile()->IsGuestSession() &&
+                                            !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_RECENT_TABS_MENU,
                                         !profile()->IsGuestSession() &&
-                                        !profile()->IsOffTheRecord());
+                                        !profile()->IsOffTheRecord() &&
+                                        !started_in_chromeless);
 
   command_updater_.UpdateCommandEnabled(
-      IDC_SHOW_SYNC_SETUP, profile()->GetOriginalProfile()->IsSyncAccessible());
+      IDC_SHOW_SYNC_SETUP,
+      profile()->GetOriginalProfile()->IsSyncAccessible() &&
+          !started_in_chromeless);
 
   // Initialize other commands based on the window type.
   bool normal_window = browser_->is_type_tabbed();
 
   // Navigation commands
-  command_updater_.UpdateCommandEnabled(IDC_HOME, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_HOME,
+                                        normal_window &&
+                                            !started_in_chromeless);
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_SELECT_NEXT_TAB, normal_window);
@@ -895,7 +910,9 @@
   command_updater_.UpdateCommandEnabled(IDC_TABPOSE, normal_window);
 
   // Show various bits of UI
-  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA, normal_window);
+  command_updater_.UpdateCommandEnabled(IDC_CLEAR_BROWSING_DATA,
+                                        normal_window &&
+                                            !started_in_chromeless);
 
   // The upgrade entry and the view incompatibility entry should always be
   // enabled. Whether they are visible is a separate matter determined on menu
@@ -905,7 +922,8 @@
 
   // View Background Pages entry is always enabled, but is hidden if there are
   // no background pages.
-  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES, true);
+  command_updater_.UpdateCommandEnabled(IDC_VIEW_BACKGROUND_PAGES,
+                                        !started_in_chromeless);
 
   // Toggle speech input
   command_updater_.UpdateCommandEnabled(IDC_TOGGLE_SPEECH_INPUT, true);
@@ -921,19 +939,26 @@
 }
 
 void BrowserCommandController::UpdateCommandsForIncognitoAvailability() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   IncognitoModePrefs::Availability incognito_availability =
       IncognitoModePrefs::GetAvailability(profile()->GetPrefs());
   command_updater_.UpdateCommandEnabled(
       IDC_NEW_WINDOW,
-      incognito_availability != IncognitoModePrefs::FORCED);
+      incognito_availability != IncognitoModePrefs::FORCED
+          && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(
       IDC_NEW_INCOGNITO_WINDOW,
-      incognito_availability != IncognitoModePrefs::DISABLED);
+      incognito_availability != IncognitoModePrefs::DISABLED
+          && !started_in_chromeless);
 
   // Bookmark manager and settings page/subpages are forced to open in normal
   // mode. For this reason we disable these commands when incognito is forced.
   const bool command_enabled =
-      incognito_availability != IncognitoModePrefs::FORCED;
+      incognito_availability != IncognitoModePrefs::FORCED &&
+      !started_in_chromeless;
   command_updater_.UpdateCommandEnabled(
       IDC_SHOW_BOOKMARK_MANAGER,
       browser_defaults::bookmarks_enabled && command_enabled);
@@ -967,17 +992,20 @@
 
   // Window management commands
   command_updater_.UpdateCommandEnabled(IDC_DUPLICATE_TAB,
-      !browser_->is_app() && CanDuplicateTab(browser_));
+      !browser_->is_chromeless_mode() && !browser_->is_app()
+          && CanDuplicateTab(browser_));
 
   // Page-related commands
   window()->SetStarredState(
       BookmarkTabHelper::FromWebContents(current_web_contents)->is_starred());
   window()->ZoomChangedForActiveTab(false);
   command_updater_.UpdateCommandEnabled(IDC_VIEW_SOURCE,
-                                        CanViewSource(browser_));
+                                        CanViewSource(browser_)
+                                            && !browser_->is_chromeless_mode());
   command_updater_.UpdateCommandEnabled(IDC_EMAIL_PAGE_LOCATION,
-                                        CanEmailPageLocation(browser_));
-  if (browser_->is_devtools())
+                                        CanEmailPageLocation(browser_)
+                                            && !browser_->is_chromeless_mode());
+  if (browser_->is_devtools() && browser_->is_chromeless_mode())
     command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, false);
 
   // Changing the encoding is not possible on Chrome-internal webpages.
@@ -993,7 +1021,8 @@
 #if !defined(OS_MACOSX)
   command_updater_.UpdateCommandEnabled(
       IDC_CREATE_SHORTCUTS,
-      CanCreateApplicationShortcuts(browser_));
+      CanCreateApplicationShortcuts(browser_)
+          && !browser_->is_chromeless_mode());
 #endif
 
   command_updater_.UpdateCommandEnabled(
@@ -1032,21 +1061,31 @@
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkEditing() {
+  bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+        || browser_->is_chromeless_mode();
+
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_PAGE,
-                                        CanBookmarkCurrentPage(browser_));
+                                        CanBookmarkCurrentPage(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_BOOKMARK_ALL_TABS,
-                                        CanBookmarkAllTabs(browser_));
+                                        CanBookmarkAllTabs(browser_)
+                                            && !started_in_chromeless);
   command_updater_.UpdateCommandEnabled(IDC_PIN_TO_START_SCREEN,
-                                        true);
+                                        !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForBookmarkBar() {
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
   const bool show_main_ui =
       IsShowingMainUI(window() && window()->IsFullscreen());
   command_updater_.UpdateCommandEnabled(IDC_SHOW_BOOKMARK_BAR,
       browser_defaults::bookmarks_enabled &&
       !profile()->GetPrefs()->IsManagedPreference(prefs::kShowBookmarkBar) &&
-      show_main_ui);
+      show_main_ui && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateCommandsForFileSelectionDialogs() {
@@ -1108,6 +1147,7 @@
   // mode.
   bool fullscreen_enabled =
       !(browser_->is_type_panel() && browser_->is_app()) &&
+      !browser_->is_chromeless_mode() &&
       fullscreen_mode != FULLSCREEN_METRO_SNAP;
 #if defined(OS_MACOSX)
   // The Mac implementation doesn't support switching to fullscreen while
@@ -1163,7 +1203,12 @@
   if (local_state)
     enabled = local_state->GetBoolean(prefs::kAllowFileSelectionDialogs);
 
-  command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE, enabled);
+  const bool started_in_chromeless =
+    CommandLine::ForCurrentProcess()->HasSwitch(switches::kChromeless)
+    || browser_->is_chromeless_mode();
+
+  command_updater_.UpdateCommandEnabled(IDC_OPEN_FILE,
+                                        enabled && !started_in_chromeless);
 }
 
 void BrowserCommandController::UpdateReloadStopState(bool is_loading,
--- a/src/chrome/browser/extensions/extension_function_registry.cc
+++ b/src/chrome/browser/extensions/extension_function_registry.cc
@@ -322,6 +322,7 @@
   RegisterFunction<extensions::SetUpdateUrlDataFunction>();
   RegisterFunction<extensions::IsAllowedIncognitoAccessFunction>();
   RegisterFunction<extensions::IsAllowedFileSchemeAccessFunction>();
+  RegisterFunction<extensions::IsChromelessWindowFunction>();
 
   // WebstorePrivate.
   RegisterFunction<extensions::GetBrowserLoginFunction>();
--- a/src/chrome/browser/extensions/api/module/module.cc
+++ b/src/chrome/browser/extensions/api/module/module.cc
@@ -7,8 +7,27 @@
 #include <string>
 
 #include "chrome/browser/extensions/extension_prefs.h"
+#include "chrome/browser/extensions/extension_tab_util.h"
 #include "chrome/browser/extensions/extension_service.h"
+#include "chrome/browser/ui/browser.h"
 #include "chrome/browser/profiles/profile.h"
+#include "chrome/common/chrome_switches.h"
+
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+#include <gdk/gdk.h>
+#include <gdk/gdkx.h>
+#endif
+
+#if defined(OS_LINUX) && defined(TOOLKIT_GTK)
+
+namespace {
+
+const char kNoCurrentWindowError[] = "No current window";
+const char kCouldNotIdentifyTab[] = "Could not find tab with specified ID";
+
+} // namespace {
+
+#endif
 
 namespace extensions {
 
@@ -42,4 +61,36 @@
   return true;
 }
 
+bool IsChromelessWindowFunction::RunImpl() {
+  bool is_chromeless = false;
+
+  int tab_id = -1;
+  if (!args_->GetInteger(0, &tab_id)) {
+    Browser* browser = GetCurrentBrowser();
+    if (!browser) {
+      error_ = kNoCurrentWindowError;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+  else {
+    Browser* browser = NULL;
+    if (!ExtensionTabUtil::GetTabById(tab_id,
+                                      profile(),
+                                      NULL,
+                                      &browser,
+                                      NULL,
+                                      NULL,
+                                      NULL)) {
+      error_ = kCouldNotIdentifyTab;
+      return false;
+    }
+    is_chromeless = browser->is_chromeless_mode();
+  }
+
+  SetResult(Value::CreateBooleanValue(is_chromeless));
+
+  return true;
+}
+
 }  // namespace extensions
--- a/src/chrome/browser/extensions/api/module/module.h
+++ b/src/chrome/browser/extensions/api/module/module.h
@@ -47,6 +47,12 @@
   virtual bool RunImpl() OVERRIDE;
 };
 
+class IsChromelessWindowFunction : public SyncExtensionFunction {
+ protected:
+  virtual bool RunImpl() OVERRIDE;
+  DECLARE_EXTENSION_FUNCTION_NAME("extension.isChromelessWindow");
+};
+
 }  // namespace extensions
 
 #endif  // CHROME_BROWSER_EXTENSIONS_API_MODULE_MODULE_H__
--- a/src/chrome/browser/sessions/session_service.cc
+++ b/src/chrome/browser/sessions/session_service.cc
@@ -1548,7 +1548,8 @@
 bool SessionService::ShouldTrackBrowser(Browser* browser) const {
   AppType app_type = browser->is_app() ? TYPE_APP : TYPE_NORMAL;
   return browser->profile() == profile() &&
-         should_track_changes_for_browser_type(browser->type(), app_type);
+         should_track_changes_for_browser_type(browser->type(), app_type) &&
+         !browser->is_chromeless_mode();
 }
 
 bool SessionService::should_track_changes_for_browser_type(Browser::Type type,
--- a/src/chrome/common/chrome_switches.cc
+++ b/src/chrome/common/chrome_switches.cc
@@ -151,6 +151,9 @@
 // Chrome Frame automation channel is closed.
 const char kChromeFrameShutdownDelay[]      = "chrome-frame-shutdown-delay";
 
+// Specifies a given URL to be opened in a chromeless mode.
+const char kChromeless[]                    = "chromeless";
+
 // Tells chrome to load the specified version of chrome.dll on Windows. If this
 // version cannot be loaded, Chrome will exit.
 const char kChromeVersion[]                 = "chrome-version";
--- a/src/chrome/common/chrome_switches.h
+++ b/src/chrome/common/chrome_switches.h
@@ -56,6 +56,7 @@
 extern const char kCheckForUpdateIntervalSec[];
 extern const char kCheckCloudPrintConnectorPolicy[];
 extern const char kChromeFrameShutdownDelay[];
+extern const char kChromeless[];
 extern const char kChromeVersion[];
 extern const char kCipherSuiteBlacklist[];
 extern const char kClearTokenService[];
--- a/src/chrome/common/extensions/api/extension.json
+++ b/src/chrome/common/extensions/api/extension.json
@@ -255,6 +255,32 @@
         }
       },
       {
+        "name": "isChromelessWindow",
+        "type": "function",
+        "unprivileged": true,
+        "description": "Checks is a given extension runs part of a chromeless window.",
+        "parameters": [
+          {
+            "type": "integer",
+            "name": "tabId",
+            "optional": true,
+            "description": "The tab id corresponding to the window to restrict the request to."
+          }
+          ,
+          {
+            "type": "function",
+            "name": "callback",
+            "parameters": [
+              {
+                "name": "isChromelessWindow",
+                "type": "boolean",
+                "description": "True if the extension runs part of a chromeless window, false otherwise."
+              }
+            ]
+          }
+        ]
+      },
+      {
         "name": "isAllowedIncognitoAccess",
         "type": "function",
         "description": "Retrieves the state of the extension's access to Incognito-mode (as determined by the user-controlled 'Allowed in Incognito' checkbox.",
--- a/src/chrome/browser/ui/browser_finder.cc
+++ b/src/chrome/browser/ui/browser_finder.cc
@@ -32,6 +32,7 @@
 const int kMatchOriginalProfile         = 1 << 0;
 const int kMatchCanSupportWindowFeature = 1 << 1;
 const int kMatchTabbed                  = 1 << 2;
+const int kMatchNonChromeless           = 1 << 3;
 
 // Returns true if the specified |browser| matches the specified arguments.
 // |match_types| is a bitmask dictating what parameters to match:
@@ -59,7 +60,11 @@
   }
 
   if (match_types & kMatchTabbed)
-    return browser->is_type_tabbed();
+    return browser->is_type_tabbed() &&
+      !browser->is_chromeless_mode();
+
+  if (match_types & kMatchNonChromeless)
+    return !browser->is_chromeless_mode();
 
   return true;
 }
@@ -88,7 +93,7 @@
       chrome::BrowserListImpl::GetInstance(desktop_type);
   if (!browser_list_impl)
     return NULL;
-  uint32 match_types = kMatchAny;
+  uint32 match_types = kMatchNonChromeless;
   if (match_tabbed)
     match_types |= kMatchTabbed;
   if (match_original_profiles)
