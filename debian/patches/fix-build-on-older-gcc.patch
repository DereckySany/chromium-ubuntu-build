Index: dev/gpu/command_buffer/service/texture_manager.cc
===================================================================
--- dev.orig/gpu/command_buffer/service/texture_manager.cc
+++ dev/gpu/command_buffer/service/texture_manager.cc
@@ -134,130 +134,130 @@ class FormatTypeValidator {
   FormatTypeValidator() {
     static const FormatType kSupportedFormatTypes[] = {
         // ES2.
-        {GL_RGB, GL_RGB, GL_UNSIGNED_BYTE},
-        {GL_RGB, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
-        {GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE},
-        {GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4},
-        {GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1},
-        {GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE},
-        {GL_LUMINANCE, GL_LUMINANCE, GL_UNSIGNED_BYTE},
-        {GL_ALPHA, GL_ALPHA, GL_UNSIGNED_BYTE},
+        std::make_tuple(GL_RGB, GL_RGB, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGB, GL_RGB, GL_UNSIGNED_SHORT_5_6_5),
+        std::make_tuple(GL_RGBA, GL_RGBA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4),
+        std::make_tuple(GL_RGBA, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1),
+        std::make_tuple(GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_LUMINANCE, GL_LUMINANCE, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_ALPHA, GL_ALPHA, GL_UNSIGNED_BYTE),
 
         // ES3.
-        {GL_R8, GL_RED, GL_UNSIGNED_BYTE},
-        {GL_R8_SNORM, GL_RED, GL_BYTE},
-        {GL_R16F, GL_RED, GL_HALF_FLOAT},
-        {GL_R16F, GL_RED, GL_FLOAT},
-        {GL_R32F, GL_RED, GL_FLOAT},
-        {GL_R8UI, GL_RED_INTEGER, GL_UNSIGNED_BYTE},
-        {GL_R8I, GL_RED_INTEGER, GL_BYTE},
-        {GL_R16UI, GL_RED_INTEGER, GL_UNSIGNED_SHORT},
-        {GL_R16I, GL_RED_INTEGER, GL_SHORT},
-        {GL_R32UI, GL_RED_INTEGER, GL_UNSIGNED_INT},
-        {GL_R32I, GL_RED_INTEGER, GL_INT},
-        {GL_RG8, GL_RG, GL_UNSIGNED_BYTE},
-        {GL_RG8_SNORM, GL_RG, GL_BYTE},
-        {GL_RG16F, GL_RG, GL_HALF_FLOAT},
-        {GL_RG16F, GL_RG, GL_FLOAT},
-        {GL_RG32F, GL_RG, GL_FLOAT},
-        {GL_RG8UI, GL_RG_INTEGER, GL_UNSIGNED_BYTE},
-        {GL_RG8I, GL_RG_INTEGER, GL_BYTE},
-        {GL_RG16UI, GL_RG_INTEGER, GL_UNSIGNED_SHORT},
-        {GL_RG16I, GL_RG_INTEGER, GL_SHORT},
-        {GL_RG32UI, GL_RG_INTEGER, GL_UNSIGNED_INT},
-        {GL_RG32I, GL_RG_INTEGER, GL_INT},
-        {GL_RGB8, GL_RGB, GL_UNSIGNED_BYTE},
-        {GL_SRGB8, GL_RGB, GL_UNSIGNED_BYTE},
-        {GL_RGB565, GL_RGB, GL_UNSIGNED_BYTE},
-        {GL_RGB565, GL_RGB, GL_UNSIGNED_SHORT_5_6_5},
-        {GL_RGB8_SNORM, GL_RGB, GL_BYTE},
-        {GL_R11F_G11F_B10F, GL_RGB, GL_UNSIGNED_INT_10F_11F_11F_REV},
-        {GL_R11F_G11F_B10F, GL_RGB, GL_HALF_FLOAT},
-        {GL_R11F_G11F_B10F, GL_RGB, GL_FLOAT},
-        {GL_RGB9_E5, GL_RGB, GL_UNSIGNED_INT_5_9_9_9_REV},
-        {GL_RGB9_E5, GL_RGB, GL_HALF_FLOAT},
-        {GL_RGB9_E5, GL_RGB, GL_FLOAT},
-        {GL_RGB16F, GL_RGB, GL_HALF_FLOAT},
-        {GL_RGB16F, GL_RGB, GL_FLOAT},
-        {GL_RGB32F, GL_RGB, GL_FLOAT},
-        {GL_RGB8UI, GL_RGB_INTEGER, GL_UNSIGNED_BYTE},
-        {GL_RGB8I, GL_RGB_INTEGER, GL_BYTE},
-        {GL_RGB16UI, GL_RGB_INTEGER, GL_UNSIGNED_SHORT},
-        {GL_RGB16I, GL_RGB_INTEGER, GL_SHORT},
-        {GL_RGB32UI, GL_RGB_INTEGER, GL_UNSIGNED_INT},
-        {GL_RGB32I, GL_RGB_INTEGER, GL_INT},
-        {GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE},
-        {GL_SRGB8_ALPHA8, GL_RGBA, GL_UNSIGNED_BYTE},
-        {GL_RGBA8_SNORM, GL_RGBA, GL_BYTE},
-        {GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_BYTE},
-        {GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1},
-        {GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV},
-        {GL_RGBA4, GL_RGBA, GL_UNSIGNED_BYTE},
-        {GL_RGBA4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4},
-        {GL_RGB10_A2, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV},
-        {GL_RGBA16F, GL_RGBA, GL_HALF_FLOAT},
-        {GL_RGBA16F, GL_RGBA, GL_FLOAT},
-        {GL_RGBA32F, GL_RGBA, GL_FLOAT},
-        {GL_RGBA8UI, GL_RGBA_INTEGER, GL_UNSIGNED_BYTE},
-        {GL_RGBA8I, GL_RGBA_INTEGER, GL_BYTE},
-        {GL_RGB10_A2UI, GL_RGBA_INTEGER, GL_UNSIGNED_INT_2_10_10_10_REV},
-        {GL_RGBA16UI, GL_RGBA_INTEGER, GL_UNSIGNED_SHORT},
-        {GL_RGBA16I, GL_RGBA_INTEGER, GL_SHORT},
-        {GL_RGBA32I, GL_RGBA_INTEGER, GL_INT},
-        {GL_RGBA32UI, GL_RGBA_INTEGER, GL_UNSIGNED_INT},
-        {GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT},
-        {GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT},
-        {GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT},
-        {GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT, GL_FLOAT},
-        {GL_DEPTH24_STENCIL8, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8},
-        {GL_DEPTH32F_STENCIL8, GL_DEPTH_STENCIL,
-         GL_FLOAT_32_UNSIGNED_INT_24_8_REV},
+        std::make_tuple(GL_R8, GL_RED, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_R8_SNORM, GL_RED, GL_BYTE),
+        std::make_tuple(GL_R16F, GL_RED, GL_HALF_FLOAT),
+        std::make_tuple(GL_R16F, GL_RED, GL_FLOAT),
+        std::make_tuple(GL_R32F, GL_RED, GL_FLOAT),
+        std::make_tuple(GL_R8UI, GL_RED_INTEGER, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_R8I, GL_RED_INTEGER, GL_BYTE),
+        std::make_tuple(GL_R16UI, GL_RED_INTEGER, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_R16I, GL_RED_INTEGER, GL_SHORT),
+        std::make_tuple(GL_R32UI, GL_RED_INTEGER, GL_UNSIGNED_INT),
+        std::make_tuple(GL_R32I, GL_RED_INTEGER, GL_INT),
+        std::make_tuple(GL_RG8, GL_RG, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RG8_SNORM, GL_RG, GL_BYTE),
+        std::make_tuple(GL_RG16F, GL_RG, GL_HALF_FLOAT),
+        std::make_tuple(GL_RG16F, GL_RG, GL_FLOAT),
+        std::make_tuple(GL_RG32F, GL_RG, GL_FLOAT),
+        std::make_tuple(GL_RG8UI, GL_RG_INTEGER, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RG8I, GL_RG_INTEGER, GL_BYTE),
+        std::make_tuple(GL_RG16UI, GL_RG_INTEGER, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_RG16I, GL_RG_INTEGER, GL_SHORT),
+        std::make_tuple(GL_RG32UI, GL_RG_INTEGER, GL_UNSIGNED_INT),
+        std::make_tuple(GL_RG32I, GL_RG_INTEGER, GL_INT),
+        std::make_tuple(GL_RGB8, GL_RGB, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_SRGB8, GL_RGB, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGB565, GL_RGB, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGB565, GL_RGB, GL_UNSIGNED_SHORT_5_6_5),
+        std::make_tuple(GL_RGB8_SNORM, GL_RGB, GL_BYTE),
+        std::make_tuple(GL_R11F_G11F_B10F, GL_RGB, GL_UNSIGNED_INT_10F_11F_11F_REV),
+        std::make_tuple(GL_R11F_G11F_B10F, GL_RGB, GL_HALF_FLOAT),
+        std::make_tuple(GL_R11F_G11F_B10F, GL_RGB, GL_FLOAT),
+        std::make_tuple(GL_RGB9_E5, GL_RGB, GL_UNSIGNED_INT_5_9_9_9_REV),
+        std::make_tuple(GL_RGB9_E5, GL_RGB, GL_HALF_FLOAT),
+        std::make_tuple(GL_RGB9_E5, GL_RGB, GL_FLOAT),
+        std::make_tuple(GL_RGB16F, GL_RGB, GL_HALF_FLOAT),
+        std::make_tuple(GL_RGB16F, GL_RGB, GL_FLOAT),
+        std::make_tuple(GL_RGB32F, GL_RGB, GL_FLOAT),
+        std::make_tuple(GL_RGB8UI, GL_RGB_INTEGER, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGB8I, GL_RGB_INTEGER, GL_BYTE),
+        std::make_tuple(GL_RGB16UI, GL_RGB_INTEGER, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_RGB16I, GL_RGB_INTEGER, GL_SHORT),
+        std::make_tuple(GL_RGB32UI, GL_RGB_INTEGER, GL_UNSIGNED_INT),
+        std::make_tuple(GL_RGB32I, GL_RGB_INTEGER, GL_INT),
+        std::make_tuple(GL_RGBA8, GL_RGBA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_SRGB8_ALPHA8, GL_RGBA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGBA8_SNORM, GL_RGBA, GL_BYTE),
+        std::make_tuple(GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_SHORT_5_5_5_1),
+        std::make_tuple(GL_RGB5_A1, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV),
+        std::make_tuple(GL_RGBA4, GL_RGBA, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGBA4, GL_RGBA, GL_UNSIGNED_SHORT_4_4_4_4),
+        std::make_tuple(GL_RGB10_A2, GL_RGBA, GL_UNSIGNED_INT_2_10_10_10_REV),
+        std::make_tuple(GL_RGBA16F, GL_RGBA, GL_HALF_FLOAT),
+        std::make_tuple(GL_RGBA16F, GL_RGBA, GL_FLOAT),
+        std::make_tuple(GL_RGBA32F, GL_RGBA, GL_FLOAT),
+        std::make_tuple(GL_RGBA8UI, GL_RGBA_INTEGER, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RGBA8I, GL_RGBA_INTEGER, GL_BYTE),
+        std::make_tuple(GL_RGB10_A2UI, GL_RGBA_INTEGER, GL_UNSIGNED_INT_2_10_10_10_REV),
+        std::make_tuple(GL_RGBA16UI, GL_RGBA_INTEGER, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_RGBA16I, GL_RGBA_INTEGER, GL_SHORT),
+        std::make_tuple(GL_RGBA32I, GL_RGBA_INTEGER, GL_INT),
+        std::make_tuple(GL_RGBA32UI, GL_RGBA_INTEGER, GL_UNSIGNED_INT),
+        std::make_tuple(GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_DEPTH_COMPONENT16, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT),
+        std::make_tuple(GL_DEPTH_COMPONENT24, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT),
+        std::make_tuple(GL_DEPTH_COMPONENT32F, GL_DEPTH_COMPONENT, GL_FLOAT),
+        std::make_tuple(GL_DEPTH24_STENCIL8, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8),
+        std::make_tuple(GL_DEPTH32F_STENCIL8, GL_DEPTH_STENCIL,
+         GL_FLOAT_32_UNSIGNED_INT_24_8_REV),
 
         // Exposed by GL_APPLE_texture_format_BGRA8888 for TexStorage*
         // TODO(kainino): this actually exposes it for (Copy)TexImage* as well,
         // which is incorrect. crbug.com/663086
-        {GL_BGRA8_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE},
+        std::make_tuple(GL_BGRA8_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE),
 
         // Exposed by GL_APPLE_texture_format_BGRA8888 and
         // GL_EXT_texture_format_BGRA8888
-        {GL_BGRA_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE},
+        std::make_tuple(GL_BGRA_EXT, GL_BGRA_EXT, GL_UNSIGNED_BYTE),
 
         // Exposed by GL_EXT_texture_norm16
-        {GL_R16_EXT, GL_RED, GL_UNSIGNED_SHORT},
+        std::make_tuple(GL_R16_EXT, GL_RED, GL_UNSIGNED_SHORT),
     };
 
     static const FormatType kSupportedFormatTypesES2Only[] = {
         // Exposed by GL_OES_texture_float and GL_OES_texture_half_float
-        {GL_RGB, GL_RGB, GL_FLOAT},
-        {GL_RGBA, GL_RGBA, GL_FLOAT},
-        {GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_FLOAT},
-        {GL_LUMINANCE, GL_LUMINANCE, GL_FLOAT},
-        {GL_ALPHA, GL_ALPHA, GL_FLOAT},
-        {GL_RGB, GL_RGB, GL_HALF_FLOAT_OES},
-        {GL_RGBA, GL_RGBA, GL_HALF_FLOAT_OES},
-        {GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_HALF_FLOAT_OES},
-        {GL_LUMINANCE, GL_LUMINANCE, GL_HALF_FLOAT_OES},
-        {GL_ALPHA, GL_ALPHA, GL_HALF_FLOAT_OES},
+        std::make_tuple(GL_RGB, GL_RGB, GL_FLOAT),
+        std::make_tuple(GL_RGBA, GL_RGBA, GL_FLOAT),
+        std::make_tuple(GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_FLOAT),
+        std::make_tuple(GL_LUMINANCE, GL_LUMINANCE, GL_FLOAT),
+        std::make_tuple(GL_ALPHA, GL_ALPHA, GL_FLOAT),
+        std::make_tuple(GL_RGB, GL_RGB, GL_HALF_FLOAT_OES),
+        std::make_tuple(GL_RGBA, GL_RGBA, GL_HALF_FLOAT_OES),
+        std::make_tuple(GL_LUMINANCE_ALPHA, GL_LUMINANCE_ALPHA, GL_HALF_FLOAT_OES),
+        std::make_tuple(GL_LUMINANCE, GL_LUMINANCE, GL_HALF_FLOAT_OES),
+        std::make_tuple(GL_ALPHA, GL_ALPHA, GL_HALF_FLOAT_OES),
 
         // Exposed by GL_ANGLE_depth_texture
-        {GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT},
-        {GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT},
-        {GL_DEPTH_STENCIL, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8},
+        std::make_tuple(GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT, GL_UNSIGNED_SHORT),
+        std::make_tuple(GL_DEPTH_COMPONENT, GL_DEPTH_COMPONENT, GL_UNSIGNED_INT),
+        std::make_tuple(GL_DEPTH_STENCIL, GL_DEPTH_STENCIL, GL_UNSIGNED_INT_24_8),
 
         // Exposed by GL_EXT_sRGB
-        {GL_SRGB, GL_SRGB, GL_UNSIGNED_BYTE},
-        {GL_SRGB_ALPHA, GL_SRGB_ALPHA, GL_UNSIGNED_BYTE},
+        std::make_tuple(GL_SRGB, GL_SRGB, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_SRGB_ALPHA, GL_SRGB_ALPHA, GL_UNSIGNED_BYTE),
 
         // Exposed by GL_EXT_texture_rg
-        {GL_RED, GL_RED, GL_UNSIGNED_BYTE},
-        {GL_RG, GL_RG, GL_UNSIGNED_BYTE},
-        {GL_RED, GL_RED, GL_FLOAT},
-        {GL_RG, GL_RG, GL_FLOAT},
-        {GL_RED, GL_RED, GL_HALF_FLOAT_OES},
-        {GL_RG, GL_RG, GL_HALF_FLOAT_OES},
+        std::make_tuple(GL_RED, GL_RED, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RG, GL_RG, GL_UNSIGNED_BYTE),
+        std::make_tuple(GL_RED, GL_RED, GL_FLOAT),
+        std::make_tuple(GL_RG, GL_RG, GL_FLOAT),
+        std::make_tuple(GL_RED, GL_RED, GL_HALF_FLOAT_OES),
+        std::make_tuple(GL_RG, GL_RG, GL_HALF_FLOAT_OES),
 
         // Exposed by GL_EXT_texture_norm16
-        {GL_RED, GL_RED, GL_UNSIGNED_SHORT},
+        std::make_tuple(GL_RED, GL_RED, GL_UNSIGNED_SHORT),
     };
 
     for (size_t ii = 0; ii < base::size(kSupportedFormatTypes); ++ii) {
@@ -272,7 +272,7 @@ class FormatTypeValidator {
   // This may be accessed from multiple threads.
   bool IsValid(ContextType context_type, GLenum internal_format, GLenum format,
                GLenum type) const {
-    FormatType query = { internal_format, format, type };
+    FormatType query = std::make_tuple(internal_format, format, type);
     if (supported_combinations_.find(query) != supported_combinations_.end()) {
       return true;
     }
Index: dev/chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
===================================================================
--- dev.orig/chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
+++ dev/chrome/browser/media/router/providers/wired_display/wired_display_media_route_provider.cc
@@ -130,8 +130,10 @@ void WiredDisplayMediaRouteProvider::Cre
   route.set_incognito(profile_->IsOffTheRecord());
   route.set_controller_type(RouteControllerType::kGeneric);
 
+  Presentation new_presentation(route);
+
   Presentation& presentation =
-      presentations_.emplace(presentation_id, route).first->second;
+      presentations_.emplace(presentation_id, std::move(new_presentation)).first->second;
   presentation.set_receiver(
       CreatePresentationReceiver(presentation_id, &presentation, *display));
   presentation.receiver()->Start(presentation_id, GURL(media_source));
Index: dev/extensions/common/api/web_request.json
===================================================================
--- dev.orig/extensions/common/api/web_request.json
+++ dev/extensions/common/api/web_request.json
@@ -204,8 +204,7 @@
                     "description": "If the request method is POST and the body is a sequence of key-value pairs encoded in UTF8, encoded as either multipart/form-data, or application/x-www-form-urlencoded, this dictionary is present and for each key contains the list of all values for that key. If the data is of another media type, or if it is malformed, the dictionary is not present. An example value of this dictionary is {'key': ['value1', 'value2']}.",
                     "properties": {},
                     "additionalProperties": {
-                      "type": "array",
-                      "items": { "$ref": "FormDataItem" }
+                      "type": "any"
                     }
                   },
                   "raw" : {
Index: dev/media/base/subsample_entry.h
===================================================================
--- dev.orig/media/base/subsample_entry.h
+++ dev/media/base/subsample_entry.h
@@ -36,7 +36,7 @@ struct SubsampleEntry {
 // does not match |input_size|.
 MEDIA_EXPORT bool VerifySubsamplesMatchSize(
     const std::vector<SubsampleEntry>& subsamples,
-    size_t input_size);
+    std::size_t input_size);
 
 }  // namespace media
 
Index: dev/device/bluetooth/dbus/bluetooth_gatt_attribute_helpers.cc
===================================================================
--- dev.orig/device/bluetooth/dbus/bluetooth_gatt_attribute_helpers.cc
+++ dev/device/bluetooth/dbus/bluetooth_gatt_attribute_helpers.cc
@@ -27,8 +27,9 @@ bool ReadOptions(dbus::MessageReader* re
       return false;
     }
 
-    options->emplace(key, nullptr);
-    if (!dict_entry_reader.PopVariant(&options->at(key))) {
+    auto options_iterator = options->find(key);
+    if (options_iterator != options->end() &&
+            !dict_entry_reader.PopVariant(&options_iterator->second)) {
       options->clear();
       return false;
     }
Index: dev/cc/trees/layer_tree_mutator.cc
===================================================================
--- dev.orig/cc/trees/layer_tree_mutator.cc
+++ dev/cc/trees/layer_tree_mutator.cc
@@ -58,8 +58,9 @@ bool MutatorInputState::IsEmpty() const
 
 AnimationWorkletInput& MutatorInputState::EnsureWorkletEntry(int id) {
   auto it = inputs_.find(id);
+  std::unique_ptr<AnimationWorkletInput> temp(new AnimationWorkletInput);
   if (it == inputs_.end())
-    it = inputs_.emplace_hint(it, id, new AnimationWorkletInput);
+    it = inputs_.emplace_hint(it, id, std::move(temp));
 
   return *it->second;
 }
Index: dev/device/fido/authenticator_get_assertion_response.cc
===================================================================
--- dev.orig/device/fido/authenticator_get_assertion_response.cc
+++ dev/device/fido/authenticator_get_assertion_response.cc
@@ -101,16 +101,16 @@ std::vector<uint8_t> GetSerializedCtapDe
     const AuthenticatorGetAssertionResponse& response) {
   cbor::Value::MapValue response_map;
   if (response.credential())
-    response_map.emplace(1, response.credential()->ConvertToCBOR());
+    response_map.emplace(cbor::Value(1), response.credential()->ConvertToCBOR());
 
-  response_map.emplace(2, response.auth_data().SerializeToByteArray());
-  response_map.emplace(3, response.signature());
+  response_map.emplace(cbor::Value(2), cbor::Value(response.auth_data().SerializeToByteArray()));
+  response_map.emplace(cbor::Value(3), cbor::Value(std::move(response.signature())));
 
   if (response.user_entity())
-    response_map.emplace(4, response.user_entity()->ConvertToCBOR());
+    response_map.emplace(cbor::Value(4), response.user_entity()->ConvertToCBOR());
 
   // Multiple account selection is not supported.
-  response_map.emplace(5, 1);
+  response_map.emplace(cbor::Value(5), cbor::Value(1));
   auto encoded_response =
       cbor::Writer::Write(cbor::Value(std::move(response_map)));
   DCHECK(encoded_response);
Index: dev/device/fido/authenticator_supported_options.cc
===================================================================
--- dev.orig/device/fido/authenticator_supported_options.cc
+++ dev/device/fido/authenticator_supported_options.cc
@@ -19,19 +19,19 @@ AuthenticatorSupportedOptions::~Authenti
 
 cbor::Value ConvertToCBOR(const AuthenticatorSupportedOptions& options) {
   cbor::Value::MapValue option_map;
-  option_map.emplace(kResidentKeyMapKey, options.supports_resident_key);
-  option_map.emplace(kUserPresenceMapKey, options.supports_user_presence);
-  option_map.emplace(kPlatformDeviceMapKey, options.is_platform_device);
+  option_map.emplace(cbor::Value(kResidentKeyMapKey), cbor::Value(options.supports_resident_key));
+  option_map.emplace(cbor::Value(kUserPresenceMapKey), cbor::Value(options.supports_user_presence));
+  option_map.emplace(cbor::Value(kPlatformDeviceMapKey), cbor::Value(options.is_platform_device));
 
   using UvAvailability =
       AuthenticatorSupportedOptions::UserVerificationAvailability;
 
   switch (options.user_verification_availability) {
     case UvAvailability::kSupportedAndConfigured:
-      option_map.emplace(kUserVerificationMapKey, true);
+      option_map.emplace(cbor::Value(kUserVerificationMapKey), cbor::Value(true));
       break;
     case UvAvailability::kSupportedButNotConfigured:
-      option_map.emplace(kUserVerificationMapKey, false);
+      option_map.emplace(cbor::Value(kUserVerificationMapKey), cbor::Value(false));
       break;
     case UvAvailability::kNotSupported:
       break;
@@ -42,10 +42,10 @@ cbor::Value ConvertToCBOR(const Authenti
 
   switch (options.client_pin_availability) {
     case ClientPinAvailability::kSupportedAndPinSet:
-      option_map.emplace(kClientPinMapKey, true);
+      option_map.emplace(cbor::Value(kClientPinMapKey), cbor::Value(true));
       break;
     case ClientPinAvailability::kSupportedButPinNotSet:
-      option_map.emplace(kClientPinMapKey, false);
+      option_map.emplace(cbor::Value(kClientPinMapKey), cbor::Value(false));
       break;
     case ClientPinAvailability::kNotSupported:
       break;
Index: dev/device/fido/attestation_object.cc
===================================================================
--- dev.orig/device/fido/attestation_object.cc
+++ dev/device/fido/attestation_object.cc
@@ -78,9 +78,9 @@ std::vector<uint8_t> AttestationObject::
 std::vector<uint8_t> SerializeToCtapStyleCborEncodedBytes(
     const AttestationObject& object) {
   cbor::Value::MapValue map;
-  map.emplace(1, object.attestation_statement().format_name());
-  map.emplace(2, object.authenticator_data().SerializeToByteArray());
-  map.emplace(3, object.attestation_statement().GetAsCBORMap());
+  map.emplace(cbor::Value(1), cbor::Value(object.attestation_statement().format_name()));
+  map.emplace(cbor::Value(2), cbor::Value(object.authenticator_data().SerializeToByteArray()));
+  map.emplace(cbor::Value(3), cbor::Value(object.attestation_statement().GetAsCBORMap()));
   auto encoded_bytes = cbor::Writer::Write(cbor::Value(std::move(map)));
   DCHECK(encoded_bytes);
   return std::move(*encoded_bytes);
Index: dev/device/fido/authenticator_get_info_response.cc
===================================================================
--- dev.orig/device/fido/authenticator_get_info_response.cc
+++ dev/device/fido/authenticator_get_info_response.cc
@@ -71,21 +71,21 @@ std::vector<uint8_t> EncodeToCBOR(
                                                                  : kU2fVersion);
   }
   cbor::Value::MapValue device_info_map;
-  device_info_map.emplace(1, std::move(version_array));
+  device_info_map.emplace(cbor::Value(1), cbor::Value(std::move(version_array)));
 
   if (response.extensions())
-    device_info_map.emplace(2, ToArrayValue(*response.extensions()));
+    device_info_map.emplace(cbor::Value(2), cbor::Value(ToArrayValue(*response.extensions())));
 
-  device_info_map.emplace(3, response.aaguid());
-  device_info_map.emplace(4, ConvertToCBOR(response.options()));
+  device_info_map.emplace(cbor::Value(3), cbor::Value(response.aaguid()));
+  device_info_map.emplace(cbor::Value(4), ConvertToCBOR(response.options()));
 
   if (response.max_msg_size()) {
     device_info_map.emplace(
-        5, base::strict_cast<int64_t>(*response.max_msg_size()));
+        cbor::Value(5), cbor::Value(base::strict_cast<int64_t>(*response.max_msg_size())));
   }
 
   if (response.pin_protocol()) {
-    device_info_map.emplace(6, ToArrayValue(*response.pin_protocol()));
+    device_info_map.emplace(cbor::Value(6), cbor::Value(ToArrayValue(*response.pin_protocol())));
   }
 
   auto encoded_bytes =
Index: dev/device/fido/public_key_credential_rp_entity.cc
===================================================================
--- dev.orig/device/fido/public_key_credential_rp_entity.cc
+++ dev/device/fido/public_key_credential_rp_entity.cc
@@ -78,12 +78,12 @@ PublicKeyCredentialRpEntity& PublicKeyCr
 
 cbor::Value PublicKeyCredentialRpEntity::ConvertToCBOR() const {
   cbor::Value::MapValue rp_map;
-  rp_map.emplace(kEntityIdMapKey, rp_id_);
+  rp_map.emplace(cbor::Value(kEntityIdMapKey), cbor::Value(rp_id_));
   if (rp_name_)
-    rp_map.emplace(kEntityNameMapKey, *rp_name_);
+    rp_map.emplace(cbor::Value(kEntityNameMapKey), cbor::Value(*rp_name_));
 
   if (rp_icon_url_)
-    rp_map.emplace(kIconUrlMapKey, rp_icon_url_->spec());
+    rp_map.emplace(cbor::Value(kIconUrlMapKey), cbor::Value(rp_icon_url_->spec()));
 
   return cbor::Value(std::move(rp_map));
 }
Index: dev/device/fido/public_key_credential_user_entity.cc
===================================================================
--- dev.orig/device/fido/public_key_credential_user_entity.cc
+++ dev/device/fido/public_key_credential_user_entity.cc
@@ -63,13 +63,13 @@ PublicKeyCredentialUserEntity::~PublicKe
 
 cbor::Value PublicKeyCredentialUserEntity::ConvertToCBOR() const {
   cbor::Value::MapValue user_map;
-  user_map.emplace(kEntityIdMapKey, user_id_);
+  user_map.emplace(cbor::Value(kEntityIdMapKey), cbor::Value(user_id_));
   if (user_name_)
-    user_map.emplace(kEntityNameMapKey, *user_name_);
+    user_map.emplace(cbor::Value(kEntityNameMapKey), cbor::Value(*user_name_));
   if (user_icon_url_)
-    user_map.emplace(kIconUrlMapKey, user_icon_url_->spec());
+    user_map.emplace(cbor::Value(kIconUrlMapKey), cbor::Value(user_icon_url_->spec()));
   if (user_display_name_) {
-    user_map.emplace(kDisplayNameMapKey, *user_display_name_);
+    user_map.emplace(cbor::Value(kDisplayNameMapKey), cbor::Value(*user_display_name_));
   }
   return cbor::Value(std::move(user_map));
 }
Index: dev/device/fido/public_key_credential_params.cc
===================================================================
--- dev.orig/device/fido/public_key_credential_params.cc
+++ dev/device/fido/public_key_credential_params.cc
@@ -64,10 +64,10 @@ cbor::Value PublicKeyCredentialParams::C
 
   for (const auto& credential : public_key_credential_params_) {
     cbor::Value::MapValue cbor_credential_map;
-    cbor_credential_map.emplace(kCredentialTypeMapKey,
-                                CredentialTypeToString(credential.type));
-    cbor_credential_map.emplace(kCredentialAlgorithmMapKey,
-                                credential.algorithm);
+    cbor_credential_map.emplace(cbor::Value(kCredentialTypeMapKey),
+                                cbor::Value(CredentialTypeToString(credential.type)));
+    cbor_credential_map.emplace(cbor::Value(kCredentialAlgorithmMapKey),
+                                cbor::Value(credential.algorithm));
     credential_param_array.emplace_back(std::move(cbor_credential_map));
   }
   return cbor::Value(std::move(credential_param_array));
Index: dev/device/fido/virtual_ctap2_device.cc
===================================================================
--- dev.orig/device/fido/virtual_ctap2_device.cc
+++ dev/device/fido/virtual_ctap2_device.cc
@@ -210,13 +210,13 @@ std::vector<uint8_t> ConstructMakeCreden
     base::span<const uint8_t> signature,
     AuthenticatorData authenticator_data) {
   cbor::Value::MapValue attestation_map;
-  attestation_map.emplace("alg", -7);
-  attestation_map.emplace("sig", fido_parsing_utils::Materialize(signature));
+  attestation_map.emplace(cbor::Value("alg"), cbor::Value(-7));
+  attestation_map.emplace(cbor::Value("sig"), cbor::Value(fido_parsing_utils::Materialize(signature)));
 
   if (attestation_certificate) {
     cbor::Value::ArrayValue certificate_chain;
     certificate_chain.emplace_back(std::move(*attestation_certificate));
-    attestation_map.emplace("x5c", std::move(certificate_chain));
+    attestation_map.emplace(cbor::Value("x5c"), cbor::Value(std::move(certificate_chain)));
   }
 
   AuthenticatorMakeCredentialResponse make_credential_response(
Index: dev/device/fido/hid/fido_hid_device.cc
===================================================================
--- dev.orig/device/fido/hid/fido_hid_device.cc
+++ dev/device/fido/hid/fido_hid_device.cc
@@ -51,7 +51,7 @@ void FidoHidDevice::Cancel() {
     return;
 
   state_ = State::kReady;
-  pending_transactions_ = {};
+  pending_transactions_ = base::queue<std::pair<std::vector<uint8_t>, DeviceCallback>>();
   timeout_callback_.Cancel();
 
   WriteMessage(
Index: dev/device/fido/cable/fido_cable_handshake_handler.cc
===================================================================
--- dev.orig/device/fido/cable/fido_cable_handshake_handler.cc
+++ dev/device/fido/cable/fido_cable_handshake_handler.cc
@@ -46,8 +46,8 @@ base::Optional<std::array<uint8_t, kClie
 ConstructHandshakeMessage(base::StringPiece handshake_key,
                           base::span<const uint8_t, 16> client_random_nonce) {
   cbor::Value::MapValue map;
-  map.emplace(0, kCableClientHelloMessage);
-  map.emplace(1, client_random_nonce);
+  map.emplace(cbor::Value(0), cbor::Value(kCableClientHelloMessage));
+  map.emplace(cbor::Value(1), cbor::Value(client_random_nonce));
   auto client_hello = cbor::Writer::Write(cbor::Value(std::move(map)));
   DCHECK(client_hello);
 
Index: dev/components/password_manager/core/browser/http_credentials_cleaner.cc
===================================================================
--- dev.orig/components/password_manager/core/browser/http_credentials_cleaner.cc
+++ dev/components/password_manager/core/browser/http_credentials_cleaner.cc
@@ -44,9 +44,9 @@ void HttpCredentialCleaner::OnGetPasswor
   // federated credentials.
   for (auto& form : RemoveNonHTTPOrHTTPSForms(std::move(results))) {
     FormKey form_key(
-        {std::string(
+        std::make_tuple(std::string(
              password_manager_util::GetSignonRealmWithProtocolExcluded(*form)),
-         form->scheme, form->username_value});
+         form->scheme, form->username_value));
     if (form->origin.SchemeIs(url::kHttpScheme)) {
       const GURL origin = form->origin;
       PostHSTSQueryForHostAndNetworkContext(
Index: dev/extensions/common/permissions/permissions_info.h
===================================================================
--- dev.orig/extensions/common/permissions/permissions_info.h
+++ dev/extensions/common/permissions/permissions_info.h
@@ -21,6 +21,18 @@
 #include "extensions/common/permissions/api_permission.h"
 #include "extensions/common/permissions/api_permission_set.h"
 
+namespace std {
+	template<> class hash<extensions::APIPermission::ID> {
+		typedef extensions::APIPermission::ID argument_type;
+
+		public:
+		size_t operator()(const argument_type& e) const {
+			using type = typename std::underlying_type<argument_type>::type;
+			return std::hash<type>()(static_cast<type>(e));
+		}
+	};
+};
+
 namespace extensions {
 
 struct Alias;
Index: dev/components/ukm/ukm_recorder_impl.h
===================================================================
--- dev.orig/components/ukm/ukm_recorder_impl.h
+++ dev/components/ukm/ukm_recorder_impl.h
@@ -25,6 +25,18 @@ class UkmBrowserTestBase;
 class UkmEGTestHelper;
 }
 
+namespace std {
+	template<> class hash<ukm::SourceIdType> {
+		typedef ukm::SourceIdType argument_type;
+
+		public:
+		size_t operator()(const argument_type& e) const {
+			using type = typename std::underlying_type<argument_type>::type;
+			return std::hash<type>()(static_cast<type>(e));
+		}
+	};
+};
+
 namespace ukm {
 class Report;
 class UkmRecorderImplTest;
Index: dev/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
+++ dev/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
@@ -62,9 +62,12 @@ static bool VerifyDataSize(const VAImage
   const gfx::Size dimensions(base::strict_cast<int>(image->width),
                              base::strict_cast<int>(image->height));
   size_t min_size = 0;
+#ifdef VA_FOURCC_I420
   if (image->format.fourcc == VA_FOURCC_I420) {
     min_size = VideoFrame::AllocationSize(PIXEL_FORMAT_I420, dimensions);
-  } else if (image->format.fourcc == VA_FOURCC_YUY2 ||
+  } else
+#endif
+	  if (image->format.fourcc == VA_FOURCC_YUY2 ||
              image->format.fourcc == VA_FOURCC('Y', 'U', 'Y', 'V')) {
     min_size = VideoFrame::AllocationSize(PIXEL_FORMAT_YUY2, dimensions);
   } else {
@@ -155,6 +158,7 @@ bool VaapiJpegDecodeAccelerator::OutputP
   size_t dst_v_stride = video_frame->stride(VideoFrame::kVPlane);
 
   switch (image->format.fourcc) {
+#ifdef VA_FOURCC_I420
     case VA_FOURCC_I420: {
       DCHECK_EQ(image->num_planes, 3u);
       const uint8_t* src_y = mem + image->offsets[0];
@@ -173,6 +177,7 @@ bool VaapiJpegDecodeAccelerator::OutputP
       }
       break;
     }
+#endif
     case VA_FOURCC_YUY2:
     case VA_FOURCC('Y', 'U', 'Y', 'V'): {
       DCHECK_EQ(image->num_planes, 1u);
Index: dev/components/viz/service/frame_sinks/frame_sink_manager_impl.cc
===================================================================
--- dev.orig/components/viz/service/frame_sinks/frame_sink_manager_impl.cc
+++ dev/components/viz/service/frame_sinks/frame_sink_manager_impl.cc
@@ -100,7 +100,7 @@ void FrameSinkManagerImpl::RegisterFrame
   DCHECK_CALLED_ON_VALID_THREAD(thread_checker_);
   DCHECK(!base::ContainsKey(frame_sink_data_, frame_sink_id));
 
-  frame_sink_data_.emplace(std::make_pair(frame_sink_id, report_activation));
+  frame_sink_data_.emplace(std::make_pair(frame_sink_id, FrameSinkData(report_activation)));
 
   if (video_detector_)
     video_detector_->OnFrameSinkIdRegistered(frame_sink_id);
Index: dev/third_party/blink/renderer/platform/heap/gc_info.cc
===================================================================
--- dev.orig/third_party/blink/renderer/platform/heap/gc_info.cc
+++ dev/third_party/blink/renderer/platform/heap/gc_info.cc
@@ -51,7 +51,7 @@ void GCInfoTable::CreateGlobalTable() {
 
 uint32_t GCInfoTable::EnsureGCInfoIndex(
     const GCInfo* gc_info,
-    std::atomic_uint32_t* gc_info_index_slot) {
+    std::atomic<uint32_t>* gc_info_index_slot) {
   DCHECK(gc_info);
   DCHECK(gc_info_index_slot);
 
Index: dev/third_party/blink/renderer/platform/heap/gc_info.h
===================================================================
--- dev.orig/third_party/blink/renderer/platform/heap/gc_info.h
+++ dev/third_party/blink/renderer/platform/heap/gc_info.h
@@ -63,7 +63,7 @@ class PLATFORM_EXPORT GCInfoTable {
     return info;
   }
 
-  uint32_t EnsureGCInfoIndex(const GCInfo*, std::atomic_uint32_t*);
+  uint32_t EnsureGCInfoIndex(const GCInfo*, std::atomic<uint32_t>*);
 
   uint32_t GcInfoIndex() const { return current_index_; }
 
@@ -107,7 +107,7 @@ struct GCInfoAtBaseType {
         std::is_polymorphic<T>::value};
     // This is more complicated than using threadsafe initialization, but this
     // is instantiated many times (once for every GC type).
-    static std::atomic_uint32_t gc_info_index{0};
+    static std::atomic<uint32_t> gc_info_index{0};
     uint32_t index = gc_info_index.load(std::memory_order_acquire);
     if (!index)
       index = GCInfoTable::Get().EnsureGCInfoIndex(&kGcInfo, &gc_info_index);
Index: dev/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
===================================================================
--- dev.orig/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
+++ dev/chrome/browser/background_fetch/background_fetch_delegate_impl.cc
@@ -374,7 +374,7 @@ void BackgroundFetchDelegateImpl::StartD
   DCHECK(job_details_map_.count(job_unique_id));
   JobDetails& job_details = job_details_map_.find(job_unique_id)->second;
 
-  job_details.current_fetch_guids.emplace(params.guid, has_request_body);
+  job_details.current_fetch_guids.emplace(std::piecewise_construct, std::forward_as_tuple(params.guid), std::forward_as_tuple(has_request_body));
   GetDownloadService()->StartDownload(params);
 }
 
Index: dev/components/page_image_annotation/core/page_annotator.cc
===================================================================
--- dev.orig/components/page_image_annotation/core/page_annotator.cc
+++ dev/components/page_image_annotation/core/page_annotator.cc
@@ -78,7 +78,9 @@ void PageAnnotator::AddNewImage(
     base::RepeatingCallback<SkBitmap()> pixels_callback) {
   images_.emplace(std::piecewise_construct,
                   std::forward_as_tuple(metadata.node_id),
-                  std::forward_as_tuple(metadata, std::move(pixels_callback)));
+                  std::forward_as_tuple(std::piecewise_construct,
+                      std::forward_as_tuple(metadata),
+                      std::forward_as_tuple(std::move(pixels_callback))));
 }
 
 void PageAnnotator::NotifyObserver(Observer* const observer,
Index: dev/third_party/angle/src/libANGLE/renderer/vulkan/vk_cache_utils.cpp
===================================================================
--- dev.orig/third_party/angle/src/libANGLE/renderer/vulkan/vk_cache_utils.cpp
+++ dev/third_party/angle/src/libANGLE/renderer/vulkan/vk_cache_utils.cpp
@@ -1361,7 +1361,7 @@ angle::Result GraphicsPipelineCache::ins
     }
 
     // The Serial will be updated outside of this query.
-    auto insertedItem = mPayload.emplace(desc, std::move(newPipeline));
+    auto insertedItem = mPayload.emplace(std::piecewise_construct, std::forward_as_tuple(desc), std::forward_as_tuple(std::move(newPipeline)));
     *descPtrOut       = &insertedItem.first->first;
     *pipelineOut      = &insertedItem.first->second;
 
@@ -1376,7 +1376,7 @@ void GraphicsPipelineCache::populate(con
         return;
     }
 
-    mPayload.emplace(desc, std::move(pipeline));
+    mPayload.emplace(std::piecewise_construct, std::forward_as_tuple(desc), std::forward_as_tuple(std::move(pipeline)));
 }
 
 // DescriptorSetLayoutCache implementation.
Index: dev/media/gpu/vaapi/vaapi_jpeg_decoder.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_jpeg_decoder.cc
+++ dev/media/gpu/vaapi/vaapi_jpeg_decoder.cc
@@ -23,11 +23,13 @@ namespace media {
 
 namespace {
 
+#ifdef VA_FOURCC_I420
 constexpr VAImageFormat kImageFormatI420 = {
     .fourcc = VA_FOURCC_I420,
     .byte_order = VA_LSB_FIRST,
     .bits_per_pixel = 12,
 };
+#endif
 
 constexpr VAImageFormat kImageFormatYUYV = {
     .fourcc = VA_FOURCC('Y', 'U', 'Y', 'V'),
@@ -201,9 +203,11 @@ static bool IsVaapiSupportedJpeg(const J
 static bool VaSurfaceFormatToImageFormat(unsigned int va_rt_format,
                                          VAImageFormat* va_image_format) {
   switch (va_rt_format) {
+#ifdef VA_FOURCC_I420
     case VA_RT_FORMAT_YUV420:
       *va_image_format = kImageFormatI420;
       return true;
+#endif
     case VA_RT_FORMAT_YUV422:
       *va_image_format = kImageFormatYUYV;
       return true;
@@ -376,6 +380,7 @@ std::unique_ptr<ScopedVAImage> VaapiJpeg
     return nullptr;
   }
 
+#ifdef VA_FOURCC_I420
   // Specify which image format we will request from the VAAPI. As the expected
   // output format is I420, we will first try this format. If converting to I420
   // is not supported by the decoder, we will request the image in its original
@@ -387,6 +392,14 @@ std::unique_ptr<ScopedVAImage> VaapiJpeg
     *status = VaapiJpegDecodeStatus::kUnsupportedSurfaceFormat;
     return nullptr;
   }
+#else
+  VAImageFormat va_image_format;
+  if (!VaSurfaceFormatToImageFormat(va_surface_format, &va_image_format)) {
+    VLOGF(1) << "Unsupported surface format";
+    *status = VaapiJpegDecodeStatus::kUnsupportedSurfaceFormat;
+    return nullptr;
+  }
+#endif
 
   auto scoped_image = vaapi_wrapper_->CreateVaImage(
       va_surface_id_, &va_image_format, coded_size_);
Index: dev/media/gpu/vaapi/vaapi_video_encode_accelerator.h
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.h
+++ dev/media/gpu/vaapi/vaapi_video_encode_accelerator.h
@@ -52,7 +52,9 @@ class MEDIA_GPU_EXPORT VaapiVideoEncodeA
  private:
   class H264Accelerator;
   class VP8Accelerator;
+#if VA_CHECK_VERSION(0, 39, 2)
   class VP9Accelerator;
+#endif
 
   // Encoder state.
   enum State {
Index: dev/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
+++ dev/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
@@ -196,6 +196,7 @@ class VaapiVideoEncodeAccelerator::VP8Ac
   VaapiVideoEncodeAccelerator* const vea_;
 };
 
+#if VA_CHECK_VERSION(0, 39, 2)
 class VaapiVideoEncodeAccelerator::VP9Accelerator
     : public VP9Encoder::Accelerator {
  public:
@@ -216,6 +217,7 @@ class VaapiVideoEncodeAccelerator::VP9Ac
  private:
   VaapiVideoEncodeAccelerator* const vea_;
 };
+#endif
 
 VaapiVideoEncodeAccelerator::VaapiVideoEncodeAccelerator()
     : codec_(kUnknownVideoCodec),
@@ -342,10 +344,12 @@ void VaapiVideoEncodeAccelerator::Initia
           std::make_unique<VP8Encoder>(std::make_unique<VP8Accelerator>(this));
       break;
 
+#if VA_CHECK_VERSION(0, 39, 2)
     case kCodecVP9:
       encoder_ =
           std::make_unique<VP9Encoder>(std::make_unique<VP9Accelerator>(this));
       break;
+#endif
 
     default:
       NOTREACHED() << "Unsupported codec type " << GetCodecName(codec_);
@@ -1205,6 +1209,7 @@ bool VaapiVideoEncodeAccelerator::VP8Acc
   return true;
 }
 
+#if VA_CHECK_VERSION(0, 39, 2)
 scoped_refptr<VP9Picture>
 VaapiVideoEncodeAccelerator::VP9Accelerator::GetPicture(
     AcceleratedVideoEncoder::EncodeJob* job) {
@@ -1336,5 +1341,6 @@ bool VaapiVideoEncodeAccelerator::VP9Acc
 
   return true;
 }
+#endif
 
 }  // namespace media
Index: dev/content/browser/indexed_db/indexed_db_leveldb_operations.cc
===================================================================
--- dev.orig/content/browser/indexed_db/indexed_db_leveldb_operations.cc
+++ dev/content/browser/indexed_db/indexed_db_leveldb_operations.cc
@@ -150,7 +150,7 @@ DeleteAndRecreateDatabase(
     ReportOpenStatus(
         indexed_db::INDEXED_DB_BACKING_STORE_OPEN_CLEANUP_DESTROY_FAILED,
         origin);
-    return {nullptr, status, false};
+    return std::make_tuple(nullptr, status, false);
   }
 
   LOG(ERROR) << "IndexedDB backing store cleanup succeeded, reopening";
@@ -164,7 +164,7 @@ DeleteAndRecreateDatabase(
     ReportOpenStatus(
         indexed_db::INDEXED_DB_BACKING_STORE_OPEN_CLEANUP_REOPEN_FAILED,
         origin);
-    return {nullptr, status, is_disk_full};
+    return std::make_tuple(nullptr, status, is_disk_full);
   }
   std::unique_ptr<LevelDBDatabase> database = std::make_unique<LevelDBDatabase>(
       std::move(state), std::move(task_runner),
@@ -172,7 +172,7 @@ DeleteAndRecreateDatabase(
   ReportOpenStatus(
       indexed_db::INDEXED_DB_BACKING_STORE_OPEN_CLEANUP_REOPEN_SUCCESS, origin);
 
-  return {std::move(database), status, is_disk_full};
+  return std::make_tuple(std::move(database), status, is_disk_full);
 }
 
 }  // namespace
@@ -682,7 +682,7 @@ CreateDatabaseDirectories(const base::Fi
                << "\"";
     ReportOpenStatus(indexed_db::INDEXED_DB_BACKING_STORE_OPEN_FAILED_DIRECTORY,
                      origin);
-    return {base::FilePath(), base::FilePath(), status};
+    return std::make_tuple(base::FilePath(), base::FilePath(), status);
   }
 
   base::FilePath leveldb_path = path_base.Append(GetLevelDBFileName(origin));
@@ -691,9 +691,9 @@ CreateDatabaseDirectories(const base::Fi
     ReportOpenStatus(indexed_db::INDEXED_DB_BACKING_STORE_OPEN_ORIGIN_TOO_LONG,
                      origin);
     status = Status::IOError("File path too long");
-    return {base::FilePath(), base::FilePath(), status};
+    return std::make_tuple(base::FilePath(), base::FilePath(), status);
   }
-  return {leveldb_path, blob_path, status};
+  return std::make_tuple(leveldb_path, blob_path, status);
 }
 
 std::tuple<std::unique_ptr<LevelDBDatabase>,
@@ -725,7 +725,7 @@ OpenAndVerifyLevelDBDatabase(
   if (status.IsIOError()) {
     ReportOpenStatus(indexed_db::INDEXED_DB_BACKING_STORE_OPEN_NO_RECOVERY,
                      origin);
-    return {std::move(database), status, IndexedDBDataLossInfo(), is_disk_full};
+    return std::make_tuple(std::move(database), status, IndexedDBDataLossInfo(), is_disk_full);
   }
 
   IndexedDBDataLossInfo data_loss_info;
@@ -742,7 +742,7 @@ OpenAndVerifyLevelDBDatabase(
       ReportOpenStatus(indexed_db::INDEXED_DB_BACKING_STORE_OPEN_SUCCESS,
                        origin);
     }
-    return {std::move(database), status, data_loss_info, is_disk_full};
+    return std::make_tuple(std::move(database), status, data_loss_info, is_disk_full);
   }
   // The leveldb database is successfully opened.
   DCHECK(status.ok());
@@ -794,7 +794,7 @@ OpenAndVerifyLevelDBDatabase(
 
   if (status.ok())
     ReportOpenStatus(indexed_db::INDEXED_DB_BACKING_STORE_OPEN_SUCCESS, origin);
-  return {std::move(database), status, data_loss_info, is_disk_full};
+  return std::make_tuple(std::move(database), status, data_loss_info, is_disk_full);
 }
 
 }  // namespace indexed_db
Index: dev/content/browser/indexed_db/leveldb/leveldb_env.cc
===================================================================
--- dev.orig/content/browser/indexed_db/leveldb/leveldb_env.cc
+++ dev/content/browser/indexed_db/leveldb/leveldb_env.cc
@@ -82,13 +82,13 @@ DefaultLevelDBFactory::OpenLevelDB(
       LOG(ERROR) << "Failed to open in-memory LevelDB database: "
                  << status.ToString();
       // Must match the other returns in this function for RVO.
-      return {nullptr, status, false};
+      return std::make_tuple(nullptr, status, false);
     }
 
-    return {LevelDBState::CreateForInMemoryDB(
+    return std::make_tuple(LevelDBState::CreateForInMemoryDB(
                 std::move(in_memory_env), ldb_comparator, idb_comparator,
                 std::move(db), "in-memory-database"),
-            status, false};
+            status, false);
   }
 
   leveldb_env::Options options =
@@ -115,16 +115,16 @@ DefaultLevelDBFactory::OpenLevelDB(
     LOG(ERROR) << "Failed to open LevelDB database from "
                << file_name.AsUTF8Unsafe() << "," << status.ToString();
     // Must match the other returns in this function for RVO.
-    return {nullptr, status, is_disk_full};
+    return std::make_tuple(nullptr, status, is_disk_full);
   }
 
   UMA_HISTOGRAM_MEDIUM_TIMES("WebCore.IndexedDB.LevelDB.OpenTime",
                              base::TimeTicks::Now() - begin_time);
 
   // Must match the other returns in this function for RVO.
-  return {LevelDBState::CreateForDiskDB(ldb_comparator, idb_comparator,
+  return std::make_tuple(LevelDBState::CreateForDiskDB(ldb_comparator, idb_comparator,
                                         std::move(db), std::move(file_name)),
-          status, false};
+          status, false);
 }
 
 leveldb::Status DefaultLevelDBFactory::DestroyLevelDB(
