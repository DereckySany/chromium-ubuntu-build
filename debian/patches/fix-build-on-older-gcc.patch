Index: beta/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
===================================================================
--- beta.orig/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
+++ beta/media/gpu/vaapi/vaapi_jpeg_decode_accelerator.cc
@@ -62,7 +62,7 @@ static bool VerifyDataSize(const VAImage
   const gfx::Size dimensions(base::strict_cast<int>(image->width),
                              base::strict_cast<int>(image->height));
   size_t min_size = 0;
-  if (image->format.fourcc == VA_FOURCC_I420) {
+  if (image->format.fourcc == VA_FOURCC('I', '4', '2', '0')) {
     min_size = VideoFrame::AllocationSize(PIXEL_FORMAT_I420, dimensions);
   } else if (image->format.fourcc == VA_FOURCC_YUY2 ||
              image->format.fourcc == VA_FOURCC('Y', 'U', 'Y', 'V')) {
@@ -155,7 +155,7 @@ bool VaapiJpegDecodeAccelerator::OutputP
   size_t dst_v_stride = video_frame->stride(VideoFrame::kVPlane);
 
   switch (image->format.fourcc) {
-    case VA_FOURCC_I420: {
+    case VA_FOURCC('I', '4', '2', '0'): {
       DCHECK_EQ(image->num_planes, 3u);
       const uint8_t* src_y = mem + image->offsets[0];
       const uint8_t* src_u = mem + image->offsets[1];
Index: beta/media/gpu/vaapi/vaapi_jpeg_decoder.cc
===================================================================
--- beta.orig/media/gpu/vaapi/vaapi_jpeg_decoder.cc
+++ beta/media/gpu/vaapi/vaapi_jpeg_decoder.cc
@@ -24,7 +24,7 @@ namespace media {
 namespace {
 
 constexpr VAImageFormat kImageFormatI420 = {
-    .fourcc = VA_FOURCC_I420,
+    .fourcc = VA_FOURCC('I', '4', '2', '0'),
     .byte_order = VA_LSB_FIRST,
     .bits_per_pixel = 12,
 };
Index: beta/media/gpu/vaapi/vaapi_video_encode_accelerator.h
===================================================================
--- beta.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.h
+++ beta/media/gpu/vaapi/vaapi_video_encode_accelerator.h
@@ -52,7 +52,9 @@ class MEDIA_GPU_EXPORT VaapiVideoEncodeA
  private:
   class H264Accelerator;
   class VP8Accelerator;
+#if VA_CHECK_VERSION(0, 39, 2)
   class VP9Accelerator;
+#endif
 
   // Encoder state.
   enum State {
Index: beta/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
===================================================================
--- beta.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
+++ beta/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
@@ -196,6 +196,7 @@ class VaapiVideoEncodeAccelerator::VP8Ac
   VaapiVideoEncodeAccelerator* const vea_;
 };
 
+#if VA_CHECK_VERSION(0, 39, 2)
 class VaapiVideoEncodeAccelerator::VP9Accelerator
     : public VP9Encoder::Accelerator {
  public:
@@ -216,6 +217,7 @@ class VaapiVideoEncodeAccelerator::VP9Ac
  private:
   VaapiVideoEncodeAccelerator* const vea_;
 };
+#endif
 
 VaapiVideoEncodeAccelerator::VaapiVideoEncodeAccelerator()
     : codec_(kUnknownVideoCodec),
@@ -342,10 +344,12 @@ void VaapiVideoEncodeAccelerator::Initia
           std::make_unique<VP8Encoder>(std::make_unique<VP8Accelerator>(this));
       break;
 
+#if VA_CHECK_VERSION(0, 39, 2)
     case kCodecVP9:
       encoder_ =
           std::make_unique<VP9Encoder>(std::make_unique<VP9Accelerator>(this));
       break;
+#endif
 
     default:
       NOTREACHED() << "Unsupported codec type " << GetCodecName(codec_);
@@ -1205,6 +1209,7 @@ bool VaapiVideoEncodeAccelerator::VP8Acc
   return true;
 }
 
+#if VA_CHECK_VERSION(0, 39, 2)
 scoped_refptr<VP9Picture>
 VaapiVideoEncodeAccelerator::VP9Accelerator::GetPicture(
     AcceleratedVideoEncoder::EncodeJob* job) {
@@ -1336,5 +1341,6 @@ bool VaapiVideoEncodeAccelerator::VP9Acc
 
   return true;
 }
+#endif
 
 }  // namespace media
Index: beta/media/gpu/vaapi/vaapi_wrapper.cc
===================================================================
--- beta.orig/media/gpu/vaapi/vaapi_wrapper.cc
+++ beta/media/gpu/vaapi/vaapi_wrapper.cc
@@ -1049,7 +1049,11 @@ scoped_refptr<VASurface> VaapiWrapper::C
   }
   // We only have to pass the first file descriptor to a driver. A VA-API driver
   // shall create a VASurface from the single fd correctly.
+#if VA_CHECK_VERSION(1, 0, 0)
   uintptr_t fd = base::checked_cast<uintptr_t>(pixmap->GetDmaBufFd(0));
+#else
+  unsigned long fd = base::checked_cast<unsigned long>(pixmap->GetDmaBufFd(0));
+#endif
   va_attrib_extbuf.buffers = &fd;
   va_attrib_extbuf.num_buffers = 1u;
 
