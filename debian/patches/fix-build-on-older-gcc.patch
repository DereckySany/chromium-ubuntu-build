Index: dev/media/gpu/vaapi/vaapi_mjpeg_decode_accelerator.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_mjpeg_decode_accelerator.cc
+++ dev/media/gpu/vaapi/vaapi_mjpeg_decode_accelerator.cc
@@ -70,9 +70,10 @@ static bool VerifyDataSize(const VAImage
   const gfx::Size dimensions(base::strict_cast<int>(image->width),
                              base::strict_cast<int>(image->height));
   size_t min_size = 0;
-  if (image->format.fourcc == VA_FOURCC_I420) {
+  if (image->format.fourcc == VA_FOURCC('I', '4', '2', '0')) {
     min_size = VideoFrame::AllocationSize(PIXEL_FORMAT_I420, dimensions);
-  } else if (image->format.fourcc == VA_FOURCC_YUY2 ||
+  } else
+	  if (image->format.fourcc == VA_FOURCC_YUY2 ||
              image->format.fourcc == VA_FOURCC('Y', 'U', 'Y', 'V')) {
     min_size = VideoFrame::AllocationSize(PIXEL_FORMAT_YUY2, dimensions);
   } else {
@@ -172,7 +173,7 @@ bool VaapiMjpegDecodeAccelerator::Output
   size_t dst_v_stride = video_frame->stride(VideoFrame::kVPlane);
 
   switch (image->format.fourcc) {
-    case VA_FOURCC_I420: {
+    case VA_FOURCC('I', '4', '2', '0'): {
       DCHECK_EQ(image->num_planes, 3u);
       const uint8_t* src_y = mem + image->offsets[0];
       const uint8_t* src_u = mem + image->offsets[1];
Index: dev/media/gpu/vaapi/vaapi_video_encode_accelerator.h
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.h
+++ dev/media/gpu/vaapi/vaapi_video_encode_accelerator.h
@@ -51,7 +51,9 @@ class MEDIA_GPU_EXPORT VaapiVideoEncodeA
  private:
   class H264Accelerator;
   class VP8Accelerator;
+#if VA_CHECK_VERSION(0, 39, 2)
   class VP9Accelerator;
+#endif
 
   // Encoder state.
   enum State {
Index: dev/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
+++ dev/media/gpu/vaapi/vaapi_video_encode_accelerator.cc
@@ -197,6 +197,7 @@ class VaapiVideoEncodeAccelerator::VP8Ac
   VaapiVideoEncodeAccelerator* const vea_;
 };
 
+#if VA_CHECK_VERSION(0, 39, 2)
 class VaapiVideoEncodeAccelerator::VP9Accelerator
     : public VP9Encoder::Accelerator {
  public:
@@ -218,6 +219,7 @@ class VaapiVideoEncodeAccelerator::VP9Ac
  private:
   VaapiVideoEncodeAccelerator* const vea_;
 };
+#endif
 
 VaapiVideoEncodeAccelerator::VaapiVideoEncodeAccelerator()
     : codec_(kUnknownVideoCodec),
@@ -344,10 +346,12 @@ void VaapiVideoEncodeAccelerator::Initia
           std::make_unique<VP8Encoder>(std::make_unique<VP8Accelerator>(this));
       break;
 
+#if VA_CHECK_VERSION(0, 39, 2)
     case kCodecVP9:
       encoder_ =
           std::make_unique<VP9Encoder>(std::make_unique<VP9Accelerator>(this));
       break;
+#endif
 
     default:
       NOTREACHED() << "Unsupported codec type " << GetCodecName(codec_);
@@ -1224,6 +1228,7 @@ bool VaapiVideoEncodeAccelerator::VP8Acc
   return true;
 }
 
+#if VA_CHECK_VERSION(0, 39, 2)
 scoped_refptr<VP9Picture>
 VaapiVideoEncodeAccelerator::VP9Accelerator::GetPicture(
     AcceleratedVideoEncoder::EncodeJob* job) {
@@ -1354,5 +1359,6 @@ bool VaapiVideoEncodeAccelerator::VP9Acc
 
   return true;
 }
+#endif
 
 }  // namespace media
Index: dev/media/gpu/vaapi/vaapi_wrapper.cc
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_wrapper.cc
+++ dev/media/gpu/vaapi/vaapi_wrapper.cc
@@ -961,10 +961,10 @@ bool VASupportedImageFormats::InitSuppor
     // Remove this workaround once b/128340287 is resolved.
     if (std::find_if(supported_formats_.cbegin(), supported_formats_.cend(),
                      [](const VAImageFormat& format) {
-                       return format.fourcc == VA_FOURCC_I420;
+                       return format.fourcc == VA_FOURCC('I', '4', '2', '0');
                      }) == supported_formats_.cend()) {
       VAImageFormat i420_format{};
-      i420_format.fourcc = VA_FOURCC_I420;
+      i420_format.fourcc = VA_FOURCC('I', '4', '2', '0');
       supported_formats_.push_back(i420_format);
     }
   } else if (base::StartsWith(VADisplayState::Get()->va_vendor_string(),
@@ -976,7 +976,7 @@ bool VASupportedImageFormats::InitSuppor
     supported_formats_.erase(
         std::remove_if(supported_formats_.begin(), supported_formats_.end(),
                        [](const VAImageFormat& format) {
-                         return format.fourcc != VA_FOURCC_I420 &&
+                         return format.fourcc != VA_FOURCC('I', '4', '2', '0') &&
                                 format.fourcc != VA_FOURCC_NV12;
                        }),
         supported_formats_.end());
@@ -1140,7 +1140,7 @@ bool VaapiWrapper::GetJpegDecodeSuitable
     // The VAAPI mesa state tracker only supports conversion from NV12 to YV12
     // and IYUV (synonym of I420).
     if (rt_format == VA_RT_FORMAT_YUV420) {
-      if (preferred_fourcc != VA_FOURCC_I420 &&
+      if (preferred_fourcc != VA_FOURCC('I', '4', '2', '0') &&
           preferred_fourcc != VA_FOURCC_YV12) {
         preferred_fourcc = VA_FOURCC_NV12;
       }
@@ -1172,13 +1172,13 @@ bool VaapiWrapper::GetJpegDecodeSuitable
     //
     if (preferred_fourcc == VA_FOURCC_422H ||
         preferred_fourcc == VA_FOURCC_P010) {
-      preferred_fourcc = VA_FOURCC_I420;
+      preferred_fourcc = VA_FOURCC('I', '4', '2', '0');
     }
   }
 
   if (!VASupportedImageFormats::Get().IsImageFormatSupported(
           VAImageFormat{.fourcc = preferred_fourcc})) {
-    preferred_fourcc = VA_FOURCC_I420;
+    preferred_fourcc = VA_FOURCC('I', '4', '2', '0');
   }
 
   // After workarounds, assume the conversion is supported.
@@ -1326,7 +1326,11 @@ scoped_refptr<VASurface> VaapiWrapper::C
   }
   // We only have to pass the first file descriptor to a driver. A VA-API driver
   // shall create a VASurface from the single fd correctly.
+#if VA_CHECK_VERSION(1, 0, 0)
   uintptr_t fd = base::checked_cast<uintptr_t>(pixmap->GetDmaBufFd(0));
+#else
+  unsigned long fd = base::checked_cast<unsigned long>(pixmap->GetDmaBufFd(0));
+#endif
   va_attrib_extbuf.buffers = &fd;
   va_attrib_extbuf.num_buffers = 1u;
 
@@ -1772,11 +1776,13 @@ bool VaapiWrapper::Initialize(CodecMode
 
   VAEntrypoint entrypoint = GetVaEntryPoint(mode, va_profile);
 
+#if VA_CHECK_VERSION(0, 39, 1)
   if (mode == CodecMode::kEncode && IsLowPowerEncSupported(va_profile) &&
       base::FeatureList::IsEnabled(kVaapiLowPowerEncoder)) {
     entrypoint = VAEntrypointEncSliceLP;
     DVLOG(2) << "Enable VA-API Low-Power Encode Entrypoint";
   }
+#endif
 
   base::AutoLock auto_lock(*va_lock_);
   std::vector<VAConfigAttrib> required_attribs;
@@ -1895,6 +1901,7 @@ void VaapiWrapper::TryToSetVADisplayAttr
     DVLOG(2) << "vaSetDisplayAttributes unsupported, ignoring by default.";
 }
 
+#if VA_CHECK_VERSION(0, 39, 1)
 // Check the support for low-power encode
 bool VaapiWrapper::IsLowPowerEncSupported(VAProfile va_profile) const {
   // Only enabled for H264/AVC
@@ -1929,5 +1936,6 @@ bool VaapiWrapper::IsLowPowerEncSupporte
   }
   return true;
 }
+#endif
 
 }  // namespace media
Index: dev/media/gpu/vaapi/vaapi_wrapper.h
===================================================================
--- dev.orig/media/gpu/vaapi/vaapi_wrapper.h
+++ dev/media/gpu/vaapi/vaapi_wrapper.h
@@ -297,8 +297,10 @@ class MEDIA_GPU_EXPORT VaapiWrapper
   // Attempt to set render mode to "render to texture.". Failure is non-fatal.
   void TryToSetVADisplayAttributeToLocalGPU();
 
+#if VA_CHECK_VERSION(0, 39, 1)
   // Check low-power encode support for the given profile
   bool IsLowPowerEncSupported(VAProfile va_profile) const;
+#endif
 
   // Pointer to VADisplayState's member |va_lock_|. Guaranteed to be valid for
   // the lifetime of VaapiWrapper.
